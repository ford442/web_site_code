(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const r of n)if(r.type==="childList")for(const o of r.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function e(n){const r={};return n.integrity&&(r.integrity=n.integrity),n.referrerPolicy&&(r.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?r.credentials="include":n.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(n){if(n.ep)return;n.ep=!0;const r=e(n);fetch(n.href,r)}})();/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Ca="171",Wn=3,Vr=0,$r=1,Nu=2,Tu=0,zr=1,vu=2,Lo=100,Bo=204,Po=205,Do=3,wu=0,Cr=0,Yr=300,Mu=301,_u=302,ko=1e3,on=1001,Uo=1002,Ds=1003,Ra=1006,Ea=1008,bu=1008,Su=1009,Au=1013,Fa=1014,Ia=1015,dn=1016,Vu=1020,zu=1023,Xi=1026,Wo=1027,qo=1030,Rr=0,Cu=1,gi="",oe="srgb",Er="srgb-linear",Go="linear",cn="srgb",xs=7680,Ho=519,Ru=513,yi=35044,an=35048,cs=2e3,ks=2001;class ps{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[t]===void 0&&(s[t]=[]),s[t].indexOf(e)===-1&&s[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const s=this._listeners;return s[t]!==void 0&&s[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const n=this._listeners[t];if(n!==void 0){const r=n.indexOf(e);r!==-1&&n.splice(r,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const s=this._listeners[t.type];if(s!==void 0){t.target=this;const n=s.slice(0);for(let r=0,o=n.length;r<o;r++)n[r].call(this,t);t.target=null}}}const zt=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let jo=1234567;const Oa=Math.PI/180,La=180/Math.PI;function Ae(){const i=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(zt[i&255]+zt[i>>8&255]+zt[i>>16&255]+zt[i>>24&255]+"-"+zt[t&255]+zt[t>>8&255]+"-"+zt[t>>16&15|64]+zt[t>>24&255]+"-"+zt[e&63|128]+zt[e>>8&255]+"-"+zt[e>>16&255]+zt[e>>24&255]+zt[s&255]+zt[s>>8&255]+zt[s>>16&255]+zt[s>>24&255]).toLowerCase()}function G(i,t,e){return Math.max(t,Math.min(e,i))}function Zr(i,t){return(i%t+t)%t}function Eu(i,t,e,s,n){return s+(i-t)*(n-s)/(e-t)}function Fu(i,t,e){return i!==t?(e-i)/(t-i):0}function hn(i,t,e){return(1-e)*i+e*t}function Iu(i,t,e,s){return hn(i,t,1-Math.exp(-e*s))}function Ou(i,t=1){return t-Math.abs(Zr(i,t*2)-t)}function Lu(i,t,e){return i<=t?0:i>=e?1:(i=(i-t)/(e-t),i*i*(3-2*i))}function Bu(i,t,e){return i<=t?0:i>=e?1:(i=(i-t)/(e-t),i*i*i*(i*(i*6-15)+10))}function Pu(i,t){return i+Math.floor(Math.random()*(t-i+1))}function Du(i,t){return i+Math.random()*(t-i)}function ku(i){return i*(.5-Math.random())}function Uu(i){i!==void 0&&(jo=i);let t=jo+=1831565813;return t=Math.imul(t^t>>>15,t|1),t^=t+Math.imul(t^t>>>7,t|61),((t^t>>>14)>>>0)/4294967296}function Wu(i){return i*Oa}function qu(i){return i*La}function Gu(i){return(i&i-1)===0&&i!==0}function Hu(i){return Math.pow(2,Math.ceil(Math.log(i)/Math.LN2))}function ju(i){return Math.pow(2,Math.floor(Math.log(i)/Math.LN2))}function Xu(i,t,e,s,n){const r=Math.cos,o=Math.sin,a=r(e/2),c=o(e/2),h=r((t+s)/2),l=o((t+s)/2),d=r((t-s)/2),p=o((t-s)/2),m=r((s-t)/2),f=o((s-t)/2);switch(n){case"XYX":i.set(a*l,c*d,c*p,a*h);break;case"YZY":i.set(c*p,a*l,c*d,a*h);break;case"ZXZ":i.set(c*d,c*p,a*l,a*h);break;case"XZX":i.set(a*l,c*f,c*m,a*h);break;case"YXY":i.set(c*m,a*l,c*f,a*h);break;case"ZYZ":i.set(c*f,c*m,a*l,a*h);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+n)}}function ae(i,t){switch(t.constructor){case Float32Array:return i;case Uint32Array:return i/4294967295;case Uint16Array:return i/65535;case Uint8Array:return i/255;case Int32Array:return Math.max(i/2147483647,-1);case Int16Array:return Math.max(i/32767,-1);case Int8Array:return Math.max(i/127,-1);default:throw new Error("Invalid component type.")}}function Q(i,t){switch(t.constructor){case Float32Array:return i;case Uint32Array:return Math.round(i*4294967295);case Uint16Array:return Math.round(i*65535);case Uint8Array:return Math.round(i*255);case Int32Array:return Math.round(i*2147483647);case Int16Array:return Math.round(i*32767);case Int8Array:return Math.round(i*127);default:throw new Error("Invalid component type.")}}const Ba={DEG2RAD:Oa,RAD2DEG:La,generateUUID:Ae,clamp:G,euclideanModulo:Zr,mapLinear:Eu,inverseLerp:Fu,lerp:hn,damp:Iu,pingpong:Ou,smoothstep:Lu,smootherstep:Bu,randInt:Pu,randFloat:Du,randFloatSpread:ku,seededRandom:Uu,degToRad:Wu,radToDeg:qu,isPowerOfTwo:Gu,ceilPowerOfTwo:Hu,floorPowerOfTwo:ju,setQuaternionFromProperEuler:Xu,normalize:Q,denormalize:ae};class gt{constructor(t=0,e=0){gt.prototype.isVector2=!0,this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,s=this.y,n=t.elements;return this.x=n[0]*e+n[3]*s+n[6],this.y=n[1]*e+n[4]*s+n[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=G(this.x,t.x,e.x),this.y=G(this.y,t.y,e.y),this}clampScalar(t,e){return this.x=G(this.x,t,e),this.y=G(this.y,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(G(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(G(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y;return e*e+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const s=Math.cos(e),n=Math.sin(e),r=this.x-t.x,o=this.y-t.y;return this.x=r*s-o*n+t.x,this.y=r*n+o*s+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class te{constructor(t,e,s,n,r,o,a,c,h){te.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],t!==void 0&&this.set(t,e,s,n,r,o,a,c,h)}set(t,e,s,n,r,o,a,c,h){const l=this.elements;return l[0]=t,l[1]=n,l[2]=a,l[3]=e,l[4]=r,l[5]=c,l[6]=s,l[7]=o,l[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}extractBasis(t,e,s){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,n=e.elements,r=this.elements,o=s[0],a=s[3],c=s[6],h=s[1],l=s[4],d=s[7],p=s[2],m=s[5],f=s[8],x=n[0],v=n[3],A=n[6],F=n[1],O=n[4],E=n[7],B=n[2],P=n[5],I=n[8];return r[0]=o*x+a*F+c*B,r[3]=o*v+a*O+c*P,r[6]=o*A+a*E+c*I,r[1]=h*x+l*F+d*B,r[4]=h*v+l*O+d*P,r[7]=h*A+l*E+d*I,r[2]=p*x+m*F+f*B,r[5]=p*v+m*O+f*P,r[8]=p*A+m*E+f*I,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[1],n=t[2],r=t[3],o=t[4],a=t[5],c=t[6],h=t[7],l=t[8];return e*o*l-e*a*h-s*r*l+s*a*c+n*r*h-n*o*c}invert(){const t=this.elements,e=t[0],s=t[1],n=t[2],r=t[3],o=t[4],a=t[5],c=t[6],h=t[7],l=t[8],d=l*o-a*h,p=a*c-l*r,m=h*r-o*c,f=e*d+s*p+n*m;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const x=1/f;return t[0]=d*x,t[1]=(n*h-l*s)*x,t[2]=(a*s-n*o)*x,t[3]=p*x,t[4]=(l*e-n*c)*x,t[5]=(n*r-a*e)*x,t[6]=m*x,t[7]=(s*c-h*e)*x,t[8]=(o*e-s*r)*x,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,s,n,r,o,a){const c=Math.cos(r),h=Math.sin(r);return this.set(s*c,s*h,-s*(c*o+h*a)+o+t,-n*h,n*c,-n*(-h*o+c*a)+a+e,0,0,1),this}scale(t,e){return this.premultiply($i.makeScale(t,e)),this}rotate(t){return this.premultiply($i.makeRotation(-t)),this}translate(t,e){return this.premultiply($i.makeTranslation(t,e)),this}makeTranslation(t,e){return t.isVector2?this.set(1,0,t.x,0,1,t.y,0,0,1):this.set(1,0,t,0,1,e,0,0,1),this}makeRotation(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,s,e,0,0,0,1),this}makeScale(t,e){return this.set(t,0,0,0,e,0,0,0,1),this}equals(t){const e=this.elements,s=t.elements;for(let n=0;n<9;n++)if(e[n]!==s[n])return!1;return!0}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return new this.constructor().fromArray(this.elements)}}const $i=new te;function $u(i){for(let t=i.length-1;t>=0;--t)if(i[t]>=65535)return!0;return!1}function Xo(i){return document.createElementNS("http://www.w3.org/1999/xhtml",i)}const $o=new te().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Yo=new te().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function Yu(){const i={enabled:!0,workingColorSpace:Er,spaces:{},convert:function(n,r,o){return this.enabled===!1||r===o||!r||!o||(this.spaces[r].transfer===cn&&(n.r=Ve(n.r),n.g=Ve(n.g),n.b=Ve(n.b)),this.spaces[r].primaries!==this.spaces[o].primaries&&(n.applyMatrix3(this.spaces[r].toXYZ),n.applyMatrix3(this.spaces[o].fromXYZ)),this.spaces[o].transfer===cn&&(n.r=Ls(n.r),n.g=Ls(n.g),n.b=Ls(n.b))),n},fromWorkingColorSpace:function(n,r){return this.convert(n,this.workingColorSpace,r)},toWorkingColorSpace:function(n,r){return this.convert(n,r,this.workingColorSpace)},getPrimaries:function(n){return this.spaces[n].primaries},getTransfer:function(n){return n===gi?Go:this.spaces[n].transfer},getLuminanceCoefficients:function(n,r=this.workingColorSpace){return n.fromArray(this.spaces[r].luminanceCoefficients)},define:function(n){Object.assign(this.spaces,n)},_getMatrix:function(n,r,o){return n.copy(this.spaces[r].toXYZ).multiply(this.spaces[o].fromXYZ)},_getDrawingBufferColorSpace:function(n){return this.spaces[n].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(n=this.workingColorSpace){return this.spaces[n].workingColorSpaceConfig.unpackColorSpace}},t=[.64,.33,.3,.6,.15,.06],e=[.2126,.7152,.0722],s=[.3127,.329];return i.define({[Er]:{primaries:t,whitePoint:s,transfer:Go,toXYZ:$o,fromXYZ:Yo,luminanceCoefficients:e,workingColorSpaceConfig:{unpackColorSpace:oe},outputColorSpaceConfig:{drawingBufferColorSpace:oe}},[oe]:{primaries:t,whitePoint:s,transfer:cn,toXYZ:$o,fromXYZ:Yo,luminanceCoefficients:e,outputColorSpaceConfig:{drawingBufferColorSpace:oe}}}),i}const ht=Yu();function Ve(i){return i<.04045?i*.0773993808:Math.pow(i*.9478672986+.0521327014,2.4)}function Ls(i){return i<.0031308?i*12.92:1.055*Math.pow(i,.41666)-.055}let Ns;class Zu{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement>"u")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Ns===void 0&&(Ns=Xo("canvas")),Ns.width=t.width,Ns.height=t.height;const s=Ns.getContext("2d");t instanceof ImageData?s.putImageData(t,0,0):s.drawImage(t,0,0,t.width,t.height),e=Ns}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}static sRGBToLinear(t){if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap){const e=Xo("canvas");e.width=t.width,e.height=t.height;const s=e.getContext("2d");s.drawImage(t,0,0,t.width,t.height);const n=s.getImageData(0,0,t.width,t.height),r=n.data;for(let o=0;o<r.length;o++)r[o]=Ve(r[o]/255)*255;return s.putImageData(n,0,0),e}else if(t.data){const e=t.data.slice(0);for(let s=0;s<e.length;s++)e instanceof Uint8Array||e instanceof Uint8ClampedArray?e[s]=Math.floor(Ve(e[s]/255)*255):e[s]=Ve(e[s]);return{data:e,width:t.width,height:t.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),t}}let Ju=0;class Pa{constructor(t=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Ju++}),this.uuid=Ae(),this.data=t,this.dataReady=!0,this.version=0}set needsUpdate(t){t===!0&&this.version++}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.images[this.uuid]!==void 0)return t.images[this.uuid];const s={uuid:this.uuid,url:""},n=this.data;if(n!==null){let r;if(Array.isArray(n)){r=[];for(let o=0,a=n.length;o<a;o++)n[o].isDataTexture?r.push(Yi(n[o].image)):r.push(Yi(n[o]))}else r=Yi(n);s.url=r}return e||(t.images[this.uuid]=s),s}}function Yi(i){return typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&i instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&i instanceof ImageBitmap?Zu.getDataURL(i):i.data?{data:Array.from(i.data),width:i.width,height:i.height,type:i.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Qu=0;class Zt extends ps{constructor(t=Zt.DEFAULT_IMAGE,e=Zt.DEFAULT_MAPPING,s=on,n=on,r=Ra,o=Ea,a=zu,c=Su,h=Zt.DEFAULT_ANISOTROPY,l=gi){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Qu++}),this.uuid=Ae(),this.name="",this.source=new Pa(t),this.mipmaps=[],this.mapping=e,this.channel=0,this.wrapS=s,this.wrapT=n,this.magFilter=r,this.minFilter=o,this.anisotropy=h,this.format=a,this.internalFormat=null,this.type=c,this.offset=new gt(0,0),this.repeat=new gt(1,1),this.center=new gt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new te,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=l,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(t=null){this.source.data=t}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.source=t.source,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.channel=t.channel,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.colorSpace=t.colorSpace,this.userData=JSON.parse(JSON.stringify(t.userData)),this.needsUpdate=!0,this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const s={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(t).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),e||(t.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Yr)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case ko:t.x=t.x-Math.floor(t.x);break;case on:t.x=t.x<0?0:1;break;case Uo:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case ko:t.y=t.y-Math.floor(t.y);break;case on:t.y=t.y<0?0:1;break;case Uo:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(t){t===!0&&this.pmremVersion++}}Zt.DEFAULT_IMAGE=null;Zt.DEFAULT_MAPPING=Yr;Zt.DEFAULT_ANISOTROPY=1;class It{constructor(t=0,e=0,s=0,n=1){It.prototype.isVector4=!0,this.x=t,this.y=e,this.z=s,this.w=n}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,s,n){return this.x=t,this.y=e,this.z=s,this.w=n,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,s=this.y,n=this.z,r=this.w,o=t.elements;return this.x=o[0]*e+o[4]*s+o[8]*n+o[12]*r,this.y=o[1]*e+o[5]*s+o[9]*n+o[13]*r,this.z=o[2]*e+o[6]*s+o[10]*n+o[14]*r,this.w=o[3]*e+o[7]*s+o[11]*n+o[15]*r,this}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,s,n,r;const c=t.elements,h=c[0],l=c[4],d=c[8],p=c[1],m=c[5],f=c[9],x=c[2],v=c[6],A=c[10];if(Math.abs(l-p)<.01&&Math.abs(d-x)<.01&&Math.abs(f-v)<.01){if(Math.abs(l+p)<.1&&Math.abs(d+x)<.1&&Math.abs(f+v)<.1&&Math.abs(h+m+A-3)<.1)return this.set(1,0,0,0),this;e=Math.PI;const O=(h+1)/2,E=(m+1)/2,B=(A+1)/2,P=(l+p)/4,I=(d+x)/4,U=(f+v)/4;return O>E&&O>B?O<.01?(s=0,n=.707106781,r=.707106781):(s=Math.sqrt(O),n=P/s,r=I/s):E>B?E<.01?(s=.707106781,n=0,r=.707106781):(n=Math.sqrt(E),s=P/n,r=U/n):B<.01?(s=.707106781,n=.707106781,r=0):(r=Math.sqrt(B),s=I/r,n=U/r),this.set(s,n,r,e),this}let F=Math.sqrt((v-f)*(v-f)+(d-x)*(d-x)+(p-l)*(p-l));return Math.abs(F)<.001&&(F=1),this.x=(v-f)/F,this.y=(d-x)/F,this.z=(p-l)/F,this.w=Math.acos((h+m+A-1)/2),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=G(this.x,t.x,e.x),this.y=G(this.y,t.y,e.y),this.z=G(this.z,t.z,e.z),this.w=G(this.w,t.w,e.w),this}clampScalar(t,e){return this.x=G(this.x,t,e),this.y=G(this.y,t,e),this.z=G(this.z,t,e),this.w=G(this.w,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(G(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this.w=t.w+(e.w-t.w)*s,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Ci extends ps{constructor(t=1,e=1,s={}){super(),this.isRenderTarget=!0,this.width=t,this.height=e,this.depth=1,this.scissor=new It(0,0,t,e),this.scissorTest=!1,this.viewport=new It(0,0,t,e);const n={width:t,height:e,depth:1};s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Ra,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},s);const r=new Zt(n,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.colorSpace);r.flipY=!1,r.generateMipmaps=s.generateMipmaps,r.internalFormat=s.internalFormat,this.textures=[];const o=s.count;for(let a=0;a<o;a++)this.textures[a]=r.clone(),this.textures[a].isRenderTargetTexture=!0;this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.resolveDepthBuffer=s.resolveDepthBuffer,this.resolveStencilBuffer=s.resolveStencilBuffer,this.depthTexture=s.depthTexture,this.samples=s.samples}get texture(){return this.textures[0]}set texture(t){this.textures[0]=t}setSize(t,e,s=1){if(this.width!==t||this.height!==e||this.depth!==s){this.width=t,this.height=e,this.depth=s;for(let n=0,r=this.textures.length;n<r;n++)this.textures[n].image.width=t,this.textures[n].image.height=e,this.textures[n].image.depth=s;this.dispose()}this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){this.width=t.width,this.height=t.height,this.depth=t.depth,this.scissor.copy(t.scissor),this.scissorTest=t.scissorTest,this.viewport.copy(t.viewport),this.textures.length=0;for(let s=0,n=t.textures.length;s<n;s++)this.textures[s]=t.textures[s].clone(),this.textures[s].isRenderTargetTexture=!0;const e=Object.assign({},t.texture.image);return this.texture.source=new Pa(e),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.resolveDepthBuffer=t.resolveDepthBuffer,this.resolveStencilBuffer=t.resolveStencilBuffer,t.depthTexture!==null&&(this.depthTexture=t.depthTexture.clone()),this.samples=t.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Ku extends Zt{constructor(t=null,e=1,s=1,n=1){super(null),this.isDataArrayTexture=!0,this.image={data:t,width:e,height:s,depth:n},this.magFilter=Ds,this.minFilter=Ds,this.wrapR=on,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(t){this.layerUpdates.add(t)}clearLayerUpdates(){this.layerUpdates.clear()}}class yn{constructor(t=0,e=0,s=0,n=1){this.isQuaternion=!0,this._x=t,this._y=e,this._z=s,this._w=n}static slerpFlat(t,e,s,n,r,o,a){let c=s[n+0],h=s[n+1],l=s[n+2],d=s[n+3];const p=r[o+0],m=r[o+1],f=r[o+2],x=r[o+3];if(a===0){t[e+0]=c,t[e+1]=h,t[e+2]=l,t[e+3]=d;return}if(a===1){t[e+0]=p,t[e+1]=m,t[e+2]=f,t[e+3]=x;return}if(d!==x||c!==p||h!==m||l!==f){let v=1-a;const A=c*p+h*m+l*f+d*x,F=A>=0?1:-1,O=1-A*A;if(O>Number.EPSILON){const B=Math.sqrt(O),P=Math.atan2(B,A*F);v=Math.sin(v*P)/B,a=Math.sin(a*P)/B}const E=a*F;if(c=c*v+p*E,h=h*v+m*E,l=l*v+f*E,d=d*v+x*E,v===1-a){const B=1/Math.sqrt(c*c+h*h+l*l+d*d);c*=B,h*=B,l*=B,d*=B}}t[e]=c,t[e+1]=h,t[e+2]=l,t[e+3]=d}static multiplyQuaternionsFlat(t,e,s,n,r,o){const a=s[n],c=s[n+1],h=s[n+2],l=s[n+3],d=r[o],p=r[o+1],m=r[o+2],f=r[o+3];return t[e]=a*f+l*d+c*m-h*p,t[e+1]=c*f+l*p+h*d-a*m,t[e+2]=h*f+l*m+a*p-c*d,t[e+3]=l*f-a*d-c*p-h*m,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,s,n){return this._x=t,this._y=e,this._z=s,this._w=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e=!0){const s=t._x,n=t._y,r=t._z,o=t._order,a=Math.cos,c=Math.sin,h=a(s/2),l=a(n/2),d=a(r/2),p=c(s/2),m=c(n/2),f=c(r/2);switch(o){case"XYZ":this._x=p*l*d+h*m*f,this._y=h*m*d-p*l*f,this._z=h*l*f+p*m*d,this._w=h*l*d-p*m*f;break;case"YXZ":this._x=p*l*d+h*m*f,this._y=h*m*d-p*l*f,this._z=h*l*f-p*m*d,this._w=h*l*d+p*m*f;break;case"ZXY":this._x=p*l*d-h*m*f,this._y=h*m*d+p*l*f,this._z=h*l*f+p*m*d,this._w=h*l*d-p*m*f;break;case"ZYX":this._x=p*l*d-h*m*f,this._y=h*m*d+p*l*f,this._z=h*l*f-p*m*d,this._w=h*l*d+p*m*f;break;case"YZX":this._x=p*l*d+h*m*f,this._y=h*m*d+p*l*f,this._z=h*l*f-p*m*d,this._w=h*l*d-p*m*f;break;case"XZY":this._x=p*l*d-h*m*f,this._y=h*m*d-p*l*f,this._z=h*l*f+p*m*d,this._w=h*l*d+p*m*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return e===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const s=e/2,n=Math.sin(s);return this._x=t.x*n,this._y=t.y*n,this._z=t.z*n,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,s=e[0],n=e[4],r=e[8],o=e[1],a=e[5],c=e[9],h=e[2],l=e[6],d=e[10],p=s+a+d;if(p>0){const m=.5/Math.sqrt(p+1);this._w=.25/m,this._x=(l-c)*m,this._y=(r-h)*m,this._z=(o-n)*m}else if(s>a&&s>d){const m=2*Math.sqrt(1+s-a-d);this._w=(l-c)/m,this._x=.25*m,this._y=(n+o)/m,this._z=(r+h)/m}else if(a>d){const m=2*Math.sqrt(1+a-s-d);this._w=(r-h)/m,this._x=(n+o)/m,this._y=.25*m,this._z=(c+l)/m}else{const m=2*Math.sqrt(1+d-s-a);this._w=(o-n)/m,this._x=(r+h)/m,this._y=(c+l)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let s=t.dot(e)+1;return s<Number.EPSILON?(s=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=s):(this._x=0,this._y=-t.z,this._z=t.y,this._w=s)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=s),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(G(this.dot(t),-1,1)))}rotateTowards(t,e){const s=this.angleTo(t);if(s===0)return this;const n=Math.min(1,e/s);return this.slerp(t,n),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const s=t._x,n=t._y,r=t._z,o=t._w,a=e._x,c=e._y,h=e._z,l=e._w;return this._x=s*l+o*a+n*h-r*c,this._y=n*l+o*c+r*a-s*h,this._z=r*l+o*h+s*c-n*a,this._w=o*l-s*a-n*c-r*h,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const s=this._x,n=this._y,r=this._z,o=this._w;let a=o*t._w+s*t._x+n*t._y+r*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=o,this._x=s,this._y=n,this._z=r,this;const c=1-a*a;if(c<=Number.EPSILON){const m=1-e;return this._w=m*o+e*this._w,this._x=m*s+e*this._x,this._y=m*n+e*this._y,this._z=m*r+e*this._z,this.normalize(),this}const h=Math.sqrt(c),l=Math.atan2(h,a),d=Math.sin((1-e)*l)/h,p=Math.sin(e*l)/h;return this._w=o*d+this._w*p,this._x=s*d+this._x*p,this._y=n*d+this._y*p,this._z=r*d+this._z*p,this._onChangeCallback(),this}slerpQuaternions(t,e,s){return this.copy(t).slerp(e,s)}random(){const t=2*Math.PI*Math.random(),e=2*Math.PI*Math.random(),s=Math.random(),n=Math.sqrt(1-s),r=Math.sqrt(s);return this.set(n*Math.sin(t),n*Math.cos(t),r*Math.sin(e),r*Math.cos(e))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class S{constructor(t=0,e=0,s=0){S.prototype.isVector3=!0,this.x=t,this.y=e,this.z=s}set(t,e,s){return s===void 0&&(s=this.z),this.x=t,this.y=e,this.z=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return this.applyQuaternion(Zo.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Zo.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,s=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[3]*s+r[6]*n,this.y=r[1]*e+r[4]*s+r[7]*n,this.z=r[2]*e+r[5]*s+r[8]*n,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,s=this.y,n=this.z,r=t.elements,o=1/(r[3]*e+r[7]*s+r[11]*n+r[15]);return this.x=(r[0]*e+r[4]*s+r[8]*n+r[12])*o,this.y=(r[1]*e+r[5]*s+r[9]*n+r[13])*o,this.z=(r[2]*e+r[6]*s+r[10]*n+r[14])*o,this}applyQuaternion(t){const e=this.x,s=this.y,n=this.z,r=t.x,o=t.y,a=t.z,c=t.w,h=2*(o*n-a*s),l=2*(a*e-r*n),d=2*(r*s-o*e);return this.x=e+c*h+o*d-a*l,this.y=s+c*l+a*h-r*d,this.z=n+c*d+r*l-o*h,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,s=this.y,n=this.z,r=t.elements;return this.x=r[0]*e+r[4]*s+r[8]*n,this.y=r[1]*e+r[5]*s+r[9]*n,this.z=r[2]*e+r[6]*s+r[10]*n,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=G(this.x,t.x,e.x),this.y=G(this.y,t.y,e.y),this.z=G(this.z,t.z,e.z),this}clampScalar(t,e){return this.x=G(this.x,t,e),this.y=G(this.y,t,e),this.z=G(this.z,t,e),this}clampLength(t,e){const s=this.length();return this.divideScalar(s||1).multiplyScalar(G(s,t,e))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,s){return this.x=t.x+(e.x-t.x)*s,this.y=t.y+(e.y-t.y)*s,this.z=t.z+(e.z-t.z)*s,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,e){const s=t.x,n=t.y,r=t.z,o=e.x,a=e.y,c=e.z;return this.x=n*c-r*a,this.y=r*o-s*c,this.z=s*a-n*o,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const s=t.dot(this)/e;return this.copy(t).multiplyScalar(s)}projectOnPlane(t){return Zi.copy(this).projectOnVector(t),this.sub(Zi)}reflect(t){return this.sub(Zi.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const s=this.dot(t)/e;return Math.acos(G(s,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,s=this.y-t.y,n=this.z-t.z;return e*e+s*s+n*n}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,s){const n=Math.sin(e)*t;return this.x=n*Math.sin(s),this.y=Math.cos(e)*t,this.z=n*Math.cos(s),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,s){return this.x=t*Math.sin(e),this.y=s,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),s=this.setFromMatrixColumn(t,1).length(),n=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=s,this.z=n,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e){return this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,e=Math.random()*2-1,s=Math.sqrt(1-e*e);return this.x=s*Math.cos(t),this.y=e,this.z=s*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Zi=new S,Zo=new yn;class xn{constructor(t=new S(1/0,1/0,1/0),e=new S(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e+=3)this.expandByPoint(se.fromArray(t,e));return this}setFromBufferAttribute(t){this.makeEmpty();for(let e=0,s=t.count;e<s;e++)this.expandByPoint(se.fromBufferAttribute(t,e));return this}setFromPoints(t){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const s=se.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}setFromObject(t,e=!1){return this.makeEmpty(),this.expandByObject(t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,e=!1){t.updateWorldMatrix(!1,!1);const s=t.geometry;if(s!==void 0){const r=s.getAttribute("position");if(e===!0&&r!==void 0&&t.isInstancedMesh!==!0)for(let o=0,a=r.count;o<a;o++)t.isMesh===!0?t.getVertexPosition(o,se):se.fromBufferAttribute(r,o),se.applyMatrix4(t.matrixWorld),this.expandByPoint(se);else t.boundingBox!==void 0?(t.boundingBox===null&&t.computeBoundingBox(),qn.copy(t.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),qn.copy(s.boundingBox)),qn.applyMatrix4(t.matrixWorld),this.union(qn)}const n=t.children;for(let r=0,o=n.length;r<o;r++)this.expandByObject(n[r],e);return this}containsPoint(t){return t.x>=this.min.x&&t.x<=this.max.x&&t.y>=this.min.y&&t.y<=this.max.y&&t.z>=this.min.z&&t.z<=this.max.z}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return t.max.x>=this.min.x&&t.min.x<=this.max.x&&t.max.y>=this.min.y&&t.min.y<=this.max.y&&t.max.z>=this.min.z&&t.min.z<=this.max.z}intersectsSphere(t){return this.clampPoint(t.center,se),se.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,s;return t.normal.x>0?(e=t.normal.x*this.min.x,s=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,s=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,s+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,s+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,s+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,s+=t.normal.z*this.min.z),e<=-t.constant&&s>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter($s),Gn.subVectors(this.max,$s),Ts.subVectors(t.a,$s),vs.subVectors(t.b,$s),ws.subVectors(t.c,$s),Ue.subVectors(vs,Ts),We.subVectors(ws,vs),Ke.subVectors(Ts,ws);let e=[0,-Ue.z,Ue.y,0,-We.z,We.y,0,-Ke.z,Ke.y,Ue.z,0,-Ue.x,We.z,0,-We.x,Ke.z,0,-Ke.x,-Ue.y,Ue.x,0,-We.y,We.x,0,-Ke.y,Ke.x,0];return!Ji(e,Ts,vs,ws,Gn)||(e=[1,0,0,0,1,0,0,0,1],!Ji(e,Ts,vs,ws,Gn))?!1:(Hn.crossVectors(Ue,We),e=[Hn.x,Hn.y,Hn.z],Ji(e,Ts,vs,ws,Gn))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return this.clampPoint(t,se).distanceTo(t)}getBoundingSphere(t){return this.isEmpty()?t.makeEmpty():(this.getCenter(t.center),t.radius=this.getSize(se).length()*.5),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Te[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Te[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Te[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Te[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Te[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Te[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Te[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Te[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Te),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}const Te=[new S,new S,new S,new S,new S,new S,new S,new S],se=new S,qn=new xn,Ts=new S,vs=new S,ws=new S,Ue=new S,We=new S,Ke=new S,$s=new S,Gn=new S,Hn=new S,ts=new S;function Ji(i,t,e,s,n){for(let r=0,o=i.length-3;r<=o;r+=3){ts.fromArray(i,r);const a=n.x*Math.abs(ts.x)+n.y*Math.abs(ts.y)+n.z*Math.abs(ts.z),c=t.dot(ts),h=e.dot(ts),l=s.dot(ts);if(Math.max(-Math.max(c,h,l),Math.min(c,h,l))>a)return!1}return!0}const td=new xn,Ys=new S,Qi=new S;class Da{constructor(t=new S,e=-1){this.isSphere=!0,this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const s=this.center;e!==void 0?s.copy(e):td.setFromPoints(t).getCenter(s);let n=0;for(let r=0,o=t.length;r<o;r++)n=Math.max(n,s.distanceToSquared(t[r]));return this.radius=Math.sqrt(n),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const s=this.center.distanceToSquared(t);return e.copy(t),s>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){if(this.isEmpty())return this.center.copy(t),this.radius=0,this;Ys.subVectors(t,this.center);const e=Ys.lengthSq();if(e>this.radius*this.radius){const s=Math.sqrt(e),n=(s-this.radius)*.5;this.center.addScaledVector(Ys,n/s),this.radius+=n}return this}union(t){return t.isEmpty()?this:this.isEmpty()?(this.copy(t),this):(this.center.equals(t.center)===!0?this.radius=Math.max(this.radius,t.radius):(Qi.subVectors(t.center,this.center).setLength(t.radius),this.expandByPoint(Ys.copy(t.center).add(Qi)),this.expandByPoint(Ys.copy(t.center).sub(Qi))),this)}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const ve=new S,Ki=new S,jn=new S,qe=new S,tr=new S,Xn=new S,er=new S;class ed{constructor(t=new S,e=new S(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.origin).addScaledVector(this.direction,t)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,ve)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const s=e.dot(this.direction);return s<0?e.copy(this.origin):e.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=ve.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(ve.copy(this.origin).addScaledVector(this.direction,e),ve.distanceToSquared(t))}distanceSqToSegment(t,e,s,n){Ki.copy(t).add(e).multiplyScalar(.5),jn.copy(e).sub(t).normalize(),qe.copy(this.origin).sub(Ki);const r=t.distanceTo(e)*.5,o=-this.direction.dot(jn),a=qe.dot(this.direction),c=-qe.dot(jn),h=qe.lengthSq(),l=Math.abs(1-o*o);let d,p,m,f;if(l>0)if(d=o*c-a,p=o*a-c,f=r*l,d>=0)if(p>=-f)if(p<=f){const x=1/l;d*=x,p*=x,m=d*(d+o*p+2*a)+p*(o*d+p+2*c)+h}else p=r,d=Math.max(0,-(o*p+a)),m=-d*d+p*(p+2*c)+h;else p=-r,d=Math.max(0,-(o*p+a)),m=-d*d+p*(p+2*c)+h;else p<=-f?(d=Math.max(0,-(-o*r+a)),p=d>0?-r:Math.min(Math.max(-r,-c),r),m=-d*d+p*(p+2*c)+h):p<=f?(d=0,p=Math.min(Math.max(-r,-c),r),m=p*(p+2*c)+h):(d=Math.max(0,-(o*r+a)),p=d>0?r:Math.min(Math.max(-r,-c),r),m=-d*d+p*(p+2*c)+h);else p=o>0?-r:r,d=Math.max(0,-(o*p+a)),m=-d*d+p*(p+2*c)+h;return s&&s.copy(this.origin).addScaledVector(this.direction,d),n&&n.copy(Ki).addScaledVector(jn,p),m}intersectSphere(t,e){ve.subVectors(t.center,this.origin);const s=ve.dot(this.direction),n=ve.dot(ve)-s*s,r=t.radius*t.radius;if(n>r)return null;const o=Math.sqrt(r-n),a=s-o,c=s+o;return c<0?null:a<0?this.at(c,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(t.normal)+t.constant)/e;return s>=0?s:null}intersectPlane(t,e){const s=this.distanceToPlane(t);return s===null?null:this.at(s,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let s,n,r,o,a,c;const h=1/this.direction.x,l=1/this.direction.y,d=1/this.direction.z,p=this.origin;return h>=0?(s=(t.min.x-p.x)*h,n=(t.max.x-p.x)*h):(s=(t.max.x-p.x)*h,n=(t.min.x-p.x)*h),l>=0?(r=(t.min.y-p.y)*l,o=(t.max.y-p.y)*l):(r=(t.max.y-p.y)*l,o=(t.min.y-p.y)*l),s>o||r>n||((r>s||isNaN(s))&&(s=r),(o<n||isNaN(n))&&(n=o),d>=0?(a=(t.min.z-p.z)*d,c=(t.max.z-p.z)*d):(a=(t.max.z-p.z)*d,c=(t.min.z-p.z)*d),s>c||a>n)||((a>s||s!==s)&&(s=a),(c<n||n!==n)&&(n=c),n<0)?null:this.at(s>=0?s:n,e)}intersectsBox(t){return this.intersectBox(t,ve)!==null}intersectTriangle(t,e,s,n,r){tr.subVectors(e,t),Xn.subVectors(s,t),er.crossVectors(tr,Xn);let o=this.direction.dot(er),a;if(o>0){if(n)return null;a=1}else if(o<0)a=-1,o=-o;else return null;qe.subVectors(this.origin,t);const c=a*this.direction.dot(Xn.crossVectors(qe,Xn));if(c<0)return null;const h=a*this.direction.dot(tr.cross(qe));if(h<0||c+h>o)return null;const l=-a*qe.dot(er);return l<0?null:this.at(l/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class tt{constructor(t,e,s,n,r,o,a,c,h,l,d,p,m,f,x,v){tt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,e,s,n,r,o,a,c,h,l,d,p,m,f,x,v)}set(t,e,s,n,r,o,a,c,h,l,d,p,m,f,x,v){const A=this.elements;return A[0]=t,A[4]=e,A[8]=s,A[12]=n,A[1]=r,A[5]=o,A[9]=a,A[13]=c,A[2]=h,A[6]=l,A[10]=d,A[14]=p,A[3]=m,A[7]=f,A[11]=x,A[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new tt().fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,s){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,s=t.elements,n=1/Ms.setFromMatrixColumn(t,0).length(),r=1/Ms.setFromMatrixColumn(t,1).length(),o=1/Ms.setFromMatrixColumn(t,2).length();return e[0]=s[0]*n,e[1]=s[1]*n,e[2]=s[2]*n,e[3]=0,e[4]=s[4]*r,e[5]=s[5]*r,e[6]=s[6]*r,e[7]=0,e[8]=s[8]*o,e[9]=s[9]*o,e[10]=s[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){const e=this.elements,s=t.x,n=t.y,r=t.z,o=Math.cos(s),a=Math.sin(s),c=Math.cos(n),h=Math.sin(n),l=Math.cos(r),d=Math.sin(r);if(t.order==="XYZ"){const p=o*l,m=o*d,f=a*l,x=a*d;e[0]=c*l,e[4]=-c*d,e[8]=h,e[1]=m+f*h,e[5]=p-x*h,e[9]=-a*c,e[2]=x-p*h,e[6]=f+m*h,e[10]=o*c}else if(t.order==="YXZ"){const p=c*l,m=c*d,f=h*l,x=h*d;e[0]=p+x*a,e[4]=f*a-m,e[8]=o*h,e[1]=o*d,e[5]=o*l,e[9]=-a,e[2]=m*a-f,e[6]=x+p*a,e[10]=o*c}else if(t.order==="ZXY"){const p=c*l,m=c*d,f=h*l,x=h*d;e[0]=p-x*a,e[4]=-o*d,e[8]=f+m*a,e[1]=m+f*a,e[5]=o*l,e[9]=x-p*a,e[2]=-o*h,e[6]=a,e[10]=o*c}else if(t.order==="ZYX"){const p=o*l,m=o*d,f=a*l,x=a*d;e[0]=c*l,e[4]=f*h-m,e[8]=p*h+x,e[1]=c*d,e[5]=x*h+p,e[9]=m*h-f,e[2]=-h,e[6]=a*c,e[10]=o*c}else if(t.order==="YZX"){const p=o*c,m=o*h,f=a*c,x=a*h;e[0]=c*l,e[4]=x-p*d,e[8]=f*d+m,e[1]=d,e[5]=o*l,e[9]=-a*l,e[2]=-h*l,e[6]=m*d+f,e[10]=p-x*d}else if(t.order==="XZY"){const p=o*c,m=o*h,f=a*c,x=a*h;e[0]=c*l,e[4]=-d,e[8]=h*l,e[1]=p*d+x,e[5]=o*l,e[9]=m*d-f,e[2]=f*d-m,e[6]=a*l,e[10]=x*d+p}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(sd,t,nd)}lookAt(t,e,s){const n=this.elements;return Dt.subVectors(t,e),Dt.lengthSq()===0&&(Dt.z=1),Dt.normalize(),Ge.crossVectors(s,Dt),Ge.lengthSq()===0&&(Math.abs(s.z)===1?Dt.x+=1e-4:Dt.z+=1e-4,Dt.normalize(),Ge.crossVectors(s,Dt)),Ge.normalize(),$n.crossVectors(Dt,Ge),n[0]=Ge.x,n[4]=$n.x,n[8]=Dt.x,n[1]=Ge.y,n[5]=$n.y,n[9]=Dt.y,n[2]=Ge.z,n[6]=$n.z,n[10]=Dt.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,n=e.elements,r=this.elements,o=s[0],a=s[4],c=s[8],h=s[12],l=s[1],d=s[5],p=s[9],m=s[13],f=s[2],x=s[6],v=s[10],A=s[14],F=s[3],O=s[7],E=s[11],B=s[15],P=n[0],I=n[4],U=n[8],Z=n[12],St=n[1],At=n[5],De=n[9],Vt=n[13],ke=n[2],On=n[6],Ln=n[10],Bn=n[14],Pn=n[3],Dn=n[7],kn=n[11],Un=n[15];return r[0]=o*P+a*St+c*ke+h*Pn,r[4]=o*I+a*At+c*On+h*Dn,r[8]=o*U+a*De+c*Ln+h*kn,r[12]=o*Z+a*Vt+c*Bn+h*Un,r[1]=l*P+d*St+p*ke+m*Pn,r[5]=l*I+d*At+p*On+m*Dn,r[9]=l*U+d*De+p*Ln+m*kn,r[13]=l*Z+d*Vt+p*Bn+m*Un,r[2]=f*P+x*St+v*ke+A*Pn,r[6]=f*I+x*At+v*On+A*Dn,r[10]=f*U+x*De+v*Ln+A*kn,r[14]=f*Z+x*Vt+v*Bn+A*Un,r[3]=F*P+O*St+E*ke+B*Pn,r[7]=F*I+O*At+E*On+B*Dn,r[11]=F*U+O*De+E*Ln+B*kn,r[15]=F*Z+O*Vt+E*Bn+B*Un,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[4],n=t[8],r=t[12],o=t[1],a=t[5],c=t[9],h=t[13],l=t[2],d=t[6],p=t[10],m=t[14],f=t[3],x=t[7],v=t[11],A=t[15];return f*(+r*c*d-n*h*d-r*a*p+s*h*p+n*a*m-s*c*m)+x*(+e*c*m-e*h*p+r*o*p-n*o*m+n*h*l-r*c*l)+v*(+e*h*d-e*a*m-r*o*d+s*o*m+r*a*l-s*h*l)+A*(-n*a*l-e*c*d+e*a*p+n*o*d-s*o*p+s*c*l)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,s){const n=this.elements;return t.isVector3?(n[12]=t.x,n[13]=t.y,n[14]=t.z):(n[12]=t,n[13]=e,n[14]=s),this}invert(){const t=this.elements,e=t[0],s=t[1],n=t[2],r=t[3],o=t[4],a=t[5],c=t[6],h=t[7],l=t[8],d=t[9],p=t[10],m=t[11],f=t[12],x=t[13],v=t[14],A=t[15],F=d*v*h-x*p*h+x*c*m-a*v*m-d*c*A+a*p*A,O=f*p*h-l*v*h-f*c*m+o*v*m+l*c*A-o*p*A,E=l*x*h-f*d*h+f*a*m-o*x*m-l*a*A+o*d*A,B=f*d*c-l*x*c-f*a*p+o*x*p+l*a*v-o*d*v,P=e*F+s*O+n*E+r*B;if(P===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const I=1/P;return t[0]=F*I,t[1]=(x*p*r-d*v*r-x*n*m+s*v*m+d*n*A-s*p*A)*I,t[2]=(a*v*r-x*c*r+x*n*h-s*v*h-a*n*A+s*c*A)*I,t[3]=(d*c*r-a*p*r-d*n*h+s*p*h+a*n*m-s*c*m)*I,t[4]=O*I,t[5]=(l*v*r-f*p*r+f*n*m-e*v*m-l*n*A+e*p*A)*I,t[6]=(f*c*r-o*v*r-f*n*h+e*v*h+o*n*A-e*c*A)*I,t[7]=(o*p*r-l*c*r+l*n*h-e*p*h-o*n*m+e*c*m)*I,t[8]=E*I,t[9]=(f*d*r-l*x*r-f*s*m+e*x*m+l*s*A-e*d*A)*I,t[10]=(o*x*r-f*a*r+f*s*h-e*x*h-o*s*A+e*a*A)*I,t[11]=(l*a*r-o*d*r-l*s*h+e*d*h+o*s*m-e*a*m)*I,t[12]=B*I,t[13]=(l*x*n-f*d*n+f*s*p-e*x*p-l*s*v+e*d*v)*I,t[14]=(f*a*n-o*x*n-f*s*c+e*x*c+o*s*v-e*a*v)*I,t[15]=(o*d*n-l*a*n+l*s*c-e*d*c-o*s*p+e*a*p)*I,this}scale(t){const e=this.elements,s=t.x,n=t.y,r=t.z;return e[0]*=s,e[4]*=n,e[8]*=r,e[1]*=s,e[5]*=n,e[9]*=r,e[2]*=s,e[6]*=n,e[10]*=r,e[3]*=s,e[7]*=n,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],n=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,n))}makeTranslation(t,e,s){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),n=Math.sin(e),r=1-s,o=t.x,a=t.y,c=t.z,h=r*o,l=r*a;return this.set(h*o+s,h*a-n*c,h*c+n*a,0,h*a+n*c,l*a+s,l*c-n*o,0,h*c-n*a,l*c+n*o,r*c*c+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,n,r,o){return this.set(1,s,r,0,t,1,o,0,e,n,1,0,0,0,0,1),this}compose(t,e,s){const n=this.elements,r=e._x,o=e._y,a=e._z,c=e._w,h=r+r,l=o+o,d=a+a,p=r*h,m=r*l,f=r*d,x=o*l,v=o*d,A=a*d,F=c*h,O=c*l,E=c*d,B=s.x,P=s.y,I=s.z;return n[0]=(1-(x+A))*B,n[1]=(m+E)*B,n[2]=(f-O)*B,n[3]=0,n[4]=(m-E)*P,n[5]=(1-(p+A))*P,n[6]=(v+F)*P,n[7]=0,n[8]=(f+O)*I,n[9]=(v-F)*I,n[10]=(1-(p+x))*I,n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,this}decompose(t,e,s){const n=this.elements;let r=Ms.set(n[0],n[1],n[2]).length();const o=Ms.set(n[4],n[5],n[6]).length(),a=Ms.set(n[8],n[9],n[10]).length();this.determinant()<0&&(r=-r),t.x=n[12],t.y=n[13],t.z=n[14],ne.copy(this);const h=1/r,l=1/o,d=1/a;return ne.elements[0]*=h,ne.elements[1]*=h,ne.elements[2]*=h,ne.elements[4]*=l,ne.elements[5]*=l,ne.elements[6]*=l,ne.elements[8]*=d,ne.elements[9]*=d,ne.elements[10]*=d,e.setFromRotationMatrix(ne),s.x=r,s.y=o,s.z=a,this}makePerspective(t,e,s,n,r,o,a=cs){const c=this.elements,h=2*r/(e-t),l=2*r/(s-n),d=(e+t)/(e-t),p=(s+n)/(s-n);let m,f;if(a===cs)m=-(o+r)/(o-r),f=-2*o*r/(o-r);else if(a===ks)m=-o/(o-r),f=-o*r/(o-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return c[0]=h,c[4]=0,c[8]=d,c[12]=0,c[1]=0,c[5]=l,c[9]=p,c[13]=0,c[2]=0,c[6]=0,c[10]=m,c[14]=f,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(t,e,s,n,r,o,a=cs){const c=this.elements,h=1/(e-t),l=1/(s-n),d=1/(o-r),p=(e+t)*h,m=(s+n)*l;let f,x;if(a===cs)f=(o+r)*d,x=-2*d;else if(a===ks)f=r*d,x=-1*d;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return c[0]=2*h,c[4]=0,c[8]=0,c[12]=-p,c[1]=0,c[5]=2*l,c[9]=0,c[13]=-m,c[2]=0,c[6]=0,c[10]=x,c[14]=-f,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(t){const e=this.elements,s=t.elements;for(let n=0;n<16;n++)if(e[n]!==s[n])return!1;return!0}fromArray(t,e=0){for(let s=0;s<16;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}}const Ms=new S,ne=new tt,sd=new S(0,0,0),nd=new S(1,1,1),Ge=new S,$n=new S,Dt=new S,Jo=new tt,Qo=new yn;class ms{constructor(t=0,e=0,s=0,n=ms.DEFAULT_ORDER){this.isEuler=!0,this._x=t,this._y=e,this._z=s,this._order=n}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,s,n=this._order){return this._x=t,this._y=e,this._z=s,this._order=n,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,s=!0){const n=t.elements,r=n[0],o=n[4],a=n[8],c=n[1],h=n[5],l=n[9],d=n[2],p=n[6],m=n[10];switch(e){case"XYZ":this._y=Math.asin(G(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-l,m),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(p,h),this._z=0);break;case"YXZ":this._x=Math.asin(-G(l,-1,1)),Math.abs(l)<.9999999?(this._y=Math.atan2(a,m),this._z=Math.atan2(c,h)):(this._y=Math.atan2(-d,r),this._z=0);break;case"ZXY":this._x=Math.asin(G(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-d,m),this._z=Math.atan2(-o,h)):(this._y=0,this._z=Math.atan2(c,r));break;case"ZYX":this._y=Math.asin(-G(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(p,m),this._z=Math.atan2(c,r)):(this._x=0,this._z=Math.atan2(-o,h));break;case"YZX":this._z=Math.asin(G(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-l,h),this._y=Math.atan2(-d,r)):(this._x=0,this._y=Math.atan2(a,m));break;case"XZY":this._z=Math.asin(-G(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(p,h),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-l,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,s===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,s){return Jo.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Jo,e,s)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Qo.setFromEuler(this),this.setFromQuaternion(Qo,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}ms.DEFAULT_ORDER="XYZ";class id{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}isEnabled(t){return(this.mask&(1<<t|0))!==0}}let rd=0;const Ko=new S,_s=new yn,we=new tt,Yn=new S,Zs=new S,od=new S,ad=new yn,ta=new S(1,0,0),ea=new S(0,1,0),sa=new S(0,0,1),na={type:"added"},cd={type:"removed"},bs={type:"childadded",child:null},sr={type:"childremoved",child:null};class Jt extends ps{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:rd++}),this.uuid=Ae(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Jt.DEFAULT_UP.clone();const t=new S,e=new ms,s=new yn,n=new S(1,1,1);function r(){s.setFromEuler(e,!1)}function o(){e.setFromQuaternion(s,void 0,!1)}e._onChange(r),s._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:n},modelViewMatrix:{value:new tt},normalMatrix:{value:new te}}),this.matrix=new tt,this.matrixWorld=new tt,this.matrixAutoUpdate=Jt.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Jt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new id,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return _s.setFromAxisAngle(t,e),this.quaternion.multiply(_s),this}rotateOnWorldAxis(t,e){return _s.setFromAxisAngle(t,e),this.quaternion.premultiply(_s),this}rotateX(t){return this.rotateOnAxis(ta,t)}rotateY(t){return this.rotateOnAxis(ea,t)}rotateZ(t){return this.rotateOnAxis(sa,t)}translateOnAxis(t,e){return Ko.copy(t).applyQuaternion(this.quaternion),this.position.add(Ko.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(ta,t)}translateY(t){return this.translateOnAxis(ea,t)}translateZ(t){return this.translateOnAxis(sa,t)}localToWorld(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return this.updateWorldMatrix(!0,!1),t.applyMatrix4(we.copy(this.matrixWorld).invert())}lookAt(t,e,s){t.isVector3?Yn.copy(t):Yn.set(t,e,s);const n=this.parent;this.updateWorldMatrix(!0,!1),Zs.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?we.lookAt(Zs,Yn,this.up):we.lookAt(Yn,Zs,this.up),this.quaternion.setFromRotationMatrix(we),n&&(we.extractRotation(n.matrixWorld),_s.setFromRotationMatrix(we),this.quaternion.premultiply(_s.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.removeFromParent(),t.parent=this,this.children.push(t),t.dispatchEvent(na),bs.child=t,this.dispatchEvent(bs),bs.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(cd),sr.child=t,this.dispatchEvent(sr),sr.child=null),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){return this.remove(...this.children)}attach(t){return this.updateWorldMatrix(!0,!1),we.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),we.multiply(t.parent.matrixWorld)),t.applyMatrix4(we),t.removeFromParent(),t.parent=this,this.children.push(t),t.updateWorldMatrix(!1,!0),t.dispatchEvent(na),bs.child=t,this.dispatchEvent(bs),bs.child=null,this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let s=0,n=this.children.length;s<n;s++){const o=this.children[s].getObjectByProperty(t,e);if(o!==void 0)return o}}getObjectsByProperty(t,e,s=[]){this[t]===e&&s.push(this);const n=this.children;for(let r=0,o=n.length;r<o;r++)n[r].getObjectsByProperty(t,e,s);return s}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Zs,t,od),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Zs,ad,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let s=0,n=e.length;s<n;s++)e[s].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let s=0,n=e.length;s<n;s++)e[s].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let s=0,n=e.length;s<n;s++)e[s].updateMatrixWorld(t)}updateWorldMatrix(t,e){const s=this.parent;if(t===!0&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),e===!0){const n=this.children;for(let r=0,o=n.length;r<o;r++)n[r].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",s={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const n={};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.castShadow===!0&&(n.castShadow=!0),this.receiveShadow===!0&&(n.receiveShadow=!0),this.visible===!1&&(n.visible=!1),this.frustumCulled===!1&&(n.frustumCulled=!1),this.renderOrder!==0&&(n.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(n.userData=this.userData),n.layers=this.layers.mask,n.matrix=this.matrix.toArray(),n.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(n.matrixAutoUpdate=!1),this.isInstancedMesh&&(n.type="InstancedMesh",n.count=this.count,n.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(n.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(n.type="BatchedMesh",n.perObjectFrustumCulled=this.perObjectFrustumCulled,n.sortObjects=this.sortObjects,n.drawRanges=this._drawRanges,n.reservedRanges=this._reservedRanges,n.visibility=this._visibility,n.active=this._active,n.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),n.maxInstanceCount=this._maxInstanceCount,n.maxVertexCount=this._maxVertexCount,n.maxIndexCount=this._maxIndexCount,n.geometryInitialized=this._geometryInitialized,n.geometryCount=this._geometryCount,n.matricesTexture=this._matricesTexture.toJSON(t),this._colorsTexture!==null&&(n.colorsTexture=this._colorsTexture.toJSON(t)),this.boundingSphere!==null&&(n.boundingSphere={center:n.boundingSphere.center.toArray(),radius:n.boundingSphere.radius}),this.boundingBox!==null&&(n.boundingBox={min:n.boundingBox.min.toArray(),max:n.boundingBox.max.toArray()}));function r(a,c){return a[c.uuid]===void 0&&(a[c.uuid]=c.toJSON(t)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?n.background=this.background.toJSON():this.background.isTexture&&(n.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(n.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){n.geometry=r(t.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const c=a.shapes;if(Array.isArray(c))for(let h=0,l=c.length;h<l;h++){const d=c[h];r(t.shapes,d)}else r(t.shapes,c)}}if(this.isSkinnedMesh&&(n.bindMode=this.bindMode,n.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),n.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let c=0,h=this.material.length;c<h;c++)a.push(r(t.materials,this.material[c]));n.material=a}else n.material=r(t.materials,this.material);if(this.children.length>0){n.children=[];for(let a=0;a<this.children.length;a++)n.children.push(this.children[a].toJSON(t).object)}if(this.animations.length>0){n.animations=[];for(let a=0;a<this.animations.length;a++){const c=this.animations[a];n.animations.push(r(t.animations,c))}}if(e){const a=o(t.geometries),c=o(t.materials),h=o(t.textures),l=o(t.images),d=o(t.shapes),p=o(t.skeletons),m=o(t.animations),f=o(t.nodes);a.length>0&&(s.geometries=a),c.length>0&&(s.materials=c),h.length>0&&(s.textures=h),l.length>0&&(s.images=l),d.length>0&&(s.shapes=d),p.length>0&&(s.skeletons=p),m.length>0&&(s.animations=m),f.length>0&&(s.nodes=f)}return s.object=n,s;function o(a){const c=[];for(const h in a){const l=a[h];delete l.metadata,c.push(l)}return c}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldAutoUpdate=t.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.animations=t.animations.slice(),this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let s=0;s<t.children.length;s++){const n=t.children[s];this.add(n.clone())}return this}}Jt.DEFAULT_UP=new S(0,1,0);Jt.DEFAULT_MATRIX_AUTO_UPDATE=!0;Jt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ie=new S,Me=new S,nr=new S,_e=new S,Ss=new S,As=new S,ia=new S,ir=new S,rr=new S,or=new S,ar=new It,cr=new It,hr=new It;class ce{constructor(t=new S,e=new S,s=new S){this.a=t,this.b=e,this.c=s}static getNormal(t,e,s,n){n.subVectors(s,e),ie.subVectors(t,e),n.cross(ie);const r=n.lengthSq();return r>0?n.multiplyScalar(1/Math.sqrt(r)):n.set(0,0,0)}static getBarycoord(t,e,s,n,r){ie.subVectors(n,e),Me.subVectors(s,e),nr.subVectors(t,e);const o=ie.dot(ie),a=ie.dot(Me),c=ie.dot(nr),h=Me.dot(Me),l=Me.dot(nr),d=o*h-a*a;if(d===0)return r.set(0,0,0),null;const p=1/d,m=(h*c-a*l)*p,f=(o*l-a*c)*p;return r.set(1-m-f,f,m)}static containsPoint(t,e,s,n){return this.getBarycoord(t,e,s,n,_e)===null?!1:_e.x>=0&&_e.y>=0&&_e.x+_e.y<=1}static getInterpolation(t,e,s,n,r,o,a,c){return this.getBarycoord(t,e,s,n,_e)===null?(c.x=0,c.y=0,"z"in c&&(c.z=0),"w"in c&&(c.w=0),null):(c.setScalar(0),c.addScaledVector(r,_e.x),c.addScaledVector(o,_e.y),c.addScaledVector(a,_e.z),c)}static getInterpolatedAttribute(t,e,s,n,r,o){return ar.setScalar(0),cr.setScalar(0),hr.setScalar(0),ar.fromBufferAttribute(t,e),cr.fromBufferAttribute(t,s),hr.fromBufferAttribute(t,n),o.setScalar(0),o.addScaledVector(ar,r.x),o.addScaledVector(cr,r.y),o.addScaledVector(hr,r.z),o}static isFrontFacing(t,e,s,n){return ie.subVectors(s,e),Me.subVectors(t,e),ie.cross(Me).dot(n)<0}set(t,e,s){return this.a.copy(t),this.b.copy(e),this.c.copy(s),this}setFromPointsAndIndices(t,e,s,n){return this.a.copy(t[e]),this.b.copy(t[s]),this.c.copy(t[n]),this}setFromAttributeAndIndices(t,e,s,n){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,s),this.c.fromBufferAttribute(t,n),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return ie.subVectors(this.c,this.b),Me.subVectors(this.a,this.b),ie.cross(Me).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return ce.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return ce.getBarycoord(t,this.a,this.b,this.c,e)}getInterpolation(t,e,s,n,r){return ce.getInterpolation(t,this.a,this.b,this.c,e,s,n,r)}containsPoint(t){return ce.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return ce.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const s=this.a,n=this.b,r=this.c;let o,a;Ss.subVectors(n,s),As.subVectors(r,s),ir.subVectors(t,s);const c=Ss.dot(ir),h=As.dot(ir);if(c<=0&&h<=0)return e.copy(s);rr.subVectors(t,n);const l=Ss.dot(rr),d=As.dot(rr);if(l>=0&&d<=l)return e.copy(n);const p=c*d-l*h;if(p<=0&&c>=0&&l<=0)return o=c/(c-l),e.copy(s).addScaledVector(Ss,o);or.subVectors(t,r);const m=Ss.dot(or),f=As.dot(or);if(f>=0&&m<=f)return e.copy(r);const x=m*h-c*f;if(x<=0&&h>=0&&f<=0)return a=h/(h-f),e.copy(s).addScaledVector(As,a);const v=l*f-m*d;if(v<=0&&d-l>=0&&m-f>=0)return ia.subVectors(r,n),a=(d-l)/(d-l+(m-f)),e.copy(n).addScaledVector(ia,a);const A=1/(v+x+p);return o=x*A,a=p*A,e.copy(s).addScaledVector(Ss,o).addScaledVector(As,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const ka={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},He={h:0,s:0,l:0},Zn={h:0,s:0,l:0};function lr(i,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?i+(t-i)*6*e:e<1/2?t:e<2/3?i+(t-i)*6*(2/3-e):i}class Ye{constructor(t,e,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(t,e,s)}set(t,e,s){if(e===void 0&&s===void 0){const n=t;n&&n.isColor?this.copy(n):typeof n=="number"?this.setHex(n):typeof n=="string"&&this.setStyle(n)}else this.setRGB(t,e,s);return this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t,e=oe){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,ht.toWorkingColorSpace(this,e),this}setRGB(t,e,s,n=ht.workingColorSpace){return this.r=t,this.g=e,this.b=s,ht.toWorkingColorSpace(this,n),this}setHSL(t,e,s,n=ht.workingColorSpace){if(t=Zr(t,1),e=G(e,0,1),s=G(s,0,1),e===0)this.r=this.g=this.b=s;else{const r=s<=.5?s*(1+e):s+e-s*e,o=2*s-r;this.r=lr(o,r,t+1/3),this.g=lr(o,r,t),this.b=lr(o,r,t-1/3)}return ht.toWorkingColorSpace(this,n),this}setStyle(t,e=oe){function s(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let n;if(n=/^(\w+)\(([^\)]*)\)/.exec(t)){let r;const o=n[1],a=n[2];switch(o){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,e);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,e);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return s(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,e);break;default:console.warn("THREE.Color: Unknown color model "+t)}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=n[1],o=r.length;if(o===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,e);if(o===6)return this.setHex(parseInt(r,16),e);console.warn("THREE.Color: Invalid hex color "+t)}else if(t&&t.length>0)return this.setColorName(t,e);return this}setColorName(t,e=oe){const s=ka[t.toLowerCase()];return s!==void 0?this.setHex(s,e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=Ve(t.r),this.g=Ve(t.g),this.b=Ve(t.b),this}copyLinearToSRGB(t){return this.r=Ls(t.r),this.g=Ls(t.g),this.b=Ls(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(t=oe){return ht.fromWorkingColorSpace(Ct.copy(this),t),Math.round(G(Ct.r*255,0,255))*65536+Math.round(G(Ct.g*255,0,255))*256+Math.round(G(Ct.b*255,0,255))}getHexString(t=oe){return("000000"+this.getHex(t).toString(16)).slice(-6)}getHSL(t,e=ht.workingColorSpace){ht.fromWorkingColorSpace(Ct.copy(this),e);const s=Ct.r,n=Ct.g,r=Ct.b,o=Math.max(s,n,r),a=Math.min(s,n,r);let c,h;const l=(a+o)/2;if(a===o)c=0,h=0;else{const d=o-a;switch(h=l<=.5?d/(o+a):d/(2-o-a),o){case s:c=(n-r)/d+(n<r?6:0);break;case n:c=(r-s)/d+2;break;case r:c=(s-n)/d+4;break}c/=6}return t.h=c,t.s=h,t.l=l,t}getRGB(t,e=ht.workingColorSpace){return ht.fromWorkingColorSpace(Ct.copy(this),e),t.r=Ct.r,t.g=Ct.g,t.b=Ct.b,t}getStyle(t=oe){ht.fromWorkingColorSpace(Ct.copy(this),t);const e=Ct.r,s=Ct.g,n=Ct.b;return t!==oe?`color(${t} ${e.toFixed(3)} ${s.toFixed(3)} ${n.toFixed(3)})`:`rgb(${Math.round(e*255)},${Math.round(s*255)},${Math.round(n*255)})`}offsetHSL(t,e,s){return this.getHSL(He),this.setHSL(He.h+t,He.s+e,He.l+s)}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,s){return this.r=t.r+(e.r-t.r)*s,this.g=t.g+(e.g-t.g)*s,this.b=t.b+(e.b-t.b)*s,this}lerpHSL(t,e){this.getHSL(He),t.getHSL(Zn);const s=hn(He.h,Zn.h,e),n=hn(He.s,Zn.s,e),r=hn(He.l,Zn.l,e);return this.setHSL(s,n,r),this}setFromVector3(t){return this.r=t.x,this.g=t.y,this.b=t.z,this}applyMatrix3(t){const e=this.r,s=this.g,n=this.b,r=t.elements;return this.r=r[0]*e+r[3]*s+r[6]*n,this.g=r[1]*e+r[4]*s+r[7]*n,this.b=r[2]*e+r[5]*s+r[8]*n,this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Ct=new Ye;Ye.NAMES=ka;let hd=0;class xi extends ps{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:hd++}),this.uuid=Ae(),this.name="",this.type="Material",this.blending=zr,this.side=Vr,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Bo,this.blendDst=Po,this.blendEquation=Lo,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Ye(0,0,0),this.blendAlpha=0,this.depthFunc=Do,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Ho,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=xs,this.stencilZFail=xs,this.stencilZPass=xs,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const s=t[e];if(s===void 0){console.warn(`THREE.Material: parameter '${e}' has value of undefined.`);continue}const n=this[e];if(n===void 0){console.warn(`THREE.Material: '${e}' is not a property of THREE.${this.type}.`);continue}n&&n.isColor?n.set(s):n&&n.isVector3&&s&&s.isVector3?n.copy(s):this[e]=s}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const s={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(s.dispersion=this.dispersion),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(t).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(t).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(t).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(t).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(t).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(t).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(t).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(t).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapRotation!==void 0&&(s.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==zr&&(s.blending=this.blending),this.side!==Vr&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==Bo&&(s.blendSrc=this.blendSrc),this.blendDst!==Po&&(s.blendDst=this.blendDst),this.blendEquation!==Lo&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==Do&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==Ho&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==xs&&(s.stencilFail=this.stencilFail),this.stencilZFail!==xs&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==xs&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function n(r){const o=[];for(const a in r){const c=r[a];delete c.metadata,o.push(c)}return o}if(e){const r=n(t.textures),o=n(t.images);r.length>0&&(s.textures=r),o.length>0&&(s.images=o)}return s}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.blendColor.copy(t.blendColor),this.blendAlpha=t.blendAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let s=null;if(e!==null){const n=e.length;s=new Array(n);for(let r=0;r!==n;++r)s[r]=e[r].clone()}return this.clippingPlanes=s,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaHash=t.alphaHash,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.forceSinglePass=t.forceSinglePass,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class Ua extends xi{constructor(t){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Ye(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new ms,this.combine=wu,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}const mt=new S,Jn=new gt;class ze{constructor(t,e,s=!1){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=s,this.usage=yi,this.updateRanges=[],this.gpuType=Ia,this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this.gpuType=t.gpuType,this}copyAt(t,e,s){t*=this.itemSize,s*=e.itemSize;for(let n=0,r=this.itemSize;n<r;n++)this.array[t+n]=e.array[s+n];return this}copyArray(t){return this.array.set(t),this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,s=this.count;e<s;e++)Jn.fromBufferAttribute(this,e),Jn.applyMatrix3(t),this.setXY(e,Jn.x,Jn.y);else if(this.itemSize===3)for(let e=0,s=this.count;e<s;e++)mt.fromBufferAttribute(this,e),mt.applyMatrix3(t),this.setXYZ(e,mt.x,mt.y,mt.z);return this}applyMatrix4(t){for(let e=0,s=this.count;e<s;e++)mt.fromBufferAttribute(this,e),mt.applyMatrix4(t),this.setXYZ(e,mt.x,mt.y,mt.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)mt.fromBufferAttribute(this,e),mt.applyNormalMatrix(t),this.setXYZ(e,mt.x,mt.y,mt.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)mt.fromBufferAttribute(this,e),mt.transformDirection(t),this.setXYZ(e,mt.x,mt.y,mt.z);return this}set(t,e=0){return this.array.set(t,e),this}getComponent(t,e){let s=this.array[t*this.itemSize+e];return this.normalized&&(s=ae(s,this.array)),s}setComponent(t,e,s){return this.normalized&&(s=Q(s,this.array)),this.array[t*this.itemSize+e]=s,this}getX(t){let e=this.array[t*this.itemSize];return this.normalized&&(e=ae(e,this.array)),e}setX(t,e){return this.normalized&&(e=Q(e,this.array)),this.array[t*this.itemSize]=e,this}getY(t){let e=this.array[t*this.itemSize+1];return this.normalized&&(e=ae(e,this.array)),e}setY(t,e){return this.normalized&&(e=Q(e,this.array)),this.array[t*this.itemSize+1]=e,this}getZ(t){let e=this.array[t*this.itemSize+2];return this.normalized&&(e=ae(e,this.array)),e}setZ(t,e){return this.normalized&&(e=Q(e,this.array)),this.array[t*this.itemSize+2]=e,this}getW(t){let e=this.array[t*this.itemSize+3];return this.normalized&&(e=ae(e,this.array)),e}setW(t,e){return this.normalized&&(e=Q(e,this.array)),this.array[t*this.itemSize+3]=e,this}setXY(t,e,s){return t*=this.itemSize,this.normalized&&(e=Q(e,this.array),s=Q(s,this.array)),this.array[t+0]=e,this.array[t+1]=s,this}setXYZ(t,e,s,n){return t*=this.itemSize,this.normalized&&(e=Q(e,this.array),s=Q(s,this.array),n=Q(n,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=n,this}setXYZW(t,e,s,n,r){return t*=this.itemSize,this.normalized&&(e=Q(e,this.array),s=Q(s,this.array),n=Q(n,this.array),r=Q(r,this.array)),this.array[t+0]=e,this.array[t+1]=s,this.array[t+2]=n,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==yi&&(t.usage=this.usage),t}}class ld extends ze{constructor(t,e,s){super(new Uint16Array(t),e,s)}}class ud extends ze{constructor(t,e,s){super(new Uint32Array(t),e,s)}}class Fr extends ze{constructor(t,e,s){super(new Float32Array(t),e,s)}}let dd=0;const Xt=new tt,ur=new Jt,Vs=new S,kt=new xn,Js=new xn,Tt=new S;class Ri extends ps{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:dd++}),this.uuid=Ae(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new($u(t)?ud:ld)(t,1):this.index=t,this}setIndirect(t){return this.indirect=t,this}getIndirect(){return this.indirect}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,s=0){this.groups.push({start:t,count:e,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const r=new te().getNormalMatrix(t);s.applyNormalMatrix(r),s.needsUpdate=!0}const n=this.attributes.tangent;return n!==void 0&&(n.transformDirection(t),n.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return Xt.makeRotationFromQuaternion(t),this.applyMatrix4(Xt),this}rotateX(t){return Xt.makeRotationX(t),this.applyMatrix4(Xt),this}rotateY(t){return Xt.makeRotationY(t),this.applyMatrix4(Xt),this}rotateZ(t){return Xt.makeRotationZ(t),this.applyMatrix4(Xt),this}translate(t,e,s){return Xt.makeTranslation(t,e,s),this.applyMatrix4(Xt),this}scale(t,e,s){return Xt.makeScale(t,e,s),this.applyMatrix4(Xt),this}lookAt(t){return ur.lookAt(t),ur.updateMatrix(),this.applyMatrix4(ur.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Vs).negate(),this.translate(Vs.x,Vs.y,Vs.z),this}setFromPoints(t){const e=this.getAttribute("position");if(e===void 0){const s=[];for(let n=0,r=t.length;n<r;n++){const o=t[n];s.push(o.x,o.y,o.z||0)}this.setAttribute("position",new Fr(s,3))}else{const s=Math.min(t.length,e.count);for(let n=0;n<s;n++){const r=t[n];e.setXYZ(n,r.x,r.y,r.z||0)}t.length>e.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),e.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new xn);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new S(-1/0,-1/0,-1/0),new S(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let s=0,n=e.length;s<n;s++){const r=e[s];kt.setFromBufferAttribute(r),this.morphTargetsRelative?(Tt.addVectors(this.boundingBox.min,kt.min),this.boundingBox.expandByPoint(Tt),Tt.addVectors(this.boundingBox.max,kt.max),this.boundingBox.expandByPoint(Tt)):(this.boundingBox.expandByPoint(kt.min),this.boundingBox.expandByPoint(kt.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Da);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new S,1/0);return}if(t){const s=this.boundingSphere.center;if(kt.setFromBufferAttribute(t),e)for(let r=0,o=e.length;r<o;r++){const a=e[r];Js.setFromBufferAttribute(a),this.morphTargetsRelative?(Tt.addVectors(kt.min,Js.min),kt.expandByPoint(Tt),Tt.addVectors(kt.max,Js.max),kt.expandByPoint(Tt)):(kt.expandByPoint(Js.min),kt.expandByPoint(Js.max))}kt.getCenter(s);let n=0;for(let r=0,o=t.count;r<o;r++)Tt.fromBufferAttribute(t,r),n=Math.max(n,s.distanceToSquared(Tt));if(e)for(let r=0,o=e.length;r<o;r++){const a=e[r],c=this.morphTargetsRelative;for(let h=0,l=a.count;h<l;h++)Tt.fromBufferAttribute(a,h),c&&(Vs.fromBufferAttribute(t,h),Tt.add(Vs)),n=Math.max(n,s.distanceToSquared(Tt))}this.boundingSphere.radius=Math.sqrt(n),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=e.position,n=e.normal,r=e.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new ze(new Float32Array(4*s.count),4));const o=this.getAttribute("tangent"),a=[],c=[];for(let U=0;U<s.count;U++)a[U]=new S,c[U]=new S;const h=new S,l=new S,d=new S,p=new gt,m=new gt,f=new gt,x=new S,v=new S;function A(U,Z,St){h.fromBufferAttribute(s,U),l.fromBufferAttribute(s,Z),d.fromBufferAttribute(s,St),p.fromBufferAttribute(r,U),m.fromBufferAttribute(r,Z),f.fromBufferAttribute(r,St),l.sub(h),d.sub(h),m.sub(p),f.sub(p);const At=1/(m.x*f.y-f.x*m.y);isFinite(At)&&(x.copy(l).multiplyScalar(f.y).addScaledVector(d,-m.y).multiplyScalar(At),v.copy(d).multiplyScalar(m.x).addScaledVector(l,-f.x).multiplyScalar(At),a[U].add(x),a[Z].add(x),a[St].add(x),c[U].add(v),c[Z].add(v),c[St].add(v))}let F=this.groups;F.length===0&&(F=[{start:0,count:t.count}]);for(let U=0,Z=F.length;U<Z;++U){const St=F[U],At=St.start,De=St.count;for(let Vt=At,ke=At+De;Vt<ke;Vt+=3)A(t.getX(Vt+0),t.getX(Vt+1),t.getX(Vt+2))}const O=new S,E=new S,B=new S,P=new S;function I(U){B.fromBufferAttribute(n,U),P.copy(B);const Z=a[U];O.copy(Z),O.sub(B.multiplyScalar(B.dot(Z))).normalize(),E.crossVectors(P,Z);const At=E.dot(c[U])<0?-1:1;o.setXYZW(U,O.x,O.y,O.z,At)}for(let U=0,Z=F.length;U<Z;++U){const St=F[U],At=St.start,De=St.count;for(let Vt=At,ke=At+De;Vt<ke;Vt+=3)I(t.getX(Vt+0)),I(t.getX(Vt+1)),I(t.getX(Vt+2))}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new ze(new Float32Array(e.count*3),3),this.setAttribute("normal",s);else for(let p=0,m=s.count;p<m;p++)s.setXYZ(p,0,0,0);const n=new S,r=new S,o=new S,a=new S,c=new S,h=new S,l=new S,d=new S;if(t)for(let p=0,m=t.count;p<m;p+=3){const f=t.getX(p+0),x=t.getX(p+1),v=t.getX(p+2);n.fromBufferAttribute(e,f),r.fromBufferAttribute(e,x),o.fromBufferAttribute(e,v),l.subVectors(o,r),d.subVectors(n,r),l.cross(d),a.fromBufferAttribute(s,f),c.fromBufferAttribute(s,x),h.fromBufferAttribute(s,v),a.add(l),c.add(l),h.add(l),s.setXYZ(f,a.x,a.y,a.z),s.setXYZ(x,c.x,c.y,c.z),s.setXYZ(v,h.x,h.y,h.z)}else for(let p=0,m=e.count;p<m;p+=3)n.fromBufferAttribute(e,p+0),r.fromBufferAttribute(e,p+1),o.fromBufferAttribute(e,p+2),l.subVectors(o,r),d.subVectors(n,r),l.cross(d),s.setXYZ(p+0,l.x,l.y,l.z),s.setXYZ(p+1,l.x,l.y,l.z),s.setXYZ(p+2,l.x,l.y,l.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const t=this.attributes.normal;for(let e=0,s=t.count;e<s;e++)Tt.fromBufferAttribute(t,e),Tt.normalize(),t.setXYZ(e,Tt.x,Tt.y,Tt.z)}toNonIndexed(){function t(a,c){const h=a.array,l=a.itemSize,d=a.normalized,p=new h.constructor(c.length*l);let m=0,f=0;for(let x=0,v=c.length;x<v;x++){a.isInterleavedBufferAttribute?m=c[x]*a.data.stride+a.offset:m=c[x]*l;for(let A=0;A<l;A++)p[f++]=h[m++]}return new ze(p,l,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new Ri,s=this.index.array,n=this.attributes;for(const a in n){const c=n[a],h=t(c,s);e.setAttribute(a,h)}const r=this.morphAttributes;for(const a in r){const c=[],h=r[a];for(let l=0,d=h.length;l<d;l++){const p=h[l],m=t(p,s);c.push(m)}e.morphAttributes[a]=c}e.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,c=o.length;a<c;a++){const h=o[a];e.addGroup(h.start,h.count,h.materialIndex)}return e}toJSON(){const t={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const h in c)c[h]!==void 0&&(t[h]=c[h]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const s=this.attributes;for(const c in s){const h=s[c];t.data.attributes[c]=h.toJSON(t.data)}const n={};let r=!1;for(const c in this.morphAttributes){const h=this.morphAttributes[c],l=[];for(let d=0,p=h.length;d<p;d++){const m=h[d];l.push(m.toJSON(t.data))}l.length>0&&(n[c]=l,r=!0)}r&&(t.data.morphAttributes=n,t.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(t.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const s=t.index;s!==null&&this.setIndex(s.clone(e));const n=t.attributes;for(const h in n){const l=n[h];this.setAttribute(h,l.clone(e))}const r=t.morphAttributes;for(const h in r){const l=[],d=r[h];for(let p=0,m=d.length;p<m;p++)l.push(d[p].clone(e));this.morphAttributes[h]=l}this.morphTargetsRelative=t.morphTargetsRelative;const o=t.groups;for(let h=0,l=o.length;h<l;h++){const d=o[h];this.addGroup(d.start,d.count,d.materialIndex)}const a=t.boundingBox;a!==null&&(this.boundingBox=a.clone());const c=t.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const ra=new tt,es=new ed,Qn=new Da,oa=new S,Kn=new S,ti=new S,ei=new S,dr=new S,si=new S,aa=new S,ni=new S;class pd extends Jt{constructor(t=new Ri,e=new Ua){super(),this.isMesh=!0,this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t,e){return super.copy(t,e),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=Array.isArray(t.material)?t.material.slice():t.material,this.geometry=t.geometry,this}updateMorphTargets(){const e=this.geometry.morphAttributes,s=Object.keys(e);if(s.length>0){const n=e[s[0]];if(n!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=n.length;r<o;r++){const a=n[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}getVertexPosition(t,e){const s=this.geometry,n=s.attributes.position,r=s.morphAttributes.position,o=s.morphTargetsRelative;e.fromBufferAttribute(n,t);const a=this.morphTargetInfluences;if(r&&a){si.set(0,0,0);for(let c=0,h=r.length;c<h;c++){const l=a[c],d=r[c];l!==0&&(dr.fromBufferAttribute(d,t),o?si.addScaledVector(dr,l):si.addScaledVector(dr.sub(e),l))}e.add(si)}return e}raycast(t,e){const s=this.geometry,n=this.material,r=this.matrixWorld;n!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),Qn.copy(s.boundingSphere),Qn.applyMatrix4(r),es.copy(t.ray).recast(t.near),!(Qn.containsPoint(es.origin)===!1&&(es.intersectSphere(Qn,oa)===null||es.origin.distanceToSquared(oa)>(t.far-t.near)**2))&&(ra.copy(r).invert(),es.copy(t.ray).applyMatrix4(ra),!(s.boundingBox!==null&&es.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(t,e,es)))}_computeIntersections(t,e,s){let n;const r=this.geometry,o=this.material,a=r.index,c=r.attributes.position,h=r.attributes.uv,l=r.attributes.uv1,d=r.attributes.normal,p=r.groups,m=r.drawRange;if(a!==null)if(Array.isArray(o))for(let f=0,x=p.length;f<x;f++){const v=p[f],A=o[v.materialIndex],F=Math.max(v.start,m.start),O=Math.min(a.count,Math.min(v.start+v.count,m.start+m.count));for(let E=F,B=O;E<B;E+=3){const P=a.getX(E),I=a.getX(E+1),U=a.getX(E+2);n=ii(this,A,t,s,h,l,d,P,I,U),n&&(n.faceIndex=Math.floor(E/3),n.face.materialIndex=v.materialIndex,e.push(n))}}else{const f=Math.max(0,m.start),x=Math.min(a.count,m.start+m.count);for(let v=f,A=x;v<A;v+=3){const F=a.getX(v),O=a.getX(v+1),E=a.getX(v+2);n=ii(this,o,t,s,h,l,d,F,O,E),n&&(n.faceIndex=Math.floor(v/3),e.push(n))}}else if(c!==void 0)if(Array.isArray(o))for(let f=0,x=p.length;f<x;f++){const v=p[f],A=o[v.materialIndex],F=Math.max(v.start,m.start),O=Math.min(c.count,Math.min(v.start+v.count,m.start+m.count));for(let E=F,B=O;E<B;E+=3){const P=E,I=E+1,U=E+2;n=ii(this,A,t,s,h,l,d,P,I,U),n&&(n.faceIndex=Math.floor(E/3),n.face.materialIndex=v.materialIndex,e.push(n))}}else{const f=Math.max(0,m.start),x=Math.min(c.count,m.start+m.count);for(let v=f,A=x;v<A;v+=3){const F=v,O=v+1,E=v+2;n=ii(this,o,t,s,h,l,d,F,O,E),n&&(n.faceIndex=Math.floor(v/3),e.push(n))}}}}function md(i,t,e,s,n,r,o,a){let c;if(t.side===$r?c=s.intersectTriangle(o,r,n,!0,a):c=s.intersectTriangle(n,r,o,t.side===Vr,a),c===null)return null;ni.copy(a),ni.applyMatrix4(i.matrixWorld);const h=e.ray.origin.distanceTo(ni);return h<e.near||h>e.far?null:{distance:h,point:ni.clone(),object:i}}function ii(i,t,e,s,n,r,o,a,c,h){i.getVertexPosition(a,Kn),i.getVertexPosition(c,ti),i.getVertexPosition(h,ei);const l=md(i,t,e,s,Kn,ti,ei,aa);if(l){const d=new S;ce.getBarycoord(aa,Kn,ti,ei,d),n&&(l.uv=ce.getInterpolatedAttribute(n,a,c,h,d,new gt)),r&&(l.uv1=ce.getInterpolatedAttribute(r,a,c,h,d,new gt)),o&&(l.normal=ce.getInterpolatedAttribute(o,a,c,h,d,new S),l.normal.dot(s.direction)>0&&l.normal.multiplyScalar(-1));const p={a,b:c,c:h,normal:new S,materialIndex:0};ce.getNormal(Kn,ti,ei,p.normal),l.face=p,l.barycoord=d}return l}class fd extends Jt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new tt,this.projectionMatrix=new tt,this.projectionMatrixInverse=new tt,this.coordinateSystem=cs}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this.coordinateSystem=t.coordinateSystem,this}getWorldDirection(t){return super.getWorldDirection(t).negate()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Wa{constructor(t,e){this.isInterleavedBuffer=!0,this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=yi,this.updateRanges=[],this.version=0,this.uuid=Ae()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}addUpdateRange(t,e){this.updateRanges.push({start:t,count:e})}clearUpdateRanges(){this.updateRanges.length=0}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,s){t*=this.stride,s*=e.stride;for(let n=0,r=this.stride;n<r;n++)this.array[t+n]=e.array[s+n];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ae()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(e,this.stride);return s.setUsage(this.usage),s}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ae()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Et=new S;class Jr{constructor(t,e,s,n=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=t,this.itemSize=e,this.offset=s,this.normalized=n}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,s=this.data.count;e<s;e++)Et.fromBufferAttribute(this,e),Et.applyMatrix4(t),this.setXYZ(e,Et.x,Et.y,Et.z);return this}applyNormalMatrix(t){for(let e=0,s=this.count;e<s;e++)Et.fromBufferAttribute(this,e),Et.applyNormalMatrix(t),this.setXYZ(e,Et.x,Et.y,Et.z);return this}transformDirection(t){for(let e=0,s=this.count;e<s;e++)Et.fromBufferAttribute(this,e),Et.transformDirection(t),this.setXYZ(e,Et.x,Et.y,Et.z);return this}getComponent(t,e){let s=this.array[t*this.data.stride+this.offset+e];return this.normalized&&(s=ae(s,this.array)),s}setComponent(t,e,s){return this.normalized&&(s=Q(s,this.array)),this.data.array[t*this.data.stride+this.offset+e]=s,this}setX(t,e){return this.normalized&&(e=Q(e,this.array)),this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.normalized&&(e=Q(e,this.array)),this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.normalized&&(e=Q(e,this.array)),this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.normalized&&(e=Q(e,this.array)),this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){let e=this.data.array[t*this.data.stride+this.offset];return this.normalized&&(e=ae(e,this.array)),e}getY(t){let e=this.data.array[t*this.data.stride+this.offset+1];return this.normalized&&(e=ae(e,this.array)),e}getZ(t){let e=this.data.array[t*this.data.stride+this.offset+2];return this.normalized&&(e=ae(e,this.array)),e}getW(t){let e=this.data.array[t*this.data.stride+this.offset+3];return this.normalized&&(e=ae(e,this.array)),e}setXY(t,e,s){return t=t*this.data.stride+this.offset,this.normalized&&(e=Q(e,this.array),s=Q(s,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=s,this}setXYZ(t,e,s,n){return t=t*this.data.stride+this.offset,this.normalized&&(e=Q(e,this.array),s=Q(s,this.array),n=Q(n,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=s,this.data.array[t+2]=n,this}setXYZW(t,e,s,n,r){return t=t*this.data.stride+this.offset,this.normalized&&(e=Q(e,this.array),s=Q(s,this.array),n=Q(n,this.array),r=Q(r,this.array)),this.data.array[t+0]=e,this.data.array[t+1]=s,this.data.array[t+2]=n,this.data.array[t+3]=r,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let s=0;s<this.count;s++){const n=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[n+r])}return new ze(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Jr(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const e=[];for(let s=0;s<this.count;s++){const n=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[n+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class Qr extends ze{constructor(t,e,s,n=1){super(t,e,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=n}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}const pr=new S,gd=new S,yd=new te;class xd{constructor(t=new S(1,0,0),e=0){this.isPlane=!0,this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,s,n){return this.normal.set(t,e,s),this.constant=n,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,s){const n=pr.subVectors(s,e).cross(gd.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(n,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(t).addScaledVector(this.normal,-this.distanceToPoint(t))}intersectLine(t,e){const s=t.delta(pr),n=this.normal.dot(s);if(n===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/n;return r<0||r>1?null:e.copy(t.start).addScaledVector(s,r)}intersectsLine(t){const e=this.distanceToPoint(t.start),s=this.distanceToPoint(t.end);return e<0&&s>0||s<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const s=e||yd.getNormalMatrix(t),n=this.coplanarPoint(pr).applyMatrix4(t),r=this.normal.applyMatrix3(s).normalize();return this.constant=-n.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}class qa extends Zt{constructor(t,e){super({width:t,height:e}),this.isFramebufferTexture=!0,this.magFilter=Ds,this.minFilter=Ds,this.generateMipmaps=!1,this.needsUpdate=!0}}class Nn extends Zt{constructor(t,e,s,n,r,o,a,c,h,l=Xi){if(l!==Xi&&l!==Wo)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&l===Xi&&(s=Fa),s===void 0&&l===Wo&&(s=Vu),super(null,n,r,o,a,c,l,s,h),this.isDepthTexture=!0,this.image={width:t,height:e},this.magFilter=a!==void 0?a:Ds,this.minFilter=c!==void 0?c:Ds,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(t){return super.copy(t),this.compareFunction=t.compareFunction,this}toJSON(t){const e=super.toJSON(t);return this.compareFunction!==null&&(e.compareFunction=this.compareFunction),e}}class Nd extends xi{constructor(t){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Ye(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Ye(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Rr,this.normalScale=new gt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new ms,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapRotation.copy(t.envMapRotation),this.envMapIntensity=t.envMapIntensity,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this.fog=t.fog,this}}class Td extends fd{constructor(t=-1,e=1,s=1,n=-1,r=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=s,this.bottom=n,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,s,n,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=s,this.view.offsetY=n,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,n=(this.top+this.bottom)/2;let r=s-t,o=s+t,a=n+e,c=n-e;if(this.view!==null&&this.view.enabled){const h=(this.right-this.left)/this.view.fullWidth/this.zoom,l=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=h*this.view.offsetX,o=r+h*this.view.width,a-=l*this.view.offsetY,c=a-l*this.view.height}this.projectionMatrix.makeOrthographic(r,o,a,c,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}class vd extends Wa{constructor(t,e,s=1){super(t,e),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Ca}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Ca);/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const wd=["alphaMap","alphaTest","anisotropy","anisotropyMap","anisotropyRotation","aoMap","attenuationColor","attenuationDistance","bumpMap","clearcoat","clearcoatMap","clearcoatNormalMap","clearcoatNormalScale","clearcoatRoughness","color","dispersion","displacementMap","emissive","emissiveMap","envMap","gradientMap","ior","iridescence","iridescenceIOR","iridescenceMap","iridescenceThicknessMap","lightMap","map","matcap","metalness","metalnessMap","normalMap","normalScale","opacity","roughness","roughnessMap","sheen","sheenColor","sheenColorMap","sheenRoughnessMap","shininess","specular","specularColor","specularColorMap","specularIntensity","specularIntensityMap","specularMap","thickness","transmission","transmissionMap"];class Md{constructor(t){this.renderObjects=new WeakMap,this.hasNode=this.containsNode(t),this.hasAnimation=t.object.isSkinnedMesh===!0,this.refreshUniforms=wd,this.renderId=0}firstInitialization(t){return this.renderObjects.has(t)===!1?(this.getRenderObjectData(t),!0):!1}getRenderObjectData(t){let e=this.renderObjects.get(t);if(e===void 0){const{geometry:s,material:n,object:r}=t;if(e={material:this.getMaterialData(n),geometry:{attributes:this.getAttributesData(s.attributes),indexVersion:s.index?s.index.version:null,drawRange:{start:s.drawRange.start,count:s.drawRange.count}},worldMatrix:r.matrixWorld.clone()},r.center&&(e.center=r.center.clone()),r.morphTargetInfluences&&(e.morphTargetInfluences=r.morphTargetInfluences.slice()),t.bundle!==null&&(e.version=t.bundle.version),e.material.transmission>0){const{width:o,height:a}=t.context;e.bufferWidth=o,e.bufferHeight=a}this.renderObjects.set(t,e)}return e}getAttributesData(t){const e={};for(const s in t){const n=t[s];e[s]={version:n.version}}return e}containsNode(t){const e=t.material;for(const s in e)if(e[s]&&e[s].isNode)return!0;return t.renderer.nodes.modelViewMatrix!==null||t.renderer.nodes.modelNormalViewMatrix!==null}getMaterialData(t){const e={};for(const s of this.refreshUniforms){const n=t[s];n!=null&&(typeof n=="object"&&n.clone!==void 0?n.isTexture===!0?e[s]={id:n.id,version:n.version}:e[s]=n.clone():e[s]=n)}return e}equals(t){const{object:e,material:s,geometry:n}=t,r=this.getRenderObjectData(t);if(r.worldMatrix.equals(e.matrixWorld)!==!0)return r.worldMatrix.copy(e.matrixWorld),!1;const o=r.material;for(const x in o){const v=o[x],A=s[x];if(v.equals!==void 0){if(v.equals(A)===!1)return v.copy(A),!1}else if(A.isTexture===!0){if(v.id!==A.id||v.version!==A.version)return v.id=A.id,v.version=A.version,!1}else if(v!==A)return o[x]=A,!1}if(o.transmission>0){const{width:x,height:v}=t.context;if(r.bufferWidth!==x||r.bufferHeight!==v)return r.bufferWidth=x,r.bufferHeight=v,!1}const a=r.geometry,c=n.attributes,h=a.attributes,l=Object.keys(h),d=Object.keys(c);if(l.length!==d.length)return r.geometry.attributes=this.getAttributesData(c),!1;for(const x of l){const v=h[x],A=c[x];if(A===void 0)return delete h[x],!1;if(v.version!==A.version)return v.version=A.version,!1}const p=n.index,m=a.indexVersion,f=p?p.version:null;if(m!==f)return a.indexVersion=f,!1;if(a.drawRange.start!==n.drawRange.start||a.drawRange.count!==n.drawRange.count)return a.drawRange.start=n.drawRange.start,a.drawRange.count=n.drawRange.count,!1;if(r.morphTargetInfluences){let x=!1;for(let v=0;v<r.morphTargetInfluences.length;v++)r.morphTargetInfluences[v]!==e.morphTargetInfluences[v]&&(x=!0);if(x)return!0}return r.center&&r.center.equals(e.center)===!1?(r.center.copy(e.center),!0):(t.bundle!==null&&(r.version=t.bundle.version),!0)}needsRefresh(t,e){if(this.hasNode||this.hasAnimation||this.firstInitialization(t))return!0;const{renderId:s}=e;if(this.renderId!==s)return this.renderId=s,!0;const n=t.object.static===!0,r=t.bundle!==null&&t.bundle.static===!0&&this.getRenderObjectData(t).version===t.bundle.version;return n||r?!1:this.equals(t)!==!0}}function pn(i,t=0){let e=3735928559^t,s=1103547991^t;if(i instanceof Array)for(let n=0,r;n<i.length;n++)r=i[n],e=Math.imul(e^r,2654435761),s=Math.imul(s^r,1597334677);else for(let n=0,r;n<i.length;n++)r=i.charCodeAt(n),e=Math.imul(e^r,2654435761),s=Math.imul(s^r,1597334677);return e=Math.imul(e^e>>>16,2246822507),e^=Math.imul(s^s>>>13,3266489909),s=Math.imul(s^s>>>16,2246822507),s^=Math.imul(e^e>>>13,3266489909),4294967296*(2097151&s)+(e>>>0)}const _d=i=>pn(i),bd=i=>pn(i),Sd=(...i)=>pn(i);function Ga(i,t=!1){const e=[];i.isNode===!0&&(e.push(i.id),i=i.getSelf());for(const{property:s,childNode:n}of Ni(i))e.push(e,pn(s.slice(0,-4)),n.getCacheKey(t));return pn(e)}function*Ni(i,t=!1){for(const e in i){if(e.startsWith("_")===!0)continue;const s=i[e];if(Array.isArray(s)===!0)for(let n=0;n<s.length;n++){const r=s[n];r&&(r.isNode===!0||t&&typeof r.toJSON=="function")&&(yield{property:e,index:n,childNode:r})}else if(s&&s.isNode===!0)yield{property:e,childNode:s};else if(typeof s=="object")for(const n in s){const r=s[n];r&&(r.isNode===!0||t&&typeof r.toJSON=="function")&&(yield{property:e,index:n,childNode:r})}}}const Ad=new Map([[1,"float"],[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]);function Vd(i){return Ad.get(i)}function Ha(i){if(/float|int|uint/.test(i))return 1;if(/vec2/.test(i))return 2;if(/vec3/.test(i))return 3;if(/vec4/.test(i))return 4;if(/mat3/.test(i))return 9;if(/mat4/.test(i))return 16;console.error("THREE.TSL: Unsupported type:",i)}function $e(i){if(i==null)return null;const t=typeof i;return i.isNode===!0?"node":t==="number"?"float":t==="boolean"?"bool":t==="string"?"string":t==="function"?"shader":i.isVector2===!0?"vec2":i.isVector3===!0?"vec3":i.isVector4===!0?"vec4":i.isMatrix3===!0?"mat3":i.isMatrix4===!0?"mat4":i.isColor===!0?"color":i instanceof ArrayBuffer?"ArrayBuffer":null}function ja(i,...t){const e=i?i.slice(-4):void 0;return t.length===1&&(e==="vec2"?t=[t[0],t[0]]:e==="vec3"?t=[t[0],t[0],t[0]]:e==="vec4"&&(t=[t[0],t[0],t[0],t[0]])),i==="color"?new Ye(...t):e==="vec2"?new gt(...t):e==="vec3"?new S(...t):e==="vec4"?new It(...t):e==="mat3"?new te(...t):e==="mat4"?new tt(...t):i==="bool"?t[0]||!1:i==="float"||i==="int"||i==="uint"?t[0]||0:i==="string"?t[0]||"":i==="ArrayBuffer"?$a(t[0]):null}function Xa(i){let t="";const e=new Uint8Array(i);for(let s=0;s<e.length;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function $a(i){return Uint8Array.from(atob(i),t=>t.charCodeAt(0)).buffer}const Ir={VERTEX:"vertex",FRAGMENT:"fragment"},$={NONE:"none",FRAME:"frame",RENDER:"render",OBJECT:"object"},zd={BOOLEAN:"bool",INTEGER:"int",FLOAT:"float",VECTOR2:"vec2",VECTOR3:"vec3",VECTOR4:"vec4",MATRIX2:"mat2",MATRIX3:"mat3",MATRIX4:"mat4"},pe={READ_ONLY:"readOnly",WRITE_ONLY:"writeOnly",READ_WRITE:"readWrite"},Ya=["fragment","vertex"],Cd=["setup","analyze","generate"],Rd=[...Ya,"compute"],Gs=["x","y","z","w"];let Ed=0;class L extends ps{static get type(){return"Node"}constructor(t=null){super(),this.nodeType=t,this.updateType=$.NONE,this.updateBeforeType=$.NONE,this.updateAfterType=$.NONE,this.uuid=Ba.generateUUID(),this.version=0,this._cacheKey=null,this._cacheKeyVersion=0,this.global=!1,this.isNode=!0,Object.defineProperty(this,"id",{value:Ed++})}set needsUpdate(t){t===!0&&this.version++}get type(){return this.constructor.type}onUpdate(t,e){return this.updateType=e,this.update=t.bind(this.getSelf()),this}onFrameUpdate(t){return this.onUpdate(t,$.FRAME)}onRenderUpdate(t){return this.onUpdate(t,$.RENDER)}onObjectUpdate(t){return this.onUpdate(t,$.OBJECT)}onReference(t){return this.updateReference=t.bind(this.getSelf()),this}getSelf(){return this.self||this}updateReference(){return this}isGlobal(){return this.global}*getChildren(){for(const{childNode:t}of Ni(this))yield t}dispose(){this.dispatchEvent({type:"dispose"})}traverse(t){t(this);for(const e of this.getChildren())e.traverse(t)}getCacheKey(t=!1){return t=t||this.version!==this._cacheKeyVersion,(t===!0||this._cacheKey===null)&&(this._cacheKey=Ga(this,t),this._cacheKeyVersion=this.version),this._cacheKey}getScope(){return this}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getUpdateAfterType(){return this.updateAfterType}getElementType(t){const e=this.getNodeType(t);return t.getElementType(e)}getNodeType(t){const e=t.getNodeProperties(this);return e.outputNode?e.outputNode.getNodeType(t):this.nodeType}getShared(t){const e=this.getHash(t);return t.getNodeFromHash(e)||this}setup(t){const e=t.getNodeProperties(this);let s=0;for(const n of this.getChildren())e["node"+s++]=n;return null}analyze(t){if(t.increaseUsage(this)===1){const s=t.getNodeProperties(this);for(const n of Object.values(s))n&&n.isNode===!0&&n.build(t)}}generate(t,e){const{outputNode:s}=t.getNodeProperties(this);if(s&&s.isNode===!0)return s.build(t,e)}updateBefore(){console.warn("Abstract function.")}updateAfter(){console.warn("Abstract function.")}update(){console.warn("Abstract function.")}build(t,e=null){const s=this.getShared(t);if(this!==s)return s.build(t,e);t.addNode(this),t.addChain(this);let n=null;const r=t.getBuildStage();if(r==="setup"){this.updateReference(t);const o=t.getNodeProperties(this);if(o.initialized!==!0){const a=t.stack.nodes.length;o.initialized=!0,o.outputNode=this.setup(t),o.outputNode!==null&&t.stack.nodes.length;for(const c of Object.values(o))c&&c.isNode===!0&&c.build(t)}}else if(r==="analyze")this.analyze(t);else if(r==="generate")if(this.generate.length===1){const a=this.getNodeType(t),c=t.getDataFromNode(this);n=c.snippet,n===void 0?(n=this.generate(t)||"",c.snippet=n):c.flowCodes!==void 0&&t.context.nodeBlock!==void 0&&t.addFlowCodeHierarchy(this,t.context.nodeBlock),n=t.format(n,a,e)}else n=this.generate(t,e)||"";return t.removeChain(this),t.addSequentialNode(this),n}getSerializeChildren(){return Ni(this)}serialize(t){const e=this.getSerializeChildren(),s={};for(const{property:n,index:r,childNode:o}of e)r!==void 0?(s[n]===void 0&&(s[n]=Number.isInteger(r)?[]:{}),s[n][r]=o.toJSON(t.meta).uuid):s[n]=o.toJSON(t.meta).uuid;Object.keys(s).length>0&&(t.inputNodes=s)}deserialize(t){if(t.inputNodes!==void 0){const e=t.meta.nodes;for(const s in t.inputNodes)if(Array.isArray(t.inputNodes[s])){const n=[];for(const r of t.inputNodes[s])n.push(e[r]);this[s]=n}else if(typeof t.inputNodes[s]=="object"){const n={};for(const r in t.inputNodes[s]){const o=t.inputNodes[s][r];n[r]=e[o]}this[s]=n}else{const n=t.inputNodes[s];this[s]=e[n]}}}toJSON(t){const{uuid:e,type:s}=this,n=t===void 0||typeof t=="string";n&&(t={textures:{},images:{},nodes:{}});let r=t.nodes[e];r===void 0&&(r={uuid:e,type:s,meta:t,metadata:{version:4.6,type:"Node",generator:"Node.toJSON"}},n!==!0&&(t.nodes[r.uuid]=r),this.serialize(r),delete r.meta);function o(a){const c=[];for(const h in a){const l=a[h];delete l.metadata,c.push(l)}return c}if(n){const a=o(t.textures),c=o(t.images),h=o(t.nodes);a.length>0&&(r.textures=a),c.length>0&&(r.images=c),h.length>0&&(r.nodes=h)}return r}}class fs extends L{static get type(){return"ArrayElementNode"}constructor(t,e){super(),this.node=t,this.indexNode=e,this.isArrayElementNode=!0}getNodeType(t){return this.node.getElementType(t)}generate(t){const e=this.node.build(t),s=this.indexNode.build(t,"uint");return`${e}[ ${s} ]`}}class Za extends L{static get type(){return"ConvertNode"}constructor(t,e){super(),this.node=t,this.convertTo=e}getNodeType(t){const e=this.node.getNodeType(t);let s=null;for(const n of this.convertTo.split("|"))(s===null||t.getTypeLength(e)===t.getTypeLength(n))&&(s=n);return s}serialize(t){super.serialize(t),t.convertTo=this.convertTo}deserialize(t){super.deserialize(t),this.convertTo=t.convertTo}generate(t,e){const s=this.node,n=this.getNodeType(t),r=s.build(t,n);return t.format(r,n,e)}}class pt extends L{static get type(){return"TempNode"}constructor(t){super(t),this.isTempNode=!0}hasDependencies(t){return t.getDataFromNode(this).usageCount>1}build(t,e){if(t.getBuildStage()==="generate"){const n=t.getVectorType(this.getNodeType(t,e)),r=t.getDataFromNode(this);if(r.propertyName!==void 0)return t.format(r.propertyName,n,e);if(n!=="void"&&e!=="void"&&this.hasDependencies(t)){const o=super.build(t,n),a=t.getVarFromNode(this,null,n),c=t.getPropertyName(a);return t.addLineFlowCode(`${c} = ${o}`,this),r.snippet=o,r.propertyName=c,t.format(r.propertyName,n,e)}}return super.build(t,e)}}class Fd extends pt{static get type(){return"JoinNode"}constructor(t=[],e=null){super(e),this.nodes=t}getNodeType(t){return this.nodeType!==null?t.getVectorType(this.nodeType):t.getTypeFromLength(this.nodes.reduce((e,s)=>e+t.getTypeLength(s.getNodeType(t)),0))}generate(t,e){const s=this.getNodeType(t),n=this.nodes,r=t.getComponentType(s),o=[];for(const c of n){let h=c.build(t);const l=t.getComponentType(c.getNodeType(t));l!==r&&(h=t.format(h,l,r)),o.push(h)}const a=`${t.getType(s)}( ${o.join(", ")} )`;return t.format(a,s,e)}}const Id=Gs.join("");class Or extends L{static get type(){return"SplitNode"}constructor(t,e="x"){super(),this.node=t,this.components=e,this.isSplitNode=!0}getVectorLength(){let t=this.components.length;for(const e of this.components)t=Math.max(Gs.indexOf(e)+1,t);return t}getComponentType(t){return t.getComponentType(this.node.getNodeType(t))}getNodeType(t){return t.getTypeFromLength(this.components.length,this.getComponentType(t))}generate(t,e){const s=this.node,n=t.getTypeLength(s.getNodeType(t));let r=null;if(n>1){let o=null;this.getVectorLength()>=n&&(o=t.getTypeFromLength(this.getVectorLength(),this.getComponentType(t)));const c=s.build(t,o);this.components.length===n&&this.components===Id.slice(0,this.components.length)?r=t.format(c,o,e):r=t.format(`${c}.${this.components}`,this.getNodeType(t),e)}else r=s.build(t,e);return r}serialize(t){super.serialize(t),t.components=this.components}deserialize(t){super.deserialize(t),this.components=t.components}}class Od extends pt{static get type(){return"SetNode"}constructor(t,e,s){super(),this.sourceNode=t,this.components=e,this.targetNode=s}getNodeType(t){return this.sourceNode.getNodeType(t)}generate(t){const{sourceNode:e,components:s,targetNode:n}=this,r=this.getNodeType(t),o=t.getTypeFromLength(s.length,n.getNodeType(t)),a=n.build(t,o),c=e.build(t,r),h=t.getTypeLength(r),l=[];for(let d=0;d<h;d++){const p=Gs[d];p===s[0]?(l.push(a),d+=s.length-1):l.push(c+"."+p)}return`${t.getType(r)}( ${l.join(", ")} )`}}class Ld extends pt{static get type(){return"FlipNode"}constructor(t,e){super(),this.sourceNode=t,this.components=e}getNodeType(t){return this.sourceNode.getNodeType(t)}generate(t){const{components:e,sourceNode:s}=this,n=this.getNodeType(t),r=s.build(t),o=t.getVarFromNode(this),a=t.getPropertyName(o);t.addLineFlowCode(a+" = "+r,this);const c=t.getTypeLength(n),h=[];let l=0;for(let d=0;d<c;d++){const p=Gs[d];p===e[l]?(h.push("1.0 - "+(a+"."+p)),l++):h.push(a+"."+p)}return`${t.getType(n)}( ${h.join(", ")} )`}}class Kr extends L{static get type(){return"InputNode"}constructor(t,e=null){super(e),this.isInputNode=!0,this.value=t,this.precision=null}getNodeType(){return this.nodeType===null?$e(this.value):this.nodeType}getInputType(t){return this.getNodeType(t)}setPrecision(t){return this.precision=t,this}serialize(t){super.serialize(t),t.value=this.value,this.value&&this.value.toArray&&(t.value=this.value.toArray()),t.valueType=$e(this.value),t.nodeType=this.nodeType,t.valueType==="ArrayBuffer"&&(t.value=Xa(t.value)),t.precision=this.precision}deserialize(t){super.deserialize(t),this.nodeType=t.nodeType,this.value=Array.isArray(t.value)?ja(t.valueType,...t.value):t.value,this.precision=t.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(t.value))}generate(){console.warn("Abstract function.")}}class le extends Kr{static get type(){return"ConstNode"}constructor(t,e=null){super(t,e),this.isConstNode=!0}generateConst(t){return t.generateConst(this.getNodeType(t),this.value)}generate(t,e){const s=this.getNodeType(t);return t.format(this.generateConst(t),s,e)}}let Us=null;const Os=new Map;function b(i,t){if(Os.has(i)){console.warn(`Redefinition of method chaining ${i}`);return}if(typeof t!="function")throw new Error(`Node element ${i} is not a function`);Os.set(i,t)}const Ja=i=>i.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"),ca=i=>Ja(i).split("").sort().join(""),Qa={setup(i,t){const e=t.shift();return i(Tn(e),...t)},get(i,t,e){if(typeof t=="string"&&i[t]===void 0){if(i.isStackNode!==!0&&t==="assign")return(...s)=>(Us.assign(e,...s),e);if(Os.has(t)){const s=Os.get(t);return i.isStackNode?(...n)=>e.add(s(...n)):(...n)=>s(e,...n)}else{if(t==="self")return i;if(t.endsWith("Assign")&&Os.has(t.slice(0,t.length-6))){const s=Os.get(t.slice(0,t.length-6));return i.isStackNode?(...n)=>e.assign(n[0],s(...n)):(...n)=>e.assign(s(e,...n))}else{if(/^[xyzwrgbastpq]{1,4}$/.test(t)===!0)return t=Ja(t),V(new Or(e,t));if(/^set[XYZWRGBASTPQ]{1,4}$/.test(t)===!0)return t=ca(t.slice(3).toLowerCase()),s=>V(new Od(i,t,s));if(/^flip[XYZWRGBASTPQ]{1,4}$/.test(t)===!0)return t=ca(t.slice(4).toLowerCase()),()=>V(new Ld(V(i),t));if(t==="width"||t==="height"||t==="depth")return t==="width"?t="x":t==="height"?t="y":t==="depth"&&(t="z"),V(new Or(i,t));if(/^\d+$/.test(t)===!0)return V(new fs(e,new le(Number(t),"uint")))}}}return Reflect.get(i,t,e)},set(i,t,e,s){return typeof t=="string"&&i[t]===void 0&&(/^[xyzwrgbastpq]{1,4}$/.test(t)===!0||t==="width"||t==="height"||t==="depth"||/^\d+$/.test(t)===!0)?(s[t].assign(e),!0):Reflect.set(i,t,e,s)}},mr=new WeakMap,ha=new WeakMap,Bd=function(i,t=null){const e=$e(i);if(e==="node"){let s=mr.get(i);return s===void 0&&(s=new Proxy(i,Qa),mr.set(i,s),mr.set(s,s)),s}else{if(t===null&&(e==="float"||e==="boolean")||e&&e!=="shader"&&e!=="string")return V(Lr(i,t));if(e==="shader")return w(i)}return i},Pd=function(i,t=null){for(const e in i)i[e]=V(i[e],t);return i},Dd=function(i,t=null){const e=i.length;for(let s=0;s<e;s++)i[s]=V(i[s],t);return i},kd=function(i,t=null,e=null,s=null){const n=r=>V(s!==null?Object.assign(r,s):r);return t===null?(...r)=>n(new i(...hs(r))):e!==null?(e=V(e),(...r)=>n(new i(t,...hs(r),e))):(...r)=>n(new i(t,...hs(r)))},Ud=function(i,...t){return V(new i(...hs(t)))};class Wd extends L{constructor(t,e){super(),this.shaderNode=t,this.inputNodes=e}getNodeType(t){return this.shaderNode.nodeType||this.getOutputNode(t).getNodeType(t)}call(t){const{shaderNode:e,inputNodes:s}=this,n=t.getNodeProperties(e);if(n.onceOutput)return n.onceOutput;let r=null;if(e.layout){let o=ha.get(t.constructor);o===void 0&&(o=new WeakMap,ha.set(t.constructor,o));let a=o.get(e);a===void 0&&(a=V(t.buildFunctionNode(e)),o.set(e,a)),t.currentFunctionNode!==null&&t.currentFunctionNode.includes.push(a),r=V(a.call(s))}else{const o=e.jsFunc,a=s!==null?o(s,t):o(t);r=V(a)}return e.once&&(n.onceOutput=r),r}getOutputNode(t){const e=t.getNodeProperties(this);return e.outputNode===null&&(e.outputNode=this.setupOutput(t)),e.outputNode}setup(t){return this.getOutputNode(t)}setupOutput(t){return t.addStack(),t.stack.outputNode=this.call(t),t.removeStack()}generate(t,e){return this.getOutputNode(t).build(t,e)}}class qd extends L{constructor(t,e){super(e),this.jsFunc=t,this.layout=null,this.global=!0,this.once=!1}setLayout(t){return this.layout=t,this}call(t=null){return Tn(t),V(new Wd(this,t))}setup(){return this.call()}}const Gd=[!1,!0],Hd=[0,1,2,3],jd=[-1,-2],Ka=[.5,1.5,1/3,1e-6,1e6,Math.PI,Math.PI*2,1/Math.PI,2/Math.PI,1/(Math.PI*2),Math.PI/2],to=new Map;for(const i of Gd)to.set(i,new le(i));const eo=new Map;for(const i of Hd)eo.set(i,new le(i,"uint"));const so=new Map([...eo].map(i=>new le(i.value,"int")));for(const i of jd)so.set(i,new le(i,"int"));const Ei=new Map([...so].map(i=>new le(i.value)));for(const i of Ka)Ei.set(i,new le(i));for(const i of Ka)Ei.set(-i,new le(-i));const Fi={bool:to,uint:eo,ints:so,float:Ei},la=new Map([...to,...Ei]),Lr=(i,t)=>la.has(i)?la.get(i):i.isNode===!0?i:new le(i,t),Xd=i=>{try{return i.getNodeType()}catch{return}},yt=function(i,t=null){return(...e)=>{if((e.length===0||!["bool","float","int","uint"].includes(i)&&e.every(n=>typeof n!="object"))&&(e=[ja(i,...e)]),e.length===1&&t!==null&&t.has(e[0]))return V(t.get(e[0]));if(e.length===1){const n=Lr(e[0],i);return Xd(n)===i?V(n):V(new Za(n,i))}const s=e.map(n=>Lr(n));return V(new Fd(s,i))}},mn=i=>typeof i=="object"&&i!==null?i.value:i,tc=i=>i!=null?i.nodeType||i.convertTo||(typeof i=="string"?i:null):null;function ln(i,t){return new Proxy(new qd(i,t),Qa)}const V=(i,t=null)=>Bd(i,t),Tn=(i,t=null)=>new Pd(i,t),hs=(i,t=null)=>new Dd(i,t),_=(...i)=>new kd(...i),C=(...i)=>new Ud(...i),w=(i,t)=>{const e=new ln(i,t),s=(...n)=>{let r;return Tn(n),n[0]&&n[0].isNode?r=[...n]:r=n[0],e.call(r)};return s.shaderNode=e,s.setLayout=n=>(e.setLayout(n),s),s.once=()=>(e.once=!0,s),s},$d=(...i)=>(console.warn("TSL.ShaderNode: tslFn() has been renamed to Fn()."),w(...i));b("toGlobal",i=>(i.global=!0,i));const Br=i=>{Us=i},ec=()=>Us,q=(...i)=>Us.If(...i);function sc(i){return Us&&Us.add(i),i}b("append",sc);const nc=new yt("color"),g=new yt("float",Fi.float),y=new yt("int",Fi.ints),R=new yt("uint",Fi.uint),Re=new yt("bool",Fi.bool),z=new yt("vec2"),Nt=new yt("ivec2"),ic=new yt("uvec2"),rc=new yt("bvec2"),T=new yt("vec3"),oc=new yt("ivec3"),Hs=new yt("uvec3"),no=new yt("bvec3"),D=new yt("vec4"),ac=new yt("ivec4"),cc=new yt("uvec4"),hc=new yt("bvec4"),Ii=new yt("mat2"),Kt=new yt("mat3"),ls=new yt("mat4"),Yd=(i="")=>V(new le(i,"string")),Zd=i=>V(new le(i,"ArrayBuffer"));b("toColor",nc);b("toFloat",g);b("toInt",y);b("toUint",R);b("toBool",Re);b("toVec2",z);b("toIVec2",Nt);b("toUVec2",ic);b("toBVec2",rc);b("toVec3",T);b("toIVec3",oc);b("toUVec3",Hs);b("toBVec3",no);b("toVec4",D);b("toIVec4",ac);b("toUVec4",cc);b("toBVec4",hc);b("toMat2",Ii);b("toMat3",Kt);b("toMat4",ls);const lc=_(fs),uc=(i,t)=>V(new Za(V(i),t)),Jd=(i,t)=>V(new Or(V(i),t));b("element",lc);b("convert",uc);class dc extends L{static get type(){return"UniformGroupNode"}constructor(t,e=!1,s=1){super("string"),this.name=t,this.version=0,this.shared=e,this.order=s,this.isUniformGroup=!0}set needsUpdate(t){t===!0&&this.version++}serialize(t){super.serialize(t),t.name=this.name,t.version=this.version,t.shared=this.shared}deserialize(t){super.deserialize(t),this.name=t.name,this.version=t.version,this.shared=t.shared}}const pc=i=>new dc(i),io=(i,t=0)=>new dc(i,!0,t),Qd=io("frame"),X=io("render"),mc=pc("object");class vn extends Kr{static get type(){return"UniformNode"}constructor(t,e=null){super(t,e),this.isUniformNode=!0,this.name="",this.groupNode=mc}label(t){return this.name=t,this}setGroup(t){return this.groupNode=t,this}getGroup(){return this.groupNode}getUniformHash(t){return this.getHash(t)}onUpdate(t,e){const s=this.getSelf();return t=t.bind(s),super.onUpdate(n=>{const r=t(n,s);r!==void 0&&(this.value=r)},e)}generate(t,e){const s=this.getNodeType(t),n=this.getUniformHash(t);let r=t.getNodeFromHash(n);r===void 0&&(t.setHashNode(this,n),r=this);const o=r.getInputType(t),a=t.getUniformFromNode(r,o,t.shaderStage,this.name||t.context.label),c=t.getPropertyName(a);return t.context.label!==void 0&&delete t.context.label,t.format(c,s,e)}}const W=(i,t)=>{const e=tc(t||i),s=i&&i.isNode===!0?i.node&&i.node.value||i.value:i;return V(new vn(s,e))};class Y extends L{static get type(){return"PropertyNode"}constructor(t,e=null,s=!1){super(t),this.name=e,this.varying=s,this.isPropertyNode=!0}getHash(t){return this.name||super.getHash(t)}isGlobal(){return!0}generate(t){let e;return this.varying===!0?(e=t.getVaryingFromNode(this,this.name),e.needsInterpolation=!0):e=t.getVarFromNode(this,this.name),t.getPropertyName(e)}}const fc=(i,t)=>V(new Y(i,t)),fn=(i,t)=>V(new Y(i,t,!0)),re=C(Y,"vec4","DiffuseColor"),Pr=C(Y,"vec3","EmissiveColor"),gc=C(Y,"float","Roughness"),Kd=C(Y,"float","Metalness"),tp=C(Y,"float","Clearcoat"),ep=C(Y,"float","ClearcoatRoughness"),sp=C(Y,"vec3","Sheen"),np=C(Y,"float","SheenRoughness"),yc=C(Y,"float","Iridescence"),ip=C(Y,"float","IridescenceIOR"),rp=C(Y,"float","IridescenceThickness"),Dr=C(Y,"float","AlphaT"),xc=C(Y,"float","Anisotropy"),pi=C(Y,"vec3","AnisotropyT"),Bs=C(Y,"vec3","AnisotropyB"),op=C(Y,"color","SpecularColor"),ap=C(Y,"float","SpecularF90"),cp=C(Y,"float","Shininess"),Nc=C(Y,"vec4","Output"),hp=C(Y,"float","dashSize"),lp=C(Y,"float","gapSize"),up=C(Y,"float","pointWidth"),dp=C(Y,"float","IOR"),pp=C(Y,"float","Transmission"),mp=C(Y,"float","Thickness"),fp=C(Y,"float","AttenuationDistance"),gp=C(Y,"color","AttenuationColor"),yp=C(Y,"float","Dispersion");class xp extends pt{static get type(){return"AssignNode"}constructor(t,e){super(),this.targetNode=t,this.sourceNode=e}hasDependencies(){return!1}getNodeType(t,e){return e!=="void"?this.targetNode.getNodeType(t):"void"}needsSplitAssign(t){const{targetNode:e}=this;if(t.isAvailable("swizzleAssign")===!1&&e.isSplitNode&&e.components.length>1){const s=t.getTypeLength(e.node.getNodeType(t));return Gs.join("").slice(0,s)!==e.components}return!1}generate(t,e){const{targetNode:s,sourceNode:n}=this,r=this.needsSplitAssign(t),o=s.getNodeType(t),a=s.context({assign:!0}).build(t),c=n.build(t,o),h=n.getNodeType(t),l=t.getDataFromNode(this);let d;if(l.initialized===!0)e!=="void"&&(d=a);else if(r){const p=t.getVarFromNode(this,null,o),m=t.getPropertyName(p);t.addLineFlowCode(`${m} = ${c}`,this);const f=s.node.context({assign:!0}).build(t);for(let x=0;x<s.components.length;x++){const v=s.components[x];t.addLineFlowCode(`${f}.${v} = ${m}[ ${x} ]`,this)}e!=="void"&&(d=a)}else d=`${a} = ${c}`,(e==="void"||h==="void")&&(t.addLineFlowCode(d,this),e!=="void"&&(d=a));return l.initialized=!0,t.format(d,o,e)}}const Tc=_(xp);b("assign",Tc);class Np extends pt{static get type(){return"FunctionCallNode"}constructor(t=null,e={}){super(),this.functionNode=t,this.parameters=e}setParameters(t){return this.parameters=t,this}getParameters(){return this.parameters}getNodeType(t){return this.functionNode.getNodeType(t)}generate(t){const e=[],s=this.functionNode,n=s.getInputs(t),r=this.parameters,o=(c,h)=>{const l=h.type,d=l==="pointer";let p;return d?p="&"+c.build(t):p=c.build(t,l),p};if(Array.isArray(r))for(let c=0;c<r.length;c++)e.push(o(r[c],n[c]));else for(const c of n){const h=r[c.name];if(h!==void 0)e.push(o(h,c));else throw new Error(`FunctionCallNode: Input '${c.name}' not found in FunctionNode.`)}return`${s.build(t,"property")}( ${e.join(", ")} )`}}const vc=(i,...t)=>(t=t.length>1||t[0]&&t[0].isNode===!0?hs(t):Tn(t[0]),V(new Np(V(i),t)));b("call",vc);class it extends pt{static get type(){return"OperatorNode"}constructor(t,e,s,...n){if(super(),n.length>0){let r=new it(t,e,s);for(let o=0;o<n.length-1;o++)r=new it(t,r,n[o]);e=r,s=n[n.length-1]}this.op=t,this.aNode=e,this.bNode=s}getNodeType(t,e){const s=this.op,n=this.aNode,r=this.bNode,o=n.getNodeType(t),a=typeof r<"u"?r.getNodeType(t):null;if(o==="void"||a==="void")return"void";if(s==="%")return o;if(s==="~"||s==="&"||s==="|"||s==="^"||s===">>"||s==="<<")return t.getIntegerType(o);if(s==="!"||s==="=="||s==="&&"||s==="||"||s==="^^")return"bool";if(s==="<"||s===">"||s==="<="||s===">="){const c=e?t.getTypeLength(e):Math.max(t.getTypeLength(o),t.getTypeLength(a));return c>1?`bvec${c}`:"bool"}else return o==="float"&&t.isMatrix(a)?a:t.isMatrix(o)&&t.isVector(a)?t.getVectorFromMatrix(o):t.isVector(o)&&t.isMatrix(a)?t.getVectorFromMatrix(a):t.getTypeLength(a)>t.getTypeLength(o)?a:o}generate(t,e){const s=this.op,n=this.aNode,r=this.bNode,o=this.getNodeType(t,e);let a=null,c=null;o!=="void"?(a=n.getNodeType(t),c=typeof r<"u"?r.getNodeType(t):null,s==="<"||s===">"||s==="<="||s===">="||s==="=="?t.isVector(a)?c=a:a!==c&&(a=c="float"):s===">>"||s==="<<"?(a=o,c=t.changeComponentType(c,"uint")):t.isMatrix(a)&&t.isVector(c)?c=t.getVectorFromMatrix(a):t.isVector(a)&&t.isMatrix(c)?a=t.getVectorFromMatrix(c):a=c=o):a=c=o;const h=n.build(t,a),l=typeof r<"u"?r.build(t,c):null,d=t.getTypeLength(e),p=t.getFunctionOperator(s);if(e!=="void")return s==="<"&&d>1?t.useComparisonMethod?t.format(`${t.getMethod("lessThan",e)}( ${h}, ${l} )`,o,e):t.format(`( ${h} < ${l} )`,o,e):s==="<="&&d>1?t.useComparisonMethod?t.format(`${t.getMethod("lessThanEqual",e)}( ${h}, ${l} )`,o,e):t.format(`( ${h} <= ${l} )`,o,e):s===">"&&d>1?t.useComparisonMethod?t.format(`${t.getMethod("greaterThan",e)}( ${h}, ${l} )`,o,e):t.format(`( ${h} > ${l} )`,o,e):s===">="&&d>1?t.useComparisonMethod?t.format(`${t.getMethod("greaterThanEqual",e)}( ${h}, ${l} )`,o,e):t.format(`( ${h} >= ${l} )`,o,e):s==="!"||s==="~"?t.format(`(${s}${h})`,a,e):p?t.format(`${p}( ${h}, ${l} )`,o,e):t.format(`( ${h} ${s} ${l} )`,o,e);if(a!=="void")return p?t.format(`${p}( ${h}, ${l} )`,o,e):t.format(`${h} ${s} ${l}`,o,e)}serialize(t){super.serialize(t),t.op=this.op}deserialize(t){super.deserialize(t),this.op=t.op}}const dt=_(it,"+"),H=_(it,"-"),k=_(it,"*"),Ee=_(it,"/"),ro=_(it,"%"),wc=_(it,"=="),Mc=_(it,"!="),_c=_(it,"<"),oo=_(it,">"),bc=_(it,"<="),Sc=_(it,">="),Ac=_(it,"&&"),Vc=_(it,"||"),zc=_(it,"!"),Cc=_(it,"^^"),Rc=_(it,"&"),Ec=_(it,"~"),Fc=_(it,"|"),Ic=_(it,"^"),Oc=_(it,"<<"),Lc=_(it,">>");b("add",dt);b("sub",H);b("mul",k);b("div",Ee);b("modInt",ro);b("equal",wc);b("notEqual",Mc);b("lessThan",_c);b("greaterThan",oo);b("lessThanEqual",bc);b("greaterThanEqual",Sc);b("and",Ac);b("or",Vc);b("not",zc);b("xor",Cc);b("bitAnd",Rc);b("bitNot",Ec);b("bitOr",Fc);b("bitXor",Ic);b("shiftLeft",Oc);b("shiftRight",Lc);const Bc=(...i)=>(console.warn("TSL.OperatorNode: .remainder() has been renamed to .modInt()."),ro(...i));b("remainder",Bc);class N extends pt{static get type(){return"MathNode"}constructor(t,e,s=null,n=null){super(),this.method=t,this.aNode=e,this.bNode=s,this.cNode=n}getInputType(t){const e=this.aNode.getNodeType(t),s=this.bNode?this.bNode.getNodeType(t):null,n=this.cNode?this.cNode.getNodeType(t):null,r=t.isMatrix(e)?0:t.getTypeLength(e),o=t.isMatrix(s)?0:t.getTypeLength(s),a=t.isMatrix(n)?0:t.getTypeLength(n);return r>o&&r>a?e:o>a?s:a>r?n:e}getNodeType(t){const e=this.method;return e===N.LENGTH||e===N.DISTANCE||e===N.DOT?"float":e===N.CROSS?"vec3":e===N.ALL?"bool":e===N.EQUALS?t.changeComponentType(this.aNode.getNodeType(t),"bool"):e===N.MOD?this.aNode.getNodeType(t):this.getInputType(t)}generate(t,e){const s=this.method,n=this.getNodeType(t),r=this.getInputType(t),o=this.aNode,a=this.bNode,c=this.cNode,h=t.renderer.isWebGLRenderer===!0;if(s===N.TRANSFORM_DIRECTION){let l=o,d=a;t.isMatrix(l.getNodeType(t))?d=D(T(d),0):l=D(T(l),0);const p=k(l,d).xyz;return gs(p).build(t,e)}else{if(s===N.NEGATE)return t.format("( - "+o.build(t,r)+" )",n,e);if(s===N.ONE_MINUS)return H(1,o).build(t,e);if(s===N.RECIPROCAL)return Ee(1,o).build(t,e);if(s===N.DIFFERENCE)return et(H(o,a)).build(t,e);{const l=[];return s===N.CROSS||s===N.MOD?l.push(o.build(t,n),a.build(t,n)):h&&s===N.STEP?l.push(o.build(t,t.getTypeLength(o.getNodeType(t))===1?"float":r),a.build(t,r)):h&&(s===N.MIN||s===N.MAX)||s===N.MOD?l.push(o.build(t,r),a.build(t,t.getTypeLength(a.getNodeType(t))===1?"float":r)):s===N.REFRACT?l.push(o.build(t,r),a.build(t,r),c.build(t,"float")):s===N.MIX?l.push(o.build(t,r),a.build(t,r),c.build(t,t.getTypeLength(c.getNodeType(t))===1?"float":r)):(l.push(o.build(t,r)),a!==null&&l.push(a.build(t,r)),c!==null&&l.push(c.build(t,r))),t.format(`${t.getMethod(s,n)}( ${l.join(", ")} )`,n,e)}}}serialize(t){super.serialize(t),t.method=this.method}deserialize(t){super.deserialize(t),this.method=t.method}}N.ALL="all";N.ANY="any";N.EQUALS="equals";N.RADIANS="radians";N.DEGREES="degrees";N.EXP="exp";N.EXP2="exp2";N.LOG="log";N.LOG2="log2";N.SQRT="sqrt";N.INVERSE_SQRT="inversesqrt";N.FLOOR="floor";N.CEIL="ceil";N.NORMALIZE="normalize";N.FRACT="fract";N.SIN="sin";N.COS="cos";N.TAN="tan";N.ASIN="asin";N.ACOS="acos";N.ATAN="atan";N.ABS="abs";N.SIGN="sign";N.LENGTH="length";N.NEGATE="negate";N.ONE_MINUS="oneMinus";N.DFDX="dFdx";N.DFDY="dFdy";N.ROUND="round";N.RECIPROCAL="reciprocal";N.TRUNC="trunc";N.FWIDTH="fwidth";N.BITCAST="bitcast";N.TRANSPOSE="transpose";N.ATAN2="atan2";N.MIN="min";N.MAX="max";N.MOD="mod";N.STEP="step";N.REFLECT="reflect";N.DISTANCE="distance";N.DIFFERENCE="difference";N.DOT="dot";N.CROSS="cross";N.POW="pow";N.TRANSFORM_DIRECTION="transformDirection";N.MIX="mix";N.CLAMP="clamp";N.REFRACT="refract";N.SMOOTHSTEP="smoothstep";N.FACEFORWARD="faceforward";const Pc=g(1e-6),Tp=g(1e6),Ti=g(Math.PI),vp=g(Math.PI*2),ao=_(N,N.ALL),Dc=_(N,N.ANY),kc=_(N,N.EQUALS),Uc=_(N,N.RADIANS),Wc=_(N,N.DEGREES),qc=_(N,N.EXP),Ws=_(N,N.EXP2),co=_(N,N.LOG),Ce=_(N,N.LOG2),Ne=_(N,N.SQRT),Gc=_(N,N.INVERSE_SQRT),me=_(N,N.FLOOR),Oi=_(N,N.CEIL),gs=_(N,N.NORMALIZE),Be=_(N,N.FRACT),qt=_(N,N.SIN),be=_(N,N.COS),Hc=_(N,N.TAN),jc=_(N,N.ASIN),Xc=_(N,N.ACOS),$c=_(N,N.ATAN),et=_(N,N.ABS),ho=_(N,N.SIGN),vi=_(N,N.LENGTH),Yc=_(N,N.NEGATE),Zc=_(N,N.ONE_MINUS),lo=_(N,N.DFDX),uo=_(N,N.DFDY),Jc=_(N,N.ROUND),Qc=_(N,N.RECIPROCAL),po=_(N,N.TRUNC),Kc=_(N,N.FWIDTH),wp=_(N,N.BITCAST),th=_(N,N.TRANSPOSE),eh=_(N,N.ATAN2),Ht=_(N,N.MIN),Mt=_(N,N.MAX),mo=_(N,N.MOD),Li=_(N,N.STEP),sh=_(N,N.REFLECT),nh=_(N,N.DISTANCE),ih=_(N,N.DIFFERENCE),Je=_(N,N.DOT),Bi=_(N,N.CROSS),he=_(N,N.POW),rh=_(N,N.POW,2),oh=_(N,N.POW,3),ah=_(N,N.POW,4),ch=_(N,N.TRANSFORM_DIRECTION),hh=i=>k(ho(i),he(et(i),1/3)),lh=i=>Je(i,i),at=_(N,N.MIX),Fe=(i,t=0,e=1)=>V(new N(N.CLAMP,V(i),V(t),V(e))),uh=i=>Fe(i),dh=_(N,N.REFRACT),qs=_(N,N.SMOOTHSTEP),ph=_(N,N.FACEFORWARD),mh=w(([i])=>{const s=43758.5453,n=Je(i.xy,z(12.9898,78.233)),r=mo(n,Ti);return Be(qt(r).mul(s))}),fh=(i,t,e)=>at(t,e,i),gh=(i,t,e)=>qs(t,e,i);b("all",ao);b("any",Dc);b("equals",kc);b("radians",Uc);b("degrees",Wc);b("exp",qc);b("exp2",Ws);b("log",co);b("log2",Ce);b("sqrt",Ne);b("inverseSqrt",Gc);b("floor",me);b("ceil",Oi);b("normalize",gs);b("fract",Be);b("sin",qt);b("cos",be);b("tan",Hc);b("asin",jc);b("acos",Xc);b("atan",$c);b("abs",et);b("sign",ho);b("length",vi);b("lengthSq",lh);b("negate",Yc);b("oneMinus",Zc);b("dFdx",lo);b("dFdy",uo);b("round",Jc);b("reciprocal",Qc);b("trunc",po);b("fwidth",Kc);b("atan2",eh);b("min",Ht);b("max",Mt);b("mod",mo);b("step",Li);b("reflect",sh);b("distance",nh);b("dot",Je);b("cross",Bi);b("pow",he);b("pow2",rh);b("pow3",oh);b("pow4",ah);b("transformDirection",ch);b("mix",fh);b("clamp",Fe);b("refract",dh);b("smoothstep",gh);b("faceForward",ph);b("difference",ih);b("saturate",uh);b("cbrt",hh);b("transpose",th);b("rand",mh);class Mp extends L{static get type(){return"ConditionalNode"}constructor(t,e,s=null){super(),this.condNode=t,this.ifNode=e,this.elseNode=s}getNodeType(t){const e=this.ifNode.getNodeType(t);if(this.elseNode!==null){const s=this.elseNode.getNodeType(t);if(t.getTypeLength(s)>t.getTypeLength(e))return s}return e}setup(t){const e=this.condNode.cache(),s=this.ifNode.cache(),n=this.elseNode?this.elseNode.cache():null,r=t.context.nodeBlock;t.getDataFromNode(s).parentNodeBlock=r,n!==null&&(t.getDataFromNode(n).parentNodeBlock=r);const o=t.getNodeProperties(this);o.condNode=e,o.ifNode=s.context({nodeBlock:s}),o.elseNode=n?n.context({nodeBlock:n}):null}generate(t,e){const s=this.getNodeType(t),n=t.getDataFromNode(this);if(n.nodeProperty!==void 0)return n.nodeProperty;const{condNode:r,ifNode:o,elseNode:a}=t.getNodeProperties(this),c=e!=="void",h=c?fc(s).build(t):"";n.nodeProperty=h;const l=r.build(t,"bool");t.addFlowCode(`
${t.tab}if ( ${l} ) {

`).addFlowTab();let d=o.build(t,s);if(d&&(c?d=h+" = "+d+";":d="return "+d+";"),t.removeFlowTab().addFlowCode(t.tab+"	"+d+`

`+t.tab+"}"),a!==null){t.addFlowCode(` else {

`).addFlowTab();let p=a.build(t,s);p&&(c?p=h+" = "+p+";":p="return "+p+";"),t.removeFlowTab().addFlowCode(t.tab+"	"+p+`

`+t.tab+`}

`)}else t.addFlowCode(`

`);return t.format(h,s,e)}}const Ot=_(Mp);b("select",Ot);const yh=(...i)=>(console.warn("TSL.ConditionalNode: cond() has been renamed to select()."),Ot(...i));b("cond",yh);class xh extends L{static get type(){return"ContextNode"}constructor(t,e={}){super(),this.isContextNode=!0,this.node=t,this.value=e}getScope(){return this.node.getScope()}getNodeType(t){return this.node.getNodeType(t)}analyze(t){this.node.build(t)}setup(t){const e=t.getContext();t.setContext({...t.context,...this.value});const s=this.node.build(t);return t.setContext(e),s}generate(t,e){const s=t.getContext();t.setContext({...t.context,...this.value});const n=this.node.build(t,e);return t.setContext(s),n}}const fo=_(xh),Nh=(i,t)=>fo(i,{label:t});b("context",fo);b("label",Nh);class _p extends L{static get type(){return"VarNode"}constructor(t,e=null){super(),this.node=t,this.name=e,this.global=!0,this.isVarNode=!0}getHash(t){return this.name||super.getHash(t)}getNodeType(t){return this.node.getNodeType(t)}generate(t){const{node:e,name:s}=this,n=t.getVarFromNode(this,s,t.getVectorType(this.getNodeType(t))),r=t.getPropertyName(n),o=e.build(t,n.type);return t.addLineFlowCode(`${r} = ${o}`,this),r}}const Th=_(_p);b("toVar",(...i)=>Th(...i).append());const vh=i=>(console.warn('TSL: "temp" is deprecated. Use ".toVar()" instead.'),Th(i));b("temp",vh);class bp extends L{static get type(){return"VaryingNode"}constructor(t,e=null){super(),this.node=t,this.name=e,this.isVaryingNode=!0}isGlobal(){return!0}getHash(t){return this.name||super.getHash(t)}getNodeType(t){return this.node.getNodeType(t)}setupVarying(t){const e=t.getNodeProperties(this);let s=e.varying;if(s===void 0){const n=this.name,r=this.getNodeType(t);e.varying=s=t.getVaryingFromNode(this,n,r),e.node=this.node}return s.needsInterpolation||(s.needsInterpolation=t.shaderStage==="fragment"),s}setup(t){this.setupVarying(t)}analyze(t){return this.setupVarying(t),this.node.analyze(t)}generate(t){const e=t.getNodeProperties(this),s=this.setupVarying(t);if(e.propertyName===void 0){const n=this.getNodeType(t),r=t.getPropertyName(s,Ir.VERTEX);t.flowNodeFromShaderStage(Ir.VERTEX,this.node,n,r),e.propertyName=r}return t.getPropertyName(s)}}const jt=_(bp);b("varying",jt);const wh=w(([i])=>{const t=i.mul(.9478672986).add(.0521327014).pow(2.4),e=i.mul(.0773993808),s=i.lessThanEqual(.04045);return at(t,e,s)}).setLayout({name:"sRGBTransferEOTF",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),Mh=w(([i])=>{const t=i.pow(.41666).mul(1.055).sub(.055),e=i.mul(12.92),s=i.lessThanEqual(.0031308);return at(t,e,s)}).setLayout({name:"sRGBTransferOETF",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),wn="WorkingColorSpace",go="OutputColorSpace";class Mn extends pt{static get type(){return"ColorSpaceNode"}constructor(t,e,s){super("vec4"),this.colorNode=t,this.source=e,this.target=s}resolveColorSpace(t,e){return e===wn?ht.workingColorSpace:e===go?t.context.outputColorSpace||t.renderer.outputColorSpace:e}setup(t){const{colorNode:e}=this,s=this.resolveColorSpace(t,this.source),n=this.resolveColorSpace(t,this.target);let r=e;return ht.enabled===!1||s===n||!s||!n||(ht.getTransfer(s)===cn&&(r=D(wh(r.rgb),r.a)),ht.getPrimaries(s)!==ht.getPrimaries(n)&&(r=D(Kt(ht._getMatrix(new te,s,n)).mul(r.rgb),r.a)),ht.getTransfer(n)===cn&&(r=D(Mh(r.rgb),r.a))),r}}const _h=i=>V(new Mn(V(i),wn,go)),bh=i=>V(new Mn(V(i),go,wn)),Sh=(i,t)=>V(new Mn(V(i),wn,t)),yo=(i,t)=>V(new Mn(V(i),t,wn)),Sp=(i,t,e)=>V(new Mn(V(i),t,e));b("toOutputColorSpace",_h);b("toWorkingColorSpace",bh);b("workingToColorSpace",Sh);b("colorSpaceToWorking",yo);let Ap=class extends fs{static get type(){return"ReferenceElementNode"}constructor(t,e){super(t,e),this.referenceNode=t,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(t){const e=super.generate(t),s=this.referenceNode.getNodeType(),n=this.getNodeType();return t.format(e,s,n)}};class Vp extends L{static get type(){return"ReferenceBaseNode"}constructor(t,e,s=null,n=null){super(),this.property=t,this.uniformType=e,this.object=s,this.count=n,this.properties=t.split("."),this.reference=s,this.node=null,this.group=null,this.updateType=$.OBJECT}setGroup(t){return this.group=t,this}element(t){return V(new Ap(this,V(t)))}setNodeType(t){const e=W(null,t).getSelf();this.group!==null&&e.setGroup(this.group),this.node=e}getNodeType(t){return this.node===null&&(this.updateReference(t),this.updateValue()),this.node.getNodeType(t)}getValueFromReference(t=this.reference){const{properties:e}=this;let s=t[e[0]];for(let n=1;n<e.length;n++)s=s[e[n]];return s}updateReference(t){return this.reference=this.object!==null?this.object:t.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){this.node===null&&this.setNodeType(this.uniformType);const t=this.getValueFromReference();Array.isArray(t)?this.node.array=t:this.node.value=t}}class zp extends Vp{static get type(){return"RendererReferenceNode"}constructor(t,e,s=null){super(t,e,s),this.renderer=s,this.setGroup(X)}updateReference(t){return this.reference=this.renderer!==null?this.renderer:t.renderer,this.reference}}const Ah=(i,t,e)=>V(new zp(i,t,e));class Cp extends pt{static get type(){return"ToneMappingNode"}constructor(t,e=zh,s=null){super("vec3"),this.toneMapping=t,this.exposureNode=e,this.colorNode=s}getCacheKey(){return Sd(super.getCacheKey(),this.toneMapping)}setup(t){const e=this.colorNode||t.context.color,s=this.toneMapping;if(s===Cr)return e;let n=null;const r=t.renderer.library.getToneMappingFunction(s);return r!==null?n=D(r(e.rgb,this.exposureNode),e.a):(console.error("ToneMappingNode: Unsupported Tone Mapping configuration.",s),n=e),n}}const Vh=(i,t,e)=>V(new Cp(i,V(t),V(e))),zh=Ah("toneMappingExposure","float");b("toneMapping",(i,t,e)=>Vh(t,e,i));class Rp extends Kr{static get type(){return"BufferAttributeNode"}constructor(t,e=null,s=0,n=0){super(t,e),this.isBufferNode=!0,this.bufferType=e,this.bufferStride=s,this.bufferOffset=n,this.usage=yi,this.instanced=!1,this.attribute=null,this.global=!0,t&&t.isBufferAttribute===!0&&(this.attribute=t,this.usage=t.usage,this.instanced=t.isInstancedBufferAttribute)}getHash(t){if(this.bufferStride===0&&this.bufferOffset===0){let e=t.globalCache.getData(this.value);return e===void 0&&(e={node:this},t.globalCache.setData(this.value,e)),e.node.uuid}return this.uuid}getNodeType(t){return this.bufferType===null&&(this.bufferType=t.getTypeFromAttribute(this.attribute)),this.bufferType}setup(t){if(this.attribute!==null)return;const e=this.getNodeType(t),s=this.value,n=t.getTypeLength(e),r=this.bufferStride||n,o=this.bufferOffset,a=s.isInterleavedBuffer===!0?s:new Wa(s,r),c=new Jr(a,n,o);a.setUsage(this.usage),this.attribute=c,this.attribute.isInstancedBufferAttribute=this.instanced}generate(t){const e=this.getNodeType(t),s=t.getBufferAttributeFromNode(this,e),n=t.getPropertyName(s);let r=null;return t.shaderStage==="vertex"||t.shaderStage==="compute"?(this.name=n,r=n):r=jt(this).build(t,e),r}getInputType(){return"bufferAttribute"}setUsage(t){return this.usage=t,this.attribute&&this.attribute.isBufferAttribute===!0&&(this.attribute.usage=t),this}setInstanced(t){return this.instanced=t,this}}const _n=(i,t,e,s)=>V(new Rp(i,t,e,s)),Ch=(i,t,e,s)=>_n(i,t,e,s).setUsage(an),wi=(i,t,e,s)=>_n(i,t,e,s).setInstanced(!0),kr=(i,t,e,s)=>Ch(i,t,e,s).setInstanced(!0);b("toAttribute",i=>_n(i.value));class Ep extends L{static get type(){return"ComputeNode"}constructor(t,e,s=[64]){super("void"),this.isComputeNode=!0,this.computeNode=t,this.count=e,this.workgroupSize=s,this.dispatchCount=0,this.version=1,this.updateBeforeType=$.OBJECT,this.onInitFunction=null,this.updateDispatchCount()}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}updateDispatchCount(){const{count:t,workgroupSize:e}=this;let s=e[0];for(let n=1;n<e.length;n++)s*=e[n];this.dispatchCount=Math.ceil(t/s)}onInit(t){return this.onInitFunction=t,this}updateBefore({renderer:t}){t.compute(this)}generate(t){const{shaderStage:e}=t;if(e==="compute"){const s=this.computeNode.build(t,"void");s!==""&&t.addLineFlowCode(s,this)}}}const Rh=(i,t,e)=>V(new Ep(V(i),t,e));b("compute",Rh);class Fp extends L{static get type(){return"CacheNode"}constructor(t,e=!0){super(),this.node=t,this.parent=e,this.isCacheNode=!0}getNodeType(t){return this.node.getNodeType(t)}build(t,...e){const s=t.getCache(),n=t.getCacheFromNode(this,this.parent);t.setCache(n);const r=this.node.build(t,...e);return t.setCache(s),r}}const Eh=(i,...t)=>V(new Fp(V(i),...t));b("cache",Eh);class Ip extends L{static get type(){return"BypassNode"}constructor(t,e){super(),this.isBypassNode=!0,this.outputNode=t,this.callNode=e}getNodeType(t){return this.outputNode.getNodeType(t)}generate(t){const e=this.callNode.build(t,"void");return e!==""&&t.addLineFlowCode(e,this),this.outputNode.build(t)}}const Fh=_(Ip);b("bypass",Fh);class Ih extends L{static get type(){return"RemapNode"}constructor(t,e,s,n=g(0),r=g(1)){super(),this.node=t,this.inLowNode=e,this.inHighNode=s,this.outLowNode=n,this.outHighNode=r,this.doClamp=!0}setup(){const{node:t,inLowNode:e,inHighNode:s,outLowNode:n,outHighNode:r,doClamp:o}=this;let a=t.sub(e).div(s.sub(e));return o===!0&&(a=a.clamp()),a.mul(r.sub(n)).add(n)}}const Oh=_(Ih,null,null,{doClamp:!1}),Lh=_(Ih);b("remap",Oh);b("remapClamp",Lh);class Op extends L{static get type(){return"ExpressionNode"}constructor(t="",e="void"){super(e),this.snippet=t}generate(t,e){const s=this.getNodeType(t),n=this.snippet;if(s==="void")t.addLineFlowCode(n,this);else return t.format(`( ${n} )`,s,e)}}const Ze=_(Op),Bh=i=>(i?Ot(i,Ze("discard")):Ze("discard")).append(),Lp=()=>Ze("return").append();b("discard",Bh);class Bp extends pt{static get type(){return"RenderOutputNode"}constructor(t,e,s){super("vec4"),this.colorNode=t,this.toneMapping=e,this.outputColorSpace=s,this.isRenderOutput=!0}setup({context:t}){let e=this.colorNode||t.color;const s=(this.toneMapping!==null?this.toneMapping:t.toneMapping)||Cr,n=(this.outputColorSpace!==null?this.outputColorSpace:t.outputColorSpace)||gi;return s!==Cr&&(e=e.toneMapping(s)),n!==gi&&n!==ht.workingColorSpace&&(e=e.workingToColorSpace(n)),e}}const Ph=(i,t=null,e=null)=>V(new Bp(V(i),t,e));b("renderOutput",Ph);function Pp(i){console.warn("THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add",i)}class Dh extends L{static get type(){return"AttributeNode"}constructor(t,e=null){super(e),this.global=!0,this._attributeName=t}getHash(t){return this.getAttributeName(t)}getNodeType(t){let e=this.nodeType;if(e===null){const s=this.getAttributeName(t);if(t.hasGeometryAttribute(s)){const n=t.geometry.getAttribute(s);e=t.getTypeFromAttribute(n)}else e="float"}return e}setAttributeName(t){return this._attributeName=t,this}getAttributeName(){return this._attributeName}generate(t){const e=this.getAttributeName(t),s=this.getNodeType(t);if(t.hasGeometryAttribute(e)===!0){const r=t.geometry.getAttribute(e),o=t.getTypeFromAttribute(r),a=t.getAttribute(e,o);return t.shaderStage==="vertex"?t.format(a.name,o,s):jt(this).build(t,s)}else return console.warn(`AttributeNode: Vertex attribute "${e}" not found on geometry.`),t.generateConst(s)}serialize(t){super.serialize(t),t.global=this.global,t._attributeName=this._attributeName}deserialize(t){super.deserialize(t),this.global=t.global,this._attributeName=t._attributeName}}const Ie=(i,t)=>V(new Dh(i,t)),rt=i=>Ie("uv"+(i>0?i:""),"vec2");class Dp extends L{static get type(){return"TextureSizeNode"}constructor(t,e=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=t,this.levelNode=e}generate(t,e){const s=this.textureNode.build(t,"property"),n=this.levelNode===null?"0":this.levelNode.build(t,"int");return t.format(`${t.getMethod("textureDimensions")}( ${s}, ${n} )`,this.getNodeType(t),e)}}const us=_(Dp);class kp extends vn{static get type(){return"MaxMipLevelNode"}constructor(t){super(0),this._textureNode=t,this.updateType=$.FRAME}get textureNode(){return this._textureNode}get texture(){return this._textureNode.value}update(){const t=this.texture,e=t.images,s=e&&e.length>0?e[0]&&e[0].image||e[0]:t.image;if(s&&s.width!==void 0){const{width:n,height:r}=s;this.value=Math.log2(Math.max(n,r))}}}const kh=_(kp);class Oe extends vn{static get type(){return"TextureNode"}constructor(t,e=null,s=null,n=null){super(t),this.isTextureNode=!0,this.uvNode=e,this.levelNode=s,this.biasNode=n,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=$.NONE,this.referenceNode=null,this._value=t,this._matrixUniform=null,this.setUpdateMatrix(e===null)}set value(t){this.referenceNode?this.referenceNode.value=t:this._value=t}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return this.value.isDepthTexture===!0?"float":this.value.type===Fa?"uvec4":this.value.type===Au?"ivec4":"vec4"}getInputType(){return"texture"}getDefaultUV(){return rt(this.value.channel)}updateReference(){return this.value}getTransformedUV(t){return this._matrixUniform===null&&(this._matrixUniform=W(this.value.matrix)),this._matrixUniform.mul(T(t,1)).xy}setUpdateMatrix(t){return this.updateMatrix=t,this.updateType=t?$.FRAME:$.NONE,this}setupUV(t,e){const s=this.value;return t.isFlipY()&&(s.image instanceof ImageBitmap&&s.flipY===!0||s.isRenderTargetTexture===!0||s.isFramebufferTexture===!0||s.isDepthTexture===!0)&&(this.sampler?e=e.flipY():e=e.setY(y(us(this,this.levelNode).y).sub(e.y).sub(1))),e}setup(t){const e=t.getNodeProperties(this);e.referenceNode=this.referenceNode;let s=this.uvNode;(s===null||t.context.forceUVContext===!0)&&t.context.getUV&&(s=t.context.getUV(this)),s||(s=this.getDefaultUV()),this.updateMatrix===!0&&(s=this.getTransformedUV(s)),s=this.setupUV(t,s);let n=this.levelNode;n===null&&t.context.getTextureLevel&&(n=t.context.getTextureLevel(this)),e.uvNode=s,e.levelNode=n,e.biasNode=this.biasNode,e.compareNode=this.compareNode,e.gradNode=this.gradNode,e.depthNode=this.depthNode}generateUV(t,e){return e.build(t,this.sampler===!0?"vec2":"ivec2")}generateSnippet(t,e,s,n,r,o,a,c){const h=this.value;let l;return n?l=t.generateTextureLevel(h,e,s,n,o):r?l=t.generateTextureBias(h,e,s,r,o):c?l=t.generateTextureGrad(h,e,s,c,o):a?l=t.generateTextureCompare(h,e,s,a,o):this.sampler===!1?l=t.generateTextureLoad(h,e,s,o):l=t.generateTexture(h,e,s,o),l}generate(t,e){const s=t.getNodeProperties(this),n=this.value;if(!n||n.isTexture!==!0)throw new Error("TextureNode: Need a three.js texture.");const r=super.generate(t,"property");if(e==="sampler")return r+"_sampler";if(t.isReference(e))return r;{const o=t.getDataFromNode(this);let a=o.propertyName;if(a===void 0){const{uvNode:l,levelNode:d,biasNode:p,compareNode:m,depthNode:f,gradNode:x}=s,v=this.generateUV(t,l),A=d?d.build(t,"float"):null,F=p?p.build(t,"float"):null,O=f?f.build(t,"int"):null,E=m?m.build(t,"float"):null,B=x?[x[0].build(t,"vec2"),x[1].build(t,"vec2")]:null,P=t.getVarFromNode(this);a=t.getPropertyName(P);const I=this.generateSnippet(t,r,v,A,F,O,E,B);t.addLineFlowCode(`${a} = ${I}`,this),o.snippet=I,o.propertyName=a}let c=a;const h=this.getNodeType(t);return t.needsToWorkingColorSpace(n)&&(c=yo(Ze(c,h),n.colorSpace).setup(t).build(t,h)),t.format(c,h,e)}}setSampler(t){return this.sampler=t,this}getSampler(){return this.sampler}uv(t){const e=this.clone();return e.uvNode=V(t),e.referenceNode=this.getSelf(),V(e)}blur(t){const e=this.clone();return e.biasNode=V(t).mul(kh(e)),e.referenceNode=this.getSelf(),V(e)}level(t){const e=this.clone();return e.levelNode=V(t),e.referenceNode=this.getSelf(),V(e)}size(t){return us(this,t)}bias(t){const e=this.clone();return e.biasNode=V(t),e.referenceNode=this.getSelf(),V(e)}compare(t){const e=this.clone();return e.compareNode=V(t),e.referenceNode=this.getSelf(),V(e)}grad(t,e){const s=this.clone();return s.gradNode=[V(t),V(e)],s.referenceNode=this.getSelf(),V(s)}depth(t){const e=this.clone();return e.depthNode=V(t),e.referenceNode=this.getSelf(),V(e)}serialize(t){super.serialize(t),t.value=this.value.toJSON(t.meta).uuid,t.sampler=this.sampler,t.updateMatrix=this.updateMatrix,t.updateType=this.updateType}deserialize(t){super.deserialize(t),this.value=t.meta.textures[t.value],this.sampler=t.sampler,this.updateMatrix=t.updateMatrix,this.updateType=t.updateType}update(){const t=this.value,e=this._matrixUniform;e!==null&&(e.value=t.matrix),t.matrixAutoUpdate===!0&&t.updateMatrix()}clone(){const t=new this.constructor(this.value,this.uvNode,this.levelNode,this.biasNode);return t.sampler=this.sampler,t}}const Ft=_(Oe),ot=(...i)=>Ft(...i).setSampler(!1),Up=i=>(i.isNode===!0?i:Ft(i)).convert("sampler"),je=W("float").label("cameraNear").setGroup(X).onRenderUpdate(({camera:i})=>i.near),Xe=W("float").label("cameraFar").setGroup(X).onRenderUpdate(({camera:i})=>i.far),bn=W("mat4").label("cameraProjectionMatrix").setGroup(X).onRenderUpdate(({camera:i})=>i.projectionMatrix),Wp=W("mat4").label("cameraProjectionMatrixInverse").setGroup(X).onRenderUpdate(({camera:i})=>i.projectionMatrixInverse),ee=W("mat4").label("cameraViewMatrix").setGroup(X).onRenderUpdate(({camera:i})=>i.matrixWorldInverse),qp=W("mat4").label("cameraWorldMatrix").setGroup(X).onRenderUpdate(({camera:i})=>i.matrixWorld),Gp=W("mat3").label("cameraNormalMatrix").setGroup(X).onRenderUpdate(({camera:i})=>i.normalMatrix),Hp=W(new S).label("cameraPosition").setGroup(X).onRenderUpdate(({camera:i},t)=>t.value.setFromMatrixPosition(i.matrixWorld));class j extends L{static get type(){return"Object3DNode"}constructor(t,e=null){super(),this.scope=t,this.object3d=e,this.updateType=$.OBJECT,this._uniformNode=new vn(null)}getNodeType(){const t=this.scope;if(t===j.WORLD_MATRIX)return"mat4";if(t===j.POSITION||t===j.VIEW_POSITION||t===j.DIRECTION||t===j.SCALE)return"vec3"}update(t){const e=this.object3d,s=this._uniformNode,n=this.scope;if(n===j.WORLD_MATRIX)s.value=e.matrixWorld;else if(n===j.POSITION)s.value=s.value||new S,s.value.setFromMatrixPosition(e.matrixWorld);else if(n===j.SCALE)s.value=s.value||new S,s.value.setFromMatrixScale(e.matrixWorld);else if(n===j.DIRECTION)s.value=s.value||new S,e.getWorldDirection(s.value);else if(n===j.VIEW_POSITION){const r=t.camera;s.value=s.value||new S,s.value.setFromMatrixPosition(e.matrixWorld),s.value.applyMatrix4(r.matrixWorldInverse)}}generate(t){const e=this.scope;return e===j.WORLD_MATRIX?this._uniformNode.nodeType="mat4":(e===j.POSITION||e===j.VIEW_POSITION||e===j.DIRECTION||e===j.SCALE)&&(this._uniformNode.nodeType="vec3"),this._uniformNode.build(t)}serialize(t){super.serialize(t),t.scope=this.scope}deserialize(t){super.deserialize(t),this.scope=t.scope}}j.WORLD_MATRIX="worldMatrix";j.POSITION="position";j.SCALE="scale";j.VIEW_POSITION="viewPosition";j.DIRECTION="direction";const jp=_(j,j.DIRECTION),Xp=_(j,j.WORLD_MATRIX),Uh=_(j,j.POSITION),$p=_(j,j.SCALE),Yp=_(j,j.VIEW_POSITION);class ge extends j{static get type(){return"ModelNode"}constructor(t){super(t)}update(t){this.object3d=t.object,super.update(t)}}const Zp=C(ge,ge.DIRECTION),Se=C(ge,ge.WORLD_MATRIX),Jp=C(ge,ge.POSITION),Qp=C(ge,ge.SCALE),Kp=C(ge,ge.VIEW_POSITION),Wh=W(new te).onObjectUpdate(({object:i},t)=>t.value.getNormalMatrix(i.matrixWorld)),tm=W(new tt).onObjectUpdate(({object:i},t)=>t.value.copy(i.matrixWorld).invert()),js=ee.mul(Se).toVar("modelViewMatrix"),em=w(i=>(i.context.isHighPrecisionModelViewMatrix=!0,W("mat4").onObjectUpdate(({object:t,camera:e})=>t.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse,t.matrixWorld)))).once()().toVar("highPrecisionModelViewMatrix"),sm=w(i=>{const t=i.context.isHighPrecisionModelViewMatrix;return W("mat3").onObjectUpdate(({object:e,camera:s})=>(t!==!0&&e.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse,e.matrixWorld),e.normalMatrix.getNormalMatrix(e.modelViewMatrix)))}).once()().toVar("highPrecisionModelNormalMatrix"),xo=Ie("position","vec3"),ct=xo.varying("positionLocal"),Mi=xo.varying("positionPrevious"),ds=Se.mul(ct).xyz.varying("v_positionWorld"),qh=ct.transformDirection(Se).varying("v_positionWorldDirection").normalize().toVar("positionWorldDirection"),wt=js.mul(ct).xyz.varying("v_positionView"),Gt=wt.negate().varying("v_positionViewDirection").normalize().toVar("positionViewDirection");class nm extends L{static get type(){return"FrontFacingNode"}constructor(){super("bool"),this.isFrontFacingNode=!0}generate(t){const{renderer:e,material:s}=t;return e.coordinateSystem===cs&&s.side===$r?"false":t.getFrontFacing()}}const Gh=C(nm),Sn=g(Gh).mul(2).sub(1),No=Ie("normal","vec3"),Pt=w(i=>i.geometry.hasAttribute("normal")===!1?(console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.'),T(0,1,0)):No,"vec3").once()().toVar("normalLocal"),Hh=wt.dFdx().cross(wt.dFdy()).normalize().toVar("normalFlat"),ye=w(i=>{let t;return i.material.flatShading===!0?t=Hh:t=jt(To(Pt),"v_normalView").normalize(),t},"vec3").once()().toVar("normalView"),jh=jt(ye.transformDirection(ee),"v_normalWorld").normalize().toVar("normalWorld"),Le=w(i=>i.context.setupNormal(),"vec3").once()().mul(Sn).toVar("transformedNormalView"),Xh=Le.transformDirection(ee).toVar("transformedNormalWorld"),im=w(i=>i.context.setupClearcoatNormal(),"vec3").once()().mul(Sn).toVar("transformedClearcoatNormalView"),$h=w(([i,t=Se])=>{const e=Kt(t),s=i.div(T(e[0].dot(e[0]),e[1].dot(e[1]),e[2].dot(e[2])));return e.mul(s).xyz}),To=w(([i],t)=>{const e=t.renderer.nodes.modelNormalViewMatrix;if(e!==null)return e.transformDirection(i);const s=Wh.mul(i);return ee.transformDirection(s)}),Yh=W(0).onReference(({material:i})=>i).onRenderUpdate(({material:i})=>i.refractionRatio),Zh=Gt.negate().reflect(Le),Jh=Gt.negate().refract(Le,Yh),Qh=Zh.transformDirection(ee).toVar("reflectVector"),Kh=Jh.transformDirection(ee).toVar("reflectVector");class rm extends Oe{static get type(){return"CubeTextureNode"}constructor(t,e=null,s=null,n=null){super(t,e,s,n),this.isCubeTextureNode=!0}getInputType(){return"cubeTexture"}getDefaultUV(){const t=this.value;return t.mapping===Mu?Qh:t.mapping===_u?Kh:(console.error('THREE.CubeTextureNode: Mapping "%s" not supported.',t.mapping),T(0,0,0))}setUpdateMatrix(){}setupUV(t,e){const s=this.value;return t.renderer.coordinateSystem===ks||!s.isRenderTargetTexture?T(e.x.negate(),e.yz):e}generateUV(t,e){return e.build(t,"vec3")}}const tl=_(rm);class vo extends vn{static get type(){return"BufferNode"}constructor(t,e,s=0){super(t,e),this.isBufferNode=!0,this.bufferType=e,this.bufferCount=s}getElementType(t){return this.getNodeType(t)}getInputType(){return"buffer"}}const An=(i,t,e)=>V(new vo(i,t,e));class om extends fs{static get type(){return"UniformArrayElementNode"}constructor(t,e){super(t,e),this.isArrayBufferElementNode=!0}generate(t){const e=super.generate(t),s=this.getNodeType();return t.format(e,"vec4",s)}}class el extends vo{static get type(){return"UniformArrayNode"}constructor(t,e=null){super(null,"vec4"),this.array=t,this.elementType=e,this._elementType=null,this._elementLength=0,this.updateType=$.RENDER,this.isArrayBufferNode=!0}getElementType(){return this.elementType||this._elementType}getElementLength(){return this._elementLength}update(){const{array:t,value:e}=this,s=this.getElementLength(),n=this.getElementType();if(s===1)for(let r=0;r<t.length;r++){const o=r*4;e[o]=t[r]}else if(n==="color")for(let r=0;r<t.length;r++){const o=r*4,a=t[r];e[o]=a.r,e[o+1]=a.g,e[o+2]=a.b||0}else for(let r=0;r<t.length;r++){const o=r*4,a=t[r];e[o]=a.x,e[o+1]=a.y,e[o+2]=a.z||0,e[o+3]=a.w||0}}setup(t){const e=this.array.length;this._elementType=this.elementType===null?$e(this.array[0]):this.elementType,this._elementLength=t.getTypeLength(this._elementType);let s=Float32Array;return this._elementType.charAt(0)==="i"?s=Int32Array:this._elementType.charAt(0)==="u"&&(s=Uint32Array),this.value=new s(e*4),this.bufferCount=e,this.bufferType=t.changeComponentType("vec4",t.getComponentType(this._elementType)),super.setup(t)}element(t){return V(new om(this,V(t)))}}const os=(i,t)=>V(new el(i,t)),am=(i,t)=>(console.warn("TSL.UniformArrayNode: uniforms() has been renamed to uniformArray()."),V(new el(i,t)));class cm extends fs{static get type(){return"ReferenceElementNode"}constructor(t,e){super(t,e),this.referenceNode=t,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(t){const e=super.generate(t),s=this.referenceNode.getNodeType(),n=this.getNodeType();return t.format(e,s,n)}}class Pi extends L{static get type(){return"ReferenceNode"}constructor(t,e,s=null,n=null){super(),this.property=t,this.uniformType=e,this.object=s,this.count=n,this.properties=t.split("."),this.reference=s,this.node=null,this.group=null,this.name=null,this.updateType=$.OBJECT}element(t){return V(new cm(this,V(t)))}setGroup(t){return this.group=t,this}label(t){return this.name=t,this}setNodeType(t){let e=null;this.count!==null?e=An(null,t,this.count):Array.isArray(this.getValueFromReference())?e=os(null,t):t==="texture"?e=Ft(null):t==="cubeTexture"?e=tl(null):e=W(null,t),this.group!==null&&e.setGroup(this.group),this.name!==null&&e.label(this.name),this.node=e.getSelf()}getNodeType(t){return this.node===null&&(this.updateReference(t),this.updateValue()),this.node.getNodeType(t)}getValueFromReference(t=this.reference){const{properties:e}=this;let s=t[e[0]];for(let n=1;n<e.length;n++)s=s[e[n]];return s}updateReference(t){return this.reference=this.object!==null?this.object:t.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){this.node===null&&this.setNodeType(this.uniformType);const t=this.getValueFromReference();Array.isArray(t)?this.node.array=t:this.node.value=t}}const lt=(i,t,e)=>V(new Pi(i,t,e)),Ur=(i,t,e,s)=>V(new Pi(i,t,s,e));class hm extends Pi{static get type(){return"MaterialReferenceNode"}constructor(t,e,s=null){super(t,e,s),this.material=s,this.isMaterialReferenceNode=!0}updateReference(t){return this.reference=this.material!==null?this.material:t.material,this.reference}}const as=(i,t,e)=>V(new hm(i,t,e)),Di=w(i=>(i.geometry.hasAttribute("tangent")===!1&&i.geometry.computeTangents(),Ie("tangent","vec4")))(),Vn=Di.xyz.toVar("tangentLocal"),zn=js.mul(D(Vn,0)).xyz.varying("v_tangentView").normalize().toVar("tangentView"),sl=zn.transformDirection(ee).varying("v_tangentWorld").normalize().toVar("tangentWorld"),wo=zn.toVar("transformedTangentView"),lm=wo.transformDirection(ee).normalize().toVar("transformedTangentWorld"),Cn=i=>i.mul(Di.w).xyz,um=jt(Cn(No.cross(Di)),"v_bitangentGeometry").normalize().toVar("bitangentGeometry"),dm=jt(Cn(Pt.cross(Vn)),"v_bitangentLocal").normalize().toVar("bitangentLocal"),nl=jt(Cn(ye.cross(zn)),"v_bitangentView").normalize().toVar("bitangentView"),pm=jt(Cn(jh.cross(sl)),"v_bitangentWorld").normalize().toVar("bitangentWorld"),il=Cn(Le.cross(wo)).normalize().toVar("transformedBitangentView"),mm=il.transformDirection(ee).normalize().toVar("transformedBitangentWorld"),Mo=Kt(zn,nl,ye),rl=Gt.mul(Mo),fm=(i,t)=>i.sub(rl.mul(t)),gm=(()=>{let i=Bs.cross(Gt);return i=i.cross(Bs).normalize(),i=at(i,Le,xc.mul(gc.oneMinus()).oneMinus().pow2().pow2()).normalize(),i})(),ym=w(i=>{const{eye_pos:t,surf_norm:e,mapN:s,uv:n}=i,r=t.dFdx(),o=t.dFdy(),a=n.dFdx(),c=n.dFdy(),h=e,l=o.cross(h),d=h.cross(r),p=l.mul(a.x).add(d.mul(c.x)),m=l.mul(a.y).add(d.mul(c.y)),f=p.dot(p).max(m.dot(m)),x=Sn.mul(f.inverseSqrt());return dt(p.mul(s.x,x),m.mul(s.y,x),h.mul(s.z)).normalize()});class xm extends pt{static get type(){return"NormalMapNode"}constructor(t,e=null){super("vec3"),this.node=t,this.scaleNode=e,this.normalMapType=Rr}setup(t){const{normalMapType:e,scaleNode:s}=this;let n=this.node.mul(2).sub(1);s!==null&&(n=T(n.xy.mul(s),n.z));let r=null;return e===Cu?r=To(n):e===Rr&&(t.hasGeometryAttribute("tangent")===!0?r=Mo.mul(n).normalize():r=ym({eye_pos:wt,surf_norm:ye,mapN:n,uv:rt()})),r}}const Wr=_(xm),Nm=w(({textureNode:i,bumpScale:t})=>{const e=n=>i.cache().context({getUV:r=>n(r.uvNode||rt()),forceUVContext:!0}),s=g(e(n=>n));return z(g(e(n=>n.add(n.dFdx()))).sub(s),g(e(n=>n.add(n.dFdy()))).sub(s)).mul(t)}),Tm=w(i=>{const{surf_pos:t,surf_norm:e,dHdxy:s}=i,n=t.dFdx().normalize(),r=t.dFdy().normalize(),o=e,a=r.cross(o),c=o.cross(n),h=n.dot(a).mul(Sn),l=h.sign().mul(s.x.mul(a).add(s.y.mul(c)));return h.abs().mul(e).sub(l).normalize()});class vm extends pt{static get type(){return"BumpMapNode"}constructor(t,e=null){super("vec3"),this.textureNode=t,this.scaleNode=e}setup(){const t=this.scaleNode!==null?this.scaleNode:1,e=Nm({textureNode:this.textureNode,bumpScale:t});return Tm({surf_pos:wt,surf_norm:ye,dHdxy:e})}}const ol=_(vm),ua=new Map;class M extends L{static get type(){return"MaterialNode"}constructor(t){super(),this.scope=t}getCache(t,e){let s=ua.get(t);return s===void 0&&(s=as(t,e),ua.set(t,s)),s}getFloat(t){return this.getCache(t,"float")}getColor(t){return this.getCache(t,"color")}getTexture(t){return this.getCache(t==="map"?"map":t+"Map","texture")}setup(t){const e=t.context.material,s=this.scope;let n=null;if(s===M.COLOR){const r=e.color!==void 0?this.getColor(s):T();e.map&&e.map.isTexture===!0?n=r.mul(this.getTexture("map")):n=r}else if(s===M.OPACITY){const r=this.getFloat(s);e.alphaMap&&e.alphaMap.isTexture===!0?n=r.mul(this.getTexture("alpha")):n=r}else if(s===M.SPECULAR_STRENGTH)e.specularMap&&e.specularMap.isTexture===!0?n=this.getTexture("specular").r:n=g(1);else if(s===M.SPECULAR_INTENSITY){const r=this.getFloat(s);e.specularMap?n=r.mul(this.getTexture(s).a):n=r}else if(s===M.SPECULAR_COLOR){const r=this.getColor(s);e.specularColorMap&&e.specularColorMap.isTexture===!0?n=r.mul(this.getTexture(s).rgb):n=r}else if(s===M.ROUGHNESS){const r=this.getFloat(s);e.roughnessMap&&e.roughnessMap.isTexture===!0?n=r.mul(this.getTexture(s).g):n=r}else if(s===M.METALNESS){const r=this.getFloat(s);e.metalnessMap&&e.metalnessMap.isTexture===!0?n=r.mul(this.getTexture(s).b):n=r}else if(s===M.EMISSIVE){const r=this.getFloat("emissiveIntensity"),o=this.getColor(s).mul(r);e.emissiveMap&&e.emissiveMap.isTexture===!0?n=o.mul(this.getTexture(s)):n=o}else if(s===M.NORMAL)e.normalMap?(n=Wr(this.getTexture("normal"),this.getCache("normalScale","vec2")),n.normalMapType=e.normalMapType):e.bumpMap?n=ol(this.getTexture("bump").r,this.getFloat("bumpScale")):n=ye;else if(s===M.CLEARCOAT){const r=this.getFloat(s);e.clearcoatMap&&e.clearcoatMap.isTexture===!0?n=r.mul(this.getTexture(s).r):n=r}else if(s===M.CLEARCOAT_ROUGHNESS){const r=this.getFloat(s);e.clearcoatRoughnessMap&&e.clearcoatRoughnessMap.isTexture===!0?n=r.mul(this.getTexture(s).r):n=r}else if(s===M.CLEARCOAT_NORMAL)e.clearcoatNormalMap?n=Wr(this.getTexture(s),this.getCache(s+"Scale","vec2")):n=ye;else if(s===M.SHEEN){const r=this.getColor("sheenColor").mul(this.getFloat("sheen"));e.sheenColorMap&&e.sheenColorMap.isTexture===!0?n=r.mul(this.getTexture("sheenColor").rgb):n=r}else if(s===M.SHEEN_ROUGHNESS){const r=this.getFloat(s);e.sheenRoughnessMap&&e.sheenRoughnessMap.isTexture===!0?n=r.mul(this.getTexture(s).a):n=r,n=n.clamp(.07,1)}else if(s===M.ANISOTROPY)if(e.anisotropyMap&&e.anisotropyMap.isTexture===!0){const r=this.getTexture(s);n=Ii(Fs.x,Fs.y,Fs.y.negate(),Fs.x).mul(r.rg.mul(2).sub(z(1)).normalize().mul(r.b))}else n=Fs;else if(s===M.IRIDESCENCE_THICKNESS){const r=lt("1","float",e.iridescenceThicknessRange);if(e.iridescenceThicknessMap){const o=lt("0","float",e.iridescenceThicknessRange);n=r.sub(o).mul(this.getTexture(s).g).add(o)}else n=r}else if(s===M.TRANSMISSION){const r=this.getFloat(s);e.transmissionMap?n=r.mul(this.getTexture(s).r):n=r}else if(s===M.THICKNESS){const r=this.getFloat(s);e.thicknessMap?n=r.mul(this.getTexture(s).g):n=r}else if(s===M.IOR)n=this.getFloat(s);else if(s===M.LIGHT_MAP)n=this.getTexture(s).rgb.mul(this.getFloat("lightMapIntensity"));else if(s===M.AO_MAP)n=this.getTexture(s).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);else{const r=this.getNodeType(t);n=this.getCache(s,r)}return n}}M.ALPHA_TEST="alphaTest";M.COLOR="color";M.OPACITY="opacity";M.SHININESS="shininess";M.SPECULAR="specular";M.SPECULAR_STRENGTH="specularStrength";M.SPECULAR_INTENSITY="specularIntensity";M.SPECULAR_COLOR="specularColor";M.REFLECTIVITY="reflectivity";M.ROUGHNESS="roughness";M.METALNESS="metalness";M.NORMAL="normal";M.CLEARCOAT="clearcoat";M.CLEARCOAT_ROUGHNESS="clearcoatRoughness";M.CLEARCOAT_NORMAL="clearcoatNormal";M.EMISSIVE="emissive";M.ROTATION="rotation";M.SHEEN="sheen";M.SHEEN_ROUGHNESS="sheenRoughness";M.ANISOTROPY="anisotropy";M.IRIDESCENCE="iridescence";M.IRIDESCENCE_IOR="iridescenceIOR";M.IRIDESCENCE_THICKNESS="iridescenceThickness";M.IOR="ior";M.TRANSMISSION="transmission";M.THICKNESS="thickness";M.ATTENUATION_DISTANCE="attenuationDistance";M.ATTENUATION_COLOR="attenuationColor";M.LINE_SCALE="scale";M.LINE_DASH_SIZE="dashSize";M.LINE_GAP_SIZE="gapSize";M.LINE_WIDTH="linewidth";M.LINE_DASH_OFFSET="dashOffset";M.POINT_WIDTH="pointWidth";M.DISPERSION="dispersion";M.LIGHT_MAP="light";M.AO_MAP="ao";const al=C(M,M.ALPHA_TEST),cl=C(M,M.COLOR),wm=C(M,M.SHININESS),hl=C(M,M.EMISSIVE),ll=C(M,M.OPACITY),Mm=C(M,M.SPECULAR),_m=C(M,M.SPECULAR_INTENSITY),bm=C(M,M.SPECULAR_COLOR),Sm=C(M,M.SPECULAR_STRENGTH),Am=C(M,M.REFLECTIVITY),Vm=C(M,M.ROUGHNESS),zm=C(M,M.METALNESS),ul=C(M,M.NORMAL).context({getUV:null}),Cm=C(M,M.CLEARCOAT),Rm=C(M,M.CLEARCOAT_ROUGHNESS),Em=C(M,M.CLEARCOAT_NORMAL).context({getUV:null}),Fm=C(M,M.ROTATION),Im=C(M,M.SHEEN),Om=C(M,M.SHEEN_ROUGHNESS),Lm=C(M,M.ANISOTROPY),Bm=C(M,M.IRIDESCENCE),Pm=C(M,M.IRIDESCENCE_IOR),Dm=C(M,M.IRIDESCENCE_THICKNESS),km=C(M,M.TRANSMISSION),Um=C(M,M.THICKNESS),Wm=C(M,M.IOR),qm=C(M,M.ATTENUATION_DISTANCE),Gm=C(M,M.ATTENUATION_COLOR),Hm=C(M,M.LINE_SCALE),jm=C(M,M.LINE_DASH_SIZE),Xm=C(M,M.LINE_GAP_SIZE),$m=C(M,M.LINE_WIDTH),Ym=C(M,M.LINE_DASH_OFFSET),Zm=C(M,M.POINT_WIDTH),Jm=C(M,M.DISPERSION),dl=C(M,M.LIGHT_MAP),pl=C(M,M.AO_MAP),Fs=W(new gt).onReference(function(i){return i.material}).onRenderUpdate(function({material:i}){this.value.set(i.anisotropy*Math.cos(i.anisotropyRotation),i.anisotropy*Math.sin(i.anisotropyRotation))});class Qm extends pt{static get type(){return"ModelViewProjectionNode"}constructor(t=null){super("vec4"),this.positionNode=t}setup(t){if(t.shaderStage==="fragment")return jt(t.context.mvp);const e=this.positionNode||ct,s=t.renderer.nodes.modelViewMatrix||js;return bn.mul(s).mul(e)}}const ml=_(Qm);class st extends L{static get type(){return"IndexNode"}constructor(t){super("uint"),this.scope=t,this.isInstanceIndexNode=!0}generate(t){const e=this.getNodeType(t),s=this.scope;let n;if(s===st.VERTEX)n=t.getVertexIndex();else if(s===st.INSTANCE)n=t.getInstanceIndex();else if(s===st.DRAW)n=t.getDrawIndex();else if(s===st.INVOCATION_LOCAL)n=t.getInvocationLocalIndex();else if(s===st.INVOCATION_SUBGROUP)n=t.getInvocationSubgroupIndex();else if(s===st.SUBGROUP)n=t.getSubgroupIndex();else throw new Error("THREE.IndexNode: Unknown scope: "+s);let r;return t.shaderStage==="vertex"||t.shaderStage==="compute"?r=n:r=jt(this).build(t,e),r}}st.VERTEX="vertex";st.INSTANCE="instance";st.SUBGROUP="subgroup";st.INVOCATION_LOCAL="invocationLocal";st.INVOCATION_SUBGROUP="invocationSubgroup";st.DRAW="draw";const fl=C(st,st.VERTEX),Rn=C(st,st.INSTANCE),Km=C(st,st.SUBGROUP),tf=C(st,st.INVOCATION_SUBGROUP),ef=C(st,st.INVOCATION_LOCAL),gl=C(st,st.DRAW);class yl extends L{static get type(){return"InstanceNode"}constructor(t,e,s){super("void"),this.count=t,this.instanceMatrix=e,this.instanceColor=s,this.instanceMatrixNode=null,this.instanceColorNode=null,this.updateType=$.FRAME,this.buffer=null,this.bufferColor=null}setup(t){const{count:e,instanceMatrix:s,instanceColor:n}=this;let{instanceMatrixNode:r,instanceColorNode:o}=this;if(r===null){if(e<=1e3)r=An(s.array,"mat4",Math.max(e,1)).element(Rn);else{const c=new vd(s.array,16,1);this.buffer=c;const h=s.usage===an?kr:wi,l=[h(c,"vec4",16,0),h(c,"vec4",16,4),h(c,"vec4",16,8),h(c,"vec4",16,12)];r=ls(...l)}this.instanceMatrixNode=r}if(n&&o===null){const c=new Qr(n.array,3),h=n.usage===an?kr:wi;this.bufferColor=c,o=T(h(c,"vec3",3,0)),this.instanceColorNode=o}const a=r.mul(ct).xyz;if(ct.assign(a),t.hasGeometryAttribute("normal")){const c=$h(Pt,r);Pt.assign(c)}this.instanceColorNode!==null&&fn("vec3","vInstanceColor").assign(this.instanceColorNode)}update(){this.instanceMatrix.usage!==an&&this.buffer!=null&&this.instanceMatrix.version!==this.buffer.version&&(this.buffer.version=this.instanceMatrix.version),this.instanceColor&&this.instanceColor.usage!==an&&this.bufferColor!=null&&this.instanceColor.version!==this.bufferColor.version&&(this.bufferColor.version=this.instanceColor.version)}}const sf=_(yl);class nf extends yl{static get type(){return"InstancedMeshNode"}constructor(t){const{count:e,instanceMatrix:s,instanceColor:n}=t;super(e,s,n),this.instanceMesh=t}}const xl=_(nf);class rf extends L{static get type(){return"BatchNode"}constructor(t){super("void"),this.batchMesh=t,this.batchingIdNode=null}setup(t){this.batchingIdNode===null&&(t.getDrawIndex()===null?this.batchingIdNode=Rn:this.batchingIdNode=gl);const s=w(([f])=>{const x=us(ot(this.batchMesh._indirectTexture),0),v=y(f).modInt(y(x)),A=y(f).div(y(x));return ot(this.batchMesh._indirectTexture,Nt(v,A)).x}).setLayout({name:"getIndirectIndex",type:"uint",inputs:[{name:"id",type:"int"}]})(y(this.batchingIdNode)),n=this.batchMesh._matricesTexture,r=us(ot(n),0),o=g(s).mul(4).toInt().toVar(),a=o.modInt(r),c=o.div(y(r)),h=ls(ot(n,Nt(a,c)),ot(n,Nt(a.add(1),c)),ot(n,Nt(a.add(2),c)),ot(n,Nt(a.add(3),c))),l=this.batchMesh._colorsTexture;if(l!==null){const x=w(([v])=>{const A=us(ot(l),0).x,F=v,O=F.modInt(A),E=F.div(A);return ot(l,Nt(O,E)).rgb}).setLayout({name:"getBatchingColor",type:"vec3",inputs:[{name:"id",type:"int"}]})(s);fn("vec3","vBatchColor").assign(x)}const d=Kt(h);ct.assign(h.mul(ct));const p=Pt.div(T(d[0].dot(d[0]),d[1].dot(d[1]),d[2].dot(d[2]))),m=d.mul(p).xyz;Pt.assign(m),t.hasGeometryAttribute("tangent")&&Vn.mulAssign(d)}}const Nl=_(rf),da=new WeakMap;class Tl extends L{static get type(){return"SkinningNode"}constructor(t,e=!1){super("void"),this.skinnedMesh=t,this.useReference=e,this.updateType=$.OBJECT,this.skinIndexNode=Ie("skinIndex","uvec4"),this.skinWeightNode=Ie("skinWeight","vec4");let s,n,r;e?(s=lt("bindMatrix","mat4"),n=lt("bindMatrixInverse","mat4"),r=Ur("skeleton.boneMatrices","mat4",t.skeleton.bones.length)):(s=W(t.bindMatrix,"mat4"),n=W(t.bindMatrixInverse,"mat4"),r=An(t.skeleton.boneMatrices,"mat4",t.skeleton.bones.length)),this.bindMatrixNode=s,this.bindMatrixInverseNode=n,this.boneMatricesNode=r,this.previousBoneMatricesNode=null}getSkinnedPosition(t=this.boneMatricesNode,e=ct){const{skinIndexNode:s,skinWeightNode:n,bindMatrixNode:r,bindMatrixInverseNode:o}=this,a=t.element(s.x),c=t.element(s.y),h=t.element(s.z),l=t.element(s.w),d=r.mul(e),p=dt(a.mul(n.x).mul(d),c.mul(n.y).mul(d),h.mul(n.z).mul(d),l.mul(n.w).mul(d));return o.mul(p).xyz}getSkinnedNormal(t=this.boneMatricesNode,e=Pt){const{skinIndexNode:s,skinWeightNode:n,bindMatrixNode:r,bindMatrixInverseNode:o}=this,a=t.element(s.x),c=t.element(s.y),h=t.element(s.z),l=t.element(s.w);let d=dt(n.x.mul(a),n.y.mul(c),n.z.mul(h),n.w.mul(l));return d=o.mul(d).mul(r),d.transformDirection(e).xyz}getPreviousSkinnedPosition(t){const e=t.object;return this.previousBoneMatricesNode===null&&(e.skeleton.previousBoneMatrices=new Float32Array(e.skeleton.boneMatrices),this.previousBoneMatricesNode=Ur("skeleton.previousBoneMatrices","mat4",e.skeleton.bones.length)),this.getSkinnedPosition(this.previousBoneMatricesNode,Mi)}needsPreviousBoneMatrices(t){const e=t.renderer.getMRT();return e&&e.has("velocity")}setup(t){this.needsPreviousBoneMatrices(t)&&Mi.assign(this.getPreviousSkinnedPosition(t));const e=this.getSkinnedPosition();if(ct.assign(e),t.hasGeometryAttribute("normal")){const s=this.getSkinnedNormal();Pt.assign(s),t.hasGeometryAttribute("tangent")&&Vn.assign(s)}}generate(t,e){if(e!=="void")return ct.build(t,e)}update(t){const s=(this.useReference?t.object:this.skinnedMesh).skeleton;da.get(s)!==t.frameId&&(da.set(s,t.frameId),this.previousBoneMatricesNode!==null&&s.previousBoneMatrices.set(s.boneMatrices),s.update())}}const of=i=>V(new Tl(i)),vl=i=>V(new Tl(i,!0));class af extends L{static get type(){return"LoopNode"}constructor(t=[]){super(),this.params=t}getVarName(t){return String.fromCharCode(105+t)}getProperties(t){const e=t.getNodeProperties(this);if(e.stackNode!==void 0)return e;const s={};for(let r=0,o=this.params.length-1;r<o;r++){const a=this.params[r],c=a.isNode!==!0&&a.name||this.getVarName(r),h=a.isNode!==!0&&a.type||"int";s[c]=Ze(c,h)}const n=t.addStack();return e.returnsNode=this.params[this.params.length-1](s,n,t),e.stackNode=n,t.removeStack(),e}getNodeType(t){const{returnsNode:e}=this.getProperties(t);return e?e.getNodeType(t):"void"}setup(t){this.getProperties(t)}generate(t){const e=this.getProperties(t),s=this.params,n=e.stackNode;for(let a=0,c=s.length-1;a<c;a++){const h=s[a];let l=null,d=null,p=null,m=null,f=null,x=null;h.isNode?(m="int",p=this.getVarName(a),l="0",d=h.build(t,m),f="<"):(m=h.type||"int",p=h.name||this.getVarName(a),l=h.start,d=h.end,f=h.condition,x=h.update,typeof l=="number"?l=t.generateConst(m,l):l&&l.isNode&&(l=l.build(t,m)),typeof d=="number"?d=t.generateConst(m,d):d&&d.isNode&&(d=d.build(t,m)),l!==void 0&&d===void 0?(l=l+" - 1",d="0",f=">="):d!==void 0&&l===void 0&&(l="0",f="<"),f===void 0&&(Number(l)>Number(d)?f=">=":f="<"));const v={start:l,end:d},A=v.start,F=v.end;let O="",E="",B="";x||(m==="int"||m==="uint"?f.includes("<")?x="++":x="--":f.includes("<")?x="+= 1.":x="-= 1."),O+=t.getVar(m,p)+" = "+A,E+=p+" "+f+" "+F,B+=p+" "+x;const P=`for ( ${O}; ${E}; ${B} )`;t.addFlowCode((a===0?`
`:"")+t.tab+P+` {

`).addFlowTab()}const r=n.build(t,"void"),o=e.returnsNode?e.returnsNode.build(t):"";t.removeFlowTab().addFlowCode(`
`+t.tab+r);for(let a=0,c=this.params.length-1;a<c;a++)t.addFlowCode((a===0?"":t.tab)+`}

`).removeFlowTab();return t.addFlowTab(),o}}const K=(...i)=>V(new af(hs(i,"int"))).append(),cf=()=>Ze("continue").append(),wl=()=>Ze("break").append(),hf=(...i)=>(console.warn("TSL.LoopNode: loop() has been renamed to Loop()."),K(...i)),fr=new WeakMap,Ut=new It,pa=w(({bufferMap:i,influence:t,stride:e,width:s,depth:n,offset:r})=>{const o=y(fl).mul(e).add(r),a=o.div(s),c=o.sub(a.mul(s));return ot(i,Nt(c,a)).depth(n).mul(t)});function lf(i){const t=i.morphAttributes.position!==void 0,e=i.morphAttributes.normal!==void 0,s=i.morphAttributes.color!==void 0,n=i.morphAttributes.position||i.morphAttributes.normal||i.morphAttributes.color,r=n!==void 0?n.length:0;let o=fr.get(i);if(o===void 0||o.count!==r){let F=function(){v.dispose(),fr.delete(i),i.removeEventListener("dispose",F)};var a=F;o!==void 0&&o.texture.dispose();const c=i.morphAttributes.position||[],h=i.morphAttributes.normal||[],l=i.morphAttributes.color||[];let d=0;t===!0&&(d=1),e===!0&&(d=2),s===!0&&(d=3);let p=i.attributes.position.count*d,m=1;const f=4096;p>f&&(m=Math.ceil(p/f),p=f);const x=new Float32Array(p*m*4*r),v=new Ku(x,p,m,r);v.type=Ia,v.needsUpdate=!0;const A=d*4;for(let O=0;O<r;O++){const E=c[O],B=h[O],P=l[O],I=p*m*4*O;for(let U=0;U<E.count;U++){const Z=U*A;t===!0&&(Ut.fromBufferAttribute(E,U),x[I+Z+0]=Ut.x,x[I+Z+1]=Ut.y,x[I+Z+2]=Ut.z,x[I+Z+3]=0),e===!0&&(Ut.fromBufferAttribute(B,U),x[I+Z+4]=Ut.x,x[I+Z+5]=Ut.y,x[I+Z+6]=Ut.z,x[I+Z+7]=0),s===!0&&(Ut.fromBufferAttribute(P,U),x[I+Z+8]=Ut.x,x[I+Z+9]=Ut.y,x[I+Z+10]=Ut.z,x[I+Z+11]=P.itemSize===4?Ut.w:1)}}o={count:r,texture:v,stride:d,size:new gt(p,m)},fr.set(i,o),i.addEventListener("dispose",F)}return o}class uf extends L{static get type(){return"MorphNode"}constructor(t){super("void"),this.mesh=t,this.morphBaseInfluence=W(1),this.updateType=$.OBJECT}setup(t){const{geometry:e}=t,s=e.morphAttributes.position!==void 0,n=e.hasAttribute("normal")&&e.morphAttributes.normal!==void 0,r=e.morphAttributes.position||e.morphAttributes.normal||e.morphAttributes.color,o=r!==void 0?r.length:0,{texture:a,stride:c,size:h}=lf(e);s===!0&&ct.mulAssign(this.morphBaseInfluence),n===!0&&Pt.mulAssign(this.morphBaseInfluence);const l=y(h.width);K(o,({i:d})=>{const p=g(0).toVar();this.mesh.count>1&&this.mesh.morphTexture!==null&&this.mesh.morphTexture!==void 0?p.assign(ot(this.mesh.morphTexture,Nt(y(d).add(1),y(Rn))).r):p.assign(lt("morphTargetInfluences","float").element(d).toVar()),s===!0&&ct.addAssign(pa({bufferMap:a,influence:p,stride:c,width:l,depth:d,offset:y(0)})),n===!0&&Pt.addAssign(pa({bufferMap:a,influence:p,stride:c,width:l,depth:d,offset:y(1)}))})}update(){const t=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?t.value=1:t.value=1-this.mesh.morphTargetInfluences.reduce((e,s)=>e+s,0)}}const Ml=_(uf);class _l extends L{static get type(){return"LightingNode"}constructor(){super("vec3"),this.isLightingNode=!0}generate(){console.warn("Abstract function.")}}class df extends _l{static get type(){return"AONode"}constructor(t=null){super(),this.aoNode=t}setup(t){t.context.ambientOcclusion.mulAssign(this.aoNode)}}class pf extends xh{static get type(){return"LightingContextNode"}constructor(t,e=null,s=null,n=null){super(t),this.lightingModel=e,this.backdropNode=s,this.backdropAlphaNode=n,this._value=null}getContext(){const{backdropNode:t,backdropAlphaNode:e}=this,s=T().toVar("directDiffuse"),n=T().toVar("directSpecular"),r=T().toVar("indirectDiffuse"),o=T().toVar("indirectSpecular"),a={directDiffuse:s,directSpecular:n,indirectDiffuse:r,indirectSpecular:o};return{radiance:T().toVar("radiance"),irradiance:T().toVar("irradiance"),iblIrradiance:T().toVar("iblIrradiance"),ambientOcclusion:g(1).toVar("ambientOcclusion"),reflectedLight:a,backdrop:t,backdropAlpha:e}}setup(t){return this.value=this._value||(this._value=this.getContext()),this.value.lightingModel=this.lightingModel||t.context.lightingModel,super.setup(t)}}const bl=_(pf);class mf extends _l{static get type(){return"IrradianceNode"}constructor(t){super(),this.node=t}setup(t){t.context.irradiance.addAssign(this.node)}}let Qs,Ks;class ft extends L{static get type(){return"ScreenNode"}constructor(t){super(),this.scope=t,this.isViewportNode=!0}getNodeType(){return this.scope===ft.VIEWPORT?"vec4":"vec2"}getUpdateType(){let t=$.NONE;return(this.scope===ft.SIZE||this.scope===ft.VIEWPORT)&&(t=$.RENDER),this.updateType=t,t}update({renderer:t}){const e=t.getRenderTarget();this.scope===ft.VIEWPORT?e!==null?Ks.copy(e.viewport):(t.getViewport(Ks),Ks.multiplyScalar(t.getPixelRatio())):e!==null?(Qs.width=e.width,Qs.height=e.height):t.getDrawingBufferSize(Qs)}setup(){const t=this.scope;let e=null;return t===ft.SIZE?e=W(Qs||(Qs=new gt)):t===ft.VIEWPORT?e=W(Ks||(Ks=new It)):e=z(En.div(_i)),e}generate(t){if(this.scope===ft.COORDINATE){let e=t.getFragCoord();if(t.isFlipY()){const s=t.getNodeProperties(_i).outputNode.build(t);e=`${t.getType("vec2")}( ${e}.x, ${s}.y - ${e}.y )`}return e}return super.generate(t)}}ft.COORDINATE="coordinate";ft.VIEWPORT="viewport";ft.SIZE="size";ft.UV="uv";const Qe=C(ft,ft.UV),_i=C(ft,ft.SIZE),En=C(ft,ft.COORDINATE),_o=C(ft,ft.VIEWPORT),Sl=_o.zw,Al=En.sub(_o.xy),ff=Al.div(Sl),gf=w(()=>(console.warn('TSL.ViewportNode: "viewportResolution" is deprecated. Use "screenSize" instead.'),_i),"vec2").once()(),yf=w(()=>(console.warn('TSL.ViewportNode: "viewportTopLeft" is deprecated. Use "screenUV" instead.'),Qe),"vec2").once()(),xf=w(()=>(console.warn('TSL.ViewportNode: "viewportBottomLeft" is deprecated. Use "screenUV.flipY()" instead.'),Qe.flipY()),"vec2").once()(),tn=new gt;class ki extends Oe{static get type(){return"ViewportTextureNode"}constructor(t=Qe,e=null,s=null){s===null&&(s=new qa,s.minFilter=Ea),super(s,t,e),this.generateMipmaps=!1,this.isOutputTextureNode=!0,this.updateBeforeType=$.FRAME}updateBefore(t){const e=t.renderer;e.getDrawingBufferSize(tn);const s=this.value;(s.image.width!==tn.width||s.image.height!==tn.height)&&(s.image.width=tn.width,s.image.height=tn.height,s.needsUpdate=!0);const n=s.generateMipmaps;s.generateMipmaps=this.generateMipmaps,e.copyFramebufferToTexture(s),s.generateMipmaps=n}clone(){const t=new this.constructor(this.uvNode,this.levelNode,this.value);return t.generateMipmaps=this.generateMipmaps,t}}const Nf=_(ki),Tf=_(ki,null,null,{generateMipmaps:!0});let gr=null;class vf extends ki{static get type(){return"ViewportDepthTextureNode"}constructor(t=Qe,e=null){gr===null&&(gr=new Nn),super(t,e,gr)}}const bo=_(vf);class Lt extends L{static get type(){return"ViewportDepthNode"}constructor(t,e=null){super("float"),this.scope=t,this.valueNode=e,this.isViewportDepthNode=!0}generate(t){const{scope:e}=this;return e===Lt.DEPTH_BASE?t.getFragDepth():super.generate(t)}setup({camera:t}){const{scope:e}=this,s=this.valueNode;let n=null;if(e===Lt.DEPTH_BASE)s!==null&&(n=zl().assign(s));else if(e===Lt.DEPTH)t.isPerspectiveCamera?n=Vl(wt.z,je,Xe):n=Ps(wt.z,je,Xe);else if(e===Lt.LINEAR_DEPTH)if(s!==null)if(t.isPerspectiveCamera){const r=So(s,je,Xe);n=Ps(r,je,Xe)}else n=s;else n=Ps(wt.z,je,Xe);return n}}Lt.DEPTH_BASE="depthBase";Lt.DEPTH="depth";Lt.LINEAR_DEPTH="linearDepth";const Ps=(i,t,e)=>i.add(t).div(t.sub(e)),wf=(i,t,e)=>t.sub(e).mul(i).sub(t),Vl=(i,t,e)=>t.add(i).mul(e).div(e.sub(t).mul(i)),So=(i,t,e)=>t.mul(e).div(e.sub(t).mul(i).sub(e)),Ao=(i,t,e)=>{t=t.max(1e-6).toVar();const s=Ce(i.negate().div(t)),n=Ce(e.div(t));return s.div(n)},Mf=(i,t,e)=>{const s=i.mul(co(e.div(t)));return g(Math.E).pow(s).mul(t).negate()},zl=_(Lt,Lt.DEPTH_BASE),Vo=C(Lt,Lt.DEPTH),bi=_(Lt,Lt.LINEAR_DEPTH),_f=bi(bo());Vo.assign=i=>zl(i);class bf extends L{constructor(t){super("float"),this.name=t,this.isBuiltinNode=!0}generate(){return this.name}}const Sf=_(bf);class Qt extends L{static get type(){return"ClippingNode"}constructor(t=Qt.DEFAULT){super(),this.scope=t}setup(t){super.setup(t);const e=t.clippingContext,{intersectionPlanes:s,unionPlanes:n}=e;return this.hardwareClipping=t.material.hardwareClipping,this.scope===Qt.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(s,n):this.scope===Qt.HARDWARE?this.setupHardwareClipping(n,t):this.setupDefault(s,n)}setupAlphaToCoverage(t,e){return w(()=>{const s=g().toVar("distanceToPlane"),n=g().toVar("distanceToGradient"),r=g(1).toVar("clipOpacity"),o=e.length;if(!this.hardwareClipping&&o>0){const c=os(e);K(o,({i:h})=>{const l=c.element(h);s.assign(wt.dot(l.xyz).negate().add(l.w)),n.assign(s.fwidth().div(2)),r.mulAssign(qs(n.negate(),n,s))})}const a=t.length;if(a>0){const c=os(t),h=g(1).toVar("intersectionClipOpacity");K(a,({i:l})=>{const d=c.element(l);s.assign(wt.dot(d.xyz).negate().add(d.w)),n.assign(s.fwidth().div(2)),h.mulAssign(qs(n.negate(),n,s).oneMinus())}),r.mulAssign(h.oneMinus())}re.a.mulAssign(r),re.a.equal(0).discard()})()}setupDefault(t,e){return w(()=>{const s=e.length;if(!this.hardwareClipping&&s>0){const r=os(e);K(s,({i:o})=>{const a=r.element(o);wt.dot(a.xyz).greaterThan(a.w).discard()})}const n=t.length;if(n>0){const r=os(t),o=Re(!0).toVar("clipped");K(n,({i:a})=>{const c=r.element(a);o.assign(wt.dot(c.xyz).greaterThan(c.w).and(o))}),o.discard()}})()}setupHardwareClipping(t,e){const s=t.length;return e.enableHardwareClipping(s),w(()=>{const n=os(t),r=Sf(e.getClipDistance());K(s,({i:o})=>{const a=n.element(o),c=wt.dot(a.xyz).sub(a.w).negate();r.element(o).assign(c)})})()}}Qt.ALPHA_TO_COVERAGE="alphaToCoverage";Qt.DEFAULT="default";Qt.HARDWARE="hardware";const Af=()=>V(new Qt),Vf=()=>V(new Qt(Qt.ALPHA_TO_COVERAGE)),zf=()=>V(new Qt(Qt.HARDWARE)),Cf=.05,ma=w(([i])=>Be(k(1e4,qt(k(17,i.x).add(k(.1,i.y)))).mul(dt(.1,et(qt(k(13,i.y).add(i.x))))))),fa=w(([i])=>ma(z(ma(i.xy),i.z))),Rf=w(([i])=>{const t=Mt(vi(lo(i.xyz)),vi(uo(i.xyz))),e=g(1).div(g(Cf).mul(t)).toVar("pixScale"),s=z(Ws(me(Ce(e))),Ws(Oi(Ce(e)))),n=z(fa(me(s.x.mul(i.xyz))),fa(me(s.y.mul(i.xyz)))),r=Be(Ce(e)),o=dt(k(r.oneMinus(),n.x),k(r,n.y)),a=Ht(r,r.oneMinus()),c=T(o.mul(o).div(k(2,a).mul(H(1,a))),o.sub(k(.5,a)).div(H(1,a)),H(1,H(1,o).mul(H(1,o)).div(k(2,a).mul(H(1,a))))),h=o.lessThan(a.oneMinus()).select(o.lessThan(a).select(c.x,c.y),c.z);return Fe(h,1e-6,1)}).setLayout({name:"getAlphaHashThreshold",type:"float",inputs:[{name:"position",type:"vec3"}]});class gn extends xi{static get type(){return"NodeMaterial"}get type(){return this.constructor.type}set type(t){}constructor(){super(),this.isNodeMaterial=!0,this.forceSinglePass=!1,this.fog=!0,this.lights=!1,this.hardwareClipping=!1,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.positionNode=null,this.geometryNode=null,this.depthNode=null,this.shadowPositionNode=null,this.receivedShadowNode=null,this.castShadowNode=null,this.outputNode=null,this.mrtNode=null,this.fragmentNode=null,this.vertexNode=null}customProgramCacheKey(){return this.type+Ga(this)}build(t){this.setup(t)}setupObserver(t){return new Md(t)}setup(t){t.context.setupNormal=()=>this.setupNormal(t);const e=t.renderer,s=e.getRenderTarget();t.addStack(),t.stack.outputNode=this.vertexNode||this.setupPosition(t),this.geometryNode!==null&&(t.stack.outputNode=t.stack.outputNode.bypass(this.geometryNode)),t.addFlow("vertex",t.removeStack()),t.addStack();let n;const r=this.setupClipping(t);if(this.depthWrite===!0&&(s!==null?s.depthBuffer===!0&&this.setupDepth(t):e.depth===!0&&this.setupDepth(t)),this.fragmentNode===null){this.setupDiffuseColor(t),this.setupVariants(t);const o=this.setupLighting(t);r!==null&&t.stack.add(r);const a=D(o,re.a).max(0);if(n=this.setupOutput(t,a),Nc.assign(n),this.outputNode!==null&&(n=this.outputNode),s!==null){const c=e.getMRT(),h=this.mrtNode;c!==null?(n=c,h!==null&&(n=c.merge(h))):h!==null&&(n=h)}}else{let o=this.fragmentNode;o.isOutputStructNode!==!0&&(o=D(o)),n=this.setupOutput(t,o)}t.stack.outputNode=n,t.addFlow("fragment",t.removeStack()),t.monitor=this.setupObserver(t)}setupClipping(t){if(t.clippingContext===null)return null;const{unionPlanes:e,intersectionPlanes:s}=t.clippingContext;let n=null;if(e.length>0||s.length>0){const r=t.renderer.samples;this.alphaToCoverage&&r>1?n=Vf():t.stack.add(Af())}return n}setupHardwareClipping(t){if(this.hardwareClipping=!1,t.clippingContext===null)return;const e=t.clippingContext.unionPlanes.length;e>0&&e<=8&&t.isAvailable("clipDistance")&&(t.stack.add(zf()),this.hardwareClipping=!0)}setupDepth(t){const{renderer:e,camera:s}=t;let n=this.depthNode;if(n===null){const r=e.getMRT();r&&r.has("depth")?n=r.get("depth"):e.logarithmicDepthBuffer===!0&&(s.isPerspectiveCamera?n=Ao(wt.z,je,Xe):n=Ps(wt.z,je,Xe))}n!==null&&Vo.assign(n).append()}setupPosition(t){const{object:e}=t,s=e.geometry;if(t.addStack(),(s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color)&&Ml(e).append(),e.isSkinnedMesh===!0&&vl(e).append(),this.displacementMap){const r=as("displacementMap","texture"),o=as("displacementScale","float"),a=as("displacementBias","float");ct.addAssign(Pt.normalize().mul(r.x.mul(o).add(a)))}e.isBatchedMesh&&Nl(e).append(),e.isInstancedMesh&&e.instanceMatrix&&e.instanceMatrix.isInstancedBufferAttribute===!0&&xl(e).append(),this.positionNode!==null&&ct.assign(this.positionNode),this.setupHardwareClipping(t);const n=ml();return t.context.vertex=t.removeStack(),t.context.mvp=n,n}setupDiffuseColor({object:t,geometry:e}){let s=this.colorNode?D(this.colorNode):cl;this.vertexColors===!0&&e.hasAttribute("color")&&(s=D(s.xyz.mul(Ie("color","vec3")),s.a)),t.instanceColor&&(s=fn("vec3","vInstanceColor").mul(s)),t.isBatchedMesh&&t._colorsTexture&&(s=fn("vec3","vBatchColor").mul(s)),re.assign(s);const n=this.opacityNode?g(this.opacityNode):ll;if(re.a.assign(re.a.mul(n)),this.alphaTestNode!==null||this.alphaTest>0){const r=this.alphaTestNode!==null?g(this.alphaTestNode):al;re.a.lessThanEqual(r).discard()}this.alphaHash===!0&&re.a.lessThan(Rf(ct)).discard(),this.transparent===!1&&this.blending===zr&&this.alphaToCoverage===!1&&re.a.assign(1)}setupVariants(){}setupOutgoingLight(){return this.lights===!0?T(0):re.rgb}setupNormal(){return this.normalNode?T(this.normalNode):ul}setupEnvironment(){let t=null;return this.envNode?t=this.envNode:this.envMap&&(t=this.envMap.isCubeTexture?as("envMap","cubeTexture"):as("envMap","texture")),t}setupLightMap(t){let e=null;return t.material.lightMap&&(e=new mf(dl)),e}setupLights(t){const e=[],s=this.setupEnvironment(t);s&&s.isLightingNode&&e.push(s);const n=this.setupLightMap(t);if(n&&n.isLightingNode&&e.push(n),this.aoNode!==null||t.material.aoMap){const o=this.aoNode!==null?this.aoNode:pl;e.push(new df(o))}let r=this.lightsNode||t.lightsNode;return e.length>0&&(r=t.renderer.lighting.createNode([...r.getLights(),...e])),r}setupLightingModel(){}setupLighting(t){const{material:e}=t,{backdropNode:s,backdropAlphaNode:n,emissiveNode:r}=this,a=this.lights===!0||this.lightsNode!==null?this.setupLights(t):null;let c=this.setupOutgoingLight(t);if(a&&a.getScope().hasLights){const h=this.setupLightingModel(t);c=bl(a,h,s,n)}else s!==null&&(c=T(n!==null?at(c,s,n):s));return(r&&r.isNode===!0||e.emissive&&e.emissive.isColor===!0)&&(Pr.assign(T(r||hl)),c=c.add(Pr)),c}setupOutput(t,e){if(this.fog===!0){const s=t.fogNode;s&&(e=D(s.mix(e.rgb,s.colorNode),e.a))}return e}setDefaultValues(t){for(const s in t){const n=t[s];this[s]===void 0&&(this[s]=n,n&&n.clone&&(this[s]=n.clone()))}const e=Object.getOwnPropertyDescriptors(t.constructor.prototype);for(const s in e)Object.getOwnPropertyDescriptor(this.constructor.prototype,s)===void 0&&e[s].get!==void 0&&Object.defineProperty(this.constructor.prototype,s,e[s])}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{},nodes:{}});const s=xi.prototype.toJSON.call(this,t),n=Ni(this);s.inputNodes={};for(const{property:o,childNode:a}of n)s.inputNodes[o]=a.toJSON(t).uuid;function r(o){const a=[];for(const c in o){const h=o[c];delete h.metadata,a.push(h)}return a}if(e){const o=r(t.textures),a=r(t.images),c=r(t.nodes);o.length>0&&(s.textures=o),a.length>0&&(s.images=a),c.length>0&&(s.nodes=c)}return s}copy(t){return this.lightsNode=t.lightsNode,this.envNode=t.envNode,this.colorNode=t.colorNode,this.normalNode=t.normalNode,this.opacityNode=t.opacityNode,this.backdropNode=t.backdropNode,this.backdropAlphaNode=t.backdropAlphaNode,this.alphaTestNode=t.alphaTestNode,this.positionNode=t.positionNode,this.geometryNode=t.geometryNode,this.depthNode=t.depthNode,this.shadowPositionNode=t.shadowPositionNode,this.receivedShadowNode=t.receivedShadowNode,this.castShadowNode=t.castShadowNode,this.outputNode=t.outputNode,this.mrtNode=t.mrtNode,this.fragmentNode=t.fragmentNode,this.vertexNode=t.vertexNode,super.copy(t)}}let yr=null;class Ef extends ki{static get type(){return"ViewportSharedTextureNode"}constructor(t=Qe,e=null){yr===null&&(yr=new qa),super(t,e,yr)}updateReference(){return this}}const Ff=_(Ef),If=i=>V(i).mul(.5).add(.5),Of=i=>V(i).mul(2).sub(1);class Lf extends pt{static get type(){return"EquirectUVNode"}constructor(t=qh){super("vec2"),this.dirNode=t}setup(){const t=this.dirNode,e=t.z.atan2(t.x).mul(1/(Math.PI*2)).add(.5),s=t.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return z(e,s)}}const Bf=_(Lf),Cl=w(({f0:i,f90:t,dotVH:e})=>{const s=e.mul(-5.55473).sub(6.98316).mul(e).exp2();return i.mul(s.oneMinus()).add(t.mul(s))}),Pf=w(i=>i.diffuseColor.mul(1/Math.PI)),Rl=w(i=>{if(i.geometry.hasAttribute("normal")===!1)return g(0);const t=ye.dFdx().abs().max(ye.dFdy().abs());return t.x.max(t.y).max(t.z)}),Df=w(i=>{const{roughness:t}=i,e=Rl();let s=t.max(.0525);return s=s.add(e),s=s.min(1),s}),El=w(({alpha:i,dotNL:t,dotNV:e})=>{const s=i.pow2(),n=t.mul(s.add(s.oneMinus().mul(e.pow2())).sqrt()),r=e.mul(s.add(s.oneMinus().mul(t.pow2())).sqrt());return Ee(.5,n.add(r).max(Pc))}).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),kf=w(({alphaT:i,alphaB:t,dotTV:e,dotBV:s,dotTL:n,dotBL:r,dotNV:o,dotNL:a})=>{const c=a.mul(T(i.mul(e),t.mul(s),o).length()),h=o.mul(T(i.mul(n),t.mul(r),a).length());return Ee(.5,c.add(h)).saturate()}).setLayout({name:"V_GGX_SmithCorrelated_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotTV",type:"float",qualifier:"in"},{name:"dotBV",type:"float",qualifier:"in"},{name:"dotTL",type:"float",qualifier:"in"},{name:"dotBL",type:"float",qualifier:"in"},{name:"dotNV",type:"float",qualifier:"in"},{name:"dotNL",type:"float",qualifier:"in"}]}),Fl=w(({alpha:i,dotNH:t})=>{const e=i.pow2(),s=t.pow2().mul(e.oneMinus()).oneMinus();return e.div(s.pow2()).mul(1/Math.PI)}).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),Uf=g(1/Math.PI),Wf=w(({alphaT:i,alphaB:t,dotNH:e,dotTH:s,dotBH:n})=>{const r=i.mul(t),o=T(t.mul(s),i.mul(n),r.mul(e)),a=o.dot(o),c=r.div(a);return Uf.mul(r.mul(c.pow2()))}).setLayout({name:"D_GGX_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotNH",type:"float",qualifier:"in"},{name:"dotTH",type:"float",qualifier:"in"},{name:"dotBH",type:"float",qualifier:"in"}]}),qf=w(i=>{const{lightDirection:t,f0:e,f90:s,roughness:n,f:r,USE_IRIDESCENCE:o,USE_ANISOTROPY:a}=i,c=i.normalView||Le,h=n.pow2(),l=t.add(Gt).normalize(),d=c.dot(t).clamp(),p=c.dot(Gt).clamp(),m=c.dot(l).clamp(),f=Gt.dot(l).clamp();let x=Cl({f0:e,f90:s,dotVH:f}),v,A;if(mn(o)&&(x=yc.mix(x,r)),mn(a)){const F=pi.dot(t),O=pi.dot(Gt),E=pi.dot(l),B=Bs.dot(t),P=Bs.dot(Gt),I=Bs.dot(l);v=kf({alphaT:Dr,alphaB:h,dotTV:O,dotBV:P,dotTL:F,dotBL:B,dotNV:p,dotNL:d}),A=Wf({alphaT:Dr,alphaB:h,dotNH:m,dotTH:E,dotBH:I})}else v=El({alpha:h,dotNL:d,dotNV:p}),A=Fl({alpha:h,dotNH:m});return x.mul(v).mul(A)}),Gf=w(({roughness:i,dotNV:t})=>{const e=D(-1,-.0275,-.572,.022),s=D(1,.0425,1.04,-.04),n=i.mul(e).add(s),r=n.x.mul(n.x).min(t.mul(-9.28).exp2()).mul(n.x).add(n.y);return z(-1.04,1.04).mul(r).add(n.zw)}).setLayout({name:"DFGApprox",type:"vec2",inputs:[{name:"roughness",type:"float"},{name:"dotNV",type:"vec3"}]}),Hf=w(({f:i,f90:t,dotVH:e})=>{const s=e.oneMinus().saturate(),n=s.mul(s),r=s.mul(n,n).clamp(0,.9999);return i.sub(T(t).mul(r)).div(r.oneMinus())}).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),Ui=1/6,Il=i=>k(Ui,k(i,k(i,i.negate().add(3)).sub(3)).add(1)),qr=i=>k(Ui,k(i,k(i,k(3,i).sub(6))).add(4)),Ol=i=>k(Ui,k(i,k(i,k(-3,i).add(3)).add(3)).add(1)),Gr=i=>k(Ui,he(i,3)),ga=i=>Il(i).add(qr(i)),ya=i=>Ol(i).add(Gr(i)),xa=i=>dt(-1,qr(i).div(Il(i).add(qr(i)))),Na=i=>dt(1,Gr(i).div(Ol(i).add(Gr(i)))),Ta=(i,t,e)=>{const s=i.uvNode,n=k(s,t.zw).add(.5),r=me(n),o=Be(n),a=ga(o.x),c=ya(o.x),h=xa(o.x),l=Na(o.x),d=xa(o.y),p=Na(o.y),m=z(r.x.add(h),r.y.add(d)).sub(.5).mul(t.xy),f=z(r.x.add(l),r.y.add(d)).sub(.5).mul(t.xy),x=z(r.x.add(h),r.y.add(p)).sub(.5).mul(t.xy),v=z(r.x.add(l),r.y.add(p)).sub(.5).mul(t.xy),A=ga(o.y).mul(dt(a.mul(i.uv(m).level(e)),c.mul(i.uv(f).level(e)))),F=ya(o.y).mul(dt(a.mul(i.uv(x).level(e)),c.mul(i.uv(v).level(e))));return A.add(F)},jf=w(([i,t=g(3)])=>{const e=z(i.size(y(t))),s=z(i.size(y(t.add(1)))),n=Ee(1,e),r=Ee(1,s),o=Ta(i,D(n,e),me(t)),a=Ta(i,D(r,s),Oi(t));return Be(t).mix(o,a)});T(.04);g(1);const va=g(1),Hr=g(-2),ri=g(.8),xr=g(-1),oi=g(.4),Nr=g(2),ai=g(.305),Tr=g(3),wa=g(.21),Xf=g(4),Ma=g(4),$f=g(16),Yf=w(([i])=>{const t=T(et(i)).toVar(),e=g(-1).toVar();return q(t.x.greaterThan(t.z),()=>{q(t.x.greaterThan(t.y),()=>{e.assign(Ot(i.x.greaterThan(0),0,3))}).Else(()=>{e.assign(Ot(i.y.greaterThan(0),1,4))})}).Else(()=>{q(t.z.greaterThan(t.y),()=>{e.assign(Ot(i.z.greaterThan(0),2,5))}).Else(()=>{e.assign(Ot(i.y.greaterThan(0),1,4))})}),e}).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),Zf=w(([i,t])=>{const e=z().toVar();return q(t.equal(0),()=>{e.assign(z(i.z,i.y).div(et(i.x)))}).ElseIf(t.equal(1),()=>{e.assign(z(i.x.negate(),i.z.negate()).div(et(i.y)))}).ElseIf(t.equal(2),()=>{e.assign(z(i.x.negate(),i.y).div(et(i.z)))}).ElseIf(t.equal(3),()=>{e.assign(z(i.z.negate(),i.y).div(et(i.x)))}).ElseIf(t.equal(4),()=>{e.assign(z(i.x.negate(),i.z).div(et(i.y)))}).Else(()=>{e.assign(z(i.x,i.y).div(et(i.z)))}),k(.5,e.add(1))}).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),Jf=w(([i])=>{const t=g(0).toVar();return q(i.greaterThanEqual(ri),()=>{t.assign(va.sub(i).mul(xr.sub(Hr)).div(va.sub(ri)).add(Hr))}).ElseIf(i.greaterThanEqual(oi),()=>{t.assign(ri.sub(i).mul(Nr.sub(xr)).div(ri.sub(oi)).add(xr))}).ElseIf(i.greaterThanEqual(ai),()=>{t.assign(oi.sub(i).mul(Tr.sub(Nr)).div(oi.sub(ai)).add(Nr))}).ElseIf(i.greaterThanEqual(wa),()=>{t.assign(ai.sub(i).mul(Xf.sub(Tr)).div(ai.sub(wa)).add(Tr))}).Else(()=>{t.assign(g(-2).mul(Ce(k(1.16,i))))}),t}).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]}),Ll=w(([i,t])=>{const e=i.toVar();e.assign(k(2,e).sub(1));const s=T(e,1).toVar();return q(t.equal(0),()=>{s.assign(s.zyx)}).ElseIf(t.equal(1),()=>{s.assign(s.xzy),s.xz.mulAssign(-1)}).ElseIf(t.equal(2),()=>{s.x.mulAssign(-1)}).ElseIf(t.equal(3),()=>{s.assign(s.zyx),s.xz.mulAssign(-1)}).ElseIf(t.equal(4),()=>{s.assign(s.xzy),s.xy.mulAssign(-1)}).ElseIf(t.equal(5),()=>{s.z.mulAssign(-1)}),s}).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]}),Bl=w(([i,t,e,s,n,r])=>{const o=g(e),a=T(t),c=Fe(Jf(o),Hr,r),h=Be(c),l=me(c),d=T(jr(i,a,l,s,n,r)).toVar();return q(h.notEqual(0),()=>{const p=T(jr(i,a,l.add(1),s,n,r)).toVar();d.assign(at(d,p,h))}),d}),jr=w(([i,t,e,s,n,r])=>{const o=g(e).toVar(),a=T(t),c=g(Yf(a)).toVar(),h=g(Mt(Ma.sub(o),0)).toVar();o.assign(Mt(o,Ma));const l=g(Ws(o)).toVar(),d=z(Zf(a,c).mul(l.sub(2)).add(1)).toVar();return q(c.greaterThan(2),()=>{d.y.addAssign(l),c.subAssign(3)}),d.x.addAssign(c.mul(l)),d.x.addAssign(h.mul(k(3,$f))),d.y.addAssign(k(4,Ws(r).sub(l))),d.x.mulAssign(s),d.y.mulAssign(n),i.uv(d).grad(z(),z())}),vr=w(({envMap:i,mipInt:t,outputDirection:e,theta:s,axis:n,CUBEUV_TEXEL_WIDTH:r,CUBEUV_TEXEL_HEIGHT:o,CUBEUV_MAX_MIP:a})=>{const c=be(s),h=e.mul(c).add(n.cross(e).mul(qt(s))).add(n.mul(n.dot(e).mul(c.oneMinus())));return jr(i,h,t,r,o,a)}),Qf=w(({n:i,latitudinal:t,poleAxis:e,outputDirection:s,weights:n,samples:r,dTheta:o,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:d})=>{const p=T(Ot(t,e,Bi(e,s))).toVar();q(ao(p.equals(T(0))),()=>{p.assign(T(s.z,0,s.x.negate()))}),p.assign(gs(p));const m=T().toVar();return m.addAssign(n.element(y(0)).mul(vr({theta:0,axis:p,outputDirection:s,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:d}))),K({start:y(1),end:i},({i:f})=>{q(f.greaterThanEqual(r),()=>{wl()});const x=g(o.mul(g(f))).toVar();m.addAssign(n.element(f).mul(vr({theta:x.mul(-1),axis:p,outputDirection:s,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:d}))),m.addAssign(n.element(f).mul(vr({theta:x,axis:p,outputDirection:s,mipInt:a,envMap:c,CUBEUV_TEXEL_WIDTH:h,CUBEUV_TEXEL_HEIGHT:l,CUBEUV_MAX_MIP:d})))}),D(m,1)});let Si=null;const _a=new WeakMap;function Kf(i){const t=Math.log2(i)-2,e=1/i;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:e,maxMip:t}}function tg(i){let t=_a.get(i);if((t!==void 0?t.pmremVersion:-1)!==i.pmremVersion){const s=i.image;if(i.isCubeTexture)if(sg(s))t=Si.fromCubemap(i,t);else return null;else if(ng(s))t=Si.fromEquirectangular(i,t);else return null;t.pmremVersion=i.pmremVersion,_a.set(i,t)}return t.texture}class eg extends pt{static get type(){return"PMREMNode"}constructor(t,e=null,s=null){super("vec3"),this._value=t,this._pmrem=null,this.uvNode=e,this.levelNode=s,this._generator=null;const n=new Zt;n.isRenderTargetTexture=!0,this._texture=Ft(n),this._width=W(0),this._height=W(0),this._maxMip=W(0),this.updateBeforeType=$.RENDER}set value(t){this._value=t,this._pmrem=null}get value(){return this._value}updateFromTexture(t){const e=Kf(t.image.height);this._texture.value=t,this._width.value=e.texelWidth,this._height.value=e.texelHeight,this._maxMip.value=e.maxMip}updateBefore(){let t=this._pmrem;const e=t?t.pmremVersion:-1,s=this._value;e!==s.pmremVersion&&(s.isPMREMTexture===!0?t=s:t=tg(s),t!==null&&(this._pmrem=t,this.updateFromTexture(t)))}setup(t){Si===null&&(Si=t.createPMREMGenerator()),this.updateBefore(t);let e=this.uvNode;e===null&&t.context.getUV&&(e=t.context.getUV(this));const s=this.value;t.renderer.coordinateSystem===cs&&s.isPMREMTexture!==!0&&s.isRenderTargetTexture===!0&&(e=T(e.x.negate(),e.yz));let n=this.levelNode;return n===null&&t.context.getTextureLevel&&(n=t.context.getTextureLevel(this)),Bl(this._texture,e,n,this._width,this._height,this._maxMip)}}function sg(i){if(i==null)return!1;let t=0;const e=6;for(let s=0;s<e;s++)i[s]!==void 0&&t++;return t===e}function ng(i){return i==null?!1:i.height>0}const ig=_(eg);class rg extends pt{static get type(){return"MatcapUVNode"}constructor(){super("vec2")}setup(){const t=T(Gt.z,0,Gt.x.negate()).normalize(),e=Gt.cross(t);return z(t.dot(Le),e.dot(Le)).mul(.495).add(.5)}}const og=C(rg);class ag extends pt{static get type(){return"RotateNode"}constructor(t,e){super(),this.positionNode=t,this.rotationNode=e}getNodeType(t){return this.positionNode.getNodeType(t)}setup(t){const{rotationNode:e,positionNode:s}=this;if(this.getNodeType(t)==="vec2"){const r=e.cos(),o=e.sin();return Ii(r,o,o.negate(),r).mul(s)}else{const r=e,o=ls(D(1,0,0,0),D(0,be(r.x),qt(r.x).negate(),0),D(0,qt(r.x),be(r.x),0),D(0,0,0,1)),a=ls(D(be(r.y),0,qt(r.y),0),D(0,1,0,0),D(qt(r.y).negate(),0,be(r.y),0),D(0,0,0,1)),c=ls(D(be(r.z),qt(r.z).negate(),0,0),D(qt(r.z),be(r.z),0,0),D(0,0,1,0),D(0,0,0,1));return o.mul(a).mul(c).mul(D(s,1)).xyz}}}const Pl=_(ag),cg=w(({texture:i,uv:t})=>{const s=T().toVar();return q(t.x.lessThan(1e-4),()=>{s.assign(T(1,0,0))}).ElseIf(t.y.lessThan(1e-4),()=>{s.assign(T(0,1,0))}).ElseIf(t.z.lessThan(1e-4),()=>{s.assign(T(0,0,1))}).ElseIf(t.x.greaterThan(1-1e-4),()=>{s.assign(T(-1,0,0))}).ElseIf(t.y.greaterThan(1-1e-4),()=>{s.assign(T(0,-1,0))}).ElseIf(t.z.greaterThan(1-1e-4),()=>{s.assign(T(0,0,-1))}).Else(()=>{const r=i.uv(t.add(T(-.01,0,0))).r.sub(i.uv(t.add(T(.01,0,0))).r),o=i.uv(t.add(T(0,-.01,0))).r.sub(i.uv(t.add(T(0,.01,0))).r),a=i.uv(t.add(T(0,0,-.01))).r.sub(i.uv(t.add(T(0,0,.01))).r);s.assign(T(r,o,a))}),s.normalize()});class hg extends Oe{static get type(){return"Texture3DNode"}constructor(t,e=null,s=null){super(t,e,s),this.isTexture3DNode=!0}getInputType(){return"texture3D"}getDefaultUV(){return T(.5,.5,.5)}setUpdateMatrix(){}setupUV(t,e){return e}generateUV(t,e){return e.build(t,"vec3")}normal(t){return cg({texture:this,uv:t})}}const lg=_(hg);class ug extends Y{static get type(){return"ParameterNode"}constructor(t,e=null){super(t,e),this.isParameterNode=!0}getHash(){return this.uuid}generate(){return this.name}}const dg=(i,t)=>V(new ug(i,t));class pg extends L{static get type(){return"StackNode"}constructor(t=null){super(),this.nodes=[],this.outputNode=null,this.parent=t,this._currentCond=null,this.isStackNode=!0}getNodeType(t){return this.outputNode?this.outputNode.getNodeType(t):"void"}add(t){return this.nodes.push(t),this}If(t,e){const s=new ln(e);return this._currentCond=Ot(t,s),this.add(this._currentCond)}ElseIf(t,e){const s=new ln(e),n=Ot(t,s);return this._currentCond.elseNode=n,this._currentCond=n,this}Else(t){return this._currentCond.elseNode=new ln(t),this}build(t,...e){const s=ec();Br(this);for(const n of this.nodes)n.build(t,"void");return Br(s),this.outputNode?this.outputNode.build(t,...e):super.build(t,...e)}else(...t){return console.warn("TSL.StackNode: .else() has been renamed to .Else()."),this.Else(...t)}elseif(...t){return console.warn("TSL.StackNode: .elseif() has been renamed to .ElseIf()."),this.ElseIf(...t)}}const mg=_(pg);class fg extends L{static get type(){return"StructTypeNode"}constructor(t){super(),this.types=t,this.isStructTypeNode=!0}getMemberTypes(){return this.types}}class Dl extends L{static get type(){return"OutputStructNode"}constructor(...t){super(),this.members=t,this.isOutputStructNode=!0}setup(t){super.setup(t);const e=this.members,s=[];for(let n=0;n<e.length;n++)s.push(e[n].getNodeType(t));this.nodeType=t.getStructTypeFromNode(new fg(s)).name}generate(t,e){const s=t.getOutputStructName(),n=this.members,r=s!==""?s+".":"";for(let o=0;o<n.length;o++){const a=n[o].build(t,e);t.addLineFlowCode(`${r}m${o} = ${a}`,this)}return s}}const gg=_(Dl);function kl(i,t){for(let e=0;e<i.length;e++)if(i[e].name===t)return e;return-1}class yg extends Dl{static get type(){return"MRTNode"}constructor(t){super(),this.outputNodes=t,this.isMRTNode=!0}has(t){return this.outputNodes[t]!==void 0}get(t){return this.outputNodes[t]}merge(t){const e={...this.outputNodes,...t.outputNodes};return Ul(e)}setup(t){const e=this.outputNodes,s=t.renderer.getRenderTarget(),n=[],r=s.textures;for(const o in e){const a=kl(r,o);n[a]=D(e[o])}return this.members=n,super.setup(t)}}const Ul=_(yg),xg=w(([i])=>{const t=i.toUint().mul(747796405).add(2891336453),e=t.shiftRight(t.shiftRight(28).add(4)).bitXor(t).mul(277803737);return e.shiftRight(22).bitXor(e).toFloat().mul(1/2**32)}),Xr=(i,t)=>he(k(4,i.mul(H(1,i))),t),Ng=(i,t)=>i.lessThan(.5)?Xr(i.mul(2),t).div(2):H(1,Xr(k(H(1,i),2),t).div(2)),Tg=(i,t,e)=>he(Ee(he(i,t),dt(he(i,t),he(H(1,i),e))),1/t),vg=(i,t)=>qt(Ti.mul(t.mul(i).sub(1))).div(Ti.mul(t.mul(i).sub(1))),de=w(([i])=>i.fract().sub(.5).abs()).setLayout({name:"tri",type:"float",inputs:[{name:"x",type:"float"}]}),Wl=w(([i])=>T(de(i.z.add(de(i.y.mul(1)))),de(i.z.add(de(i.x.mul(1)))),de(i.y.add(de(i.x.mul(1)))))).setLayout({name:"tri3",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),wg=w(([i,t,e])=>{const s=T(i).toVar(),n=g(1.4).toVar(),r=g(0).toVar(),o=T(s).toVar();return K({start:g(0),end:g(3),type:"float",condition:"<="},()=>{const a=T(Wl(o.mul(2))).toVar();s.addAssign(a.add(e.mul(g(.1).mul(t)))),o.mulAssign(1.8),n.mulAssign(1.5),s.mulAssign(1.2);const c=g(de(s.z.add(de(s.x.add(de(s.y)))))).toVar();r.addAssign(c.div(n)),o.addAssign(.14)}),r}).setLayout({name:"triNoise3D",type:"float",inputs:[{name:"p",type:"vec3"},{name:"spd",type:"float"},{name:"time",type:"float"}]});class Mg extends L{static get type(){return"FunctionOverloadingNode"}constructor(t=[],...e){super(),this.functionNodes=t,this.parametersNodes=e,this._candidateFnCall=null,this.global=!0}getNodeType(){return this.functionNodes[0].shaderNode.layout.type}setup(t){const e=this.parametersNodes;let s=this._candidateFnCall;if(s===null){let n=null,r=-1;for(const o of this.functionNodes){const c=o.shaderNode.layout;if(c===null)throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");const h=c.inputs;if(e.length===h.length){let l=0;for(let d=0;d<e.length;d++){const p=e[d],m=h[d];p.getNodeType(t)===m.type?l++:l=0}l>r&&(n=o,r=l)}}this._candidateFnCall=s=n(...e)}return s}}const _g=_(Mg),bt=i=>(...t)=>_g(i,...t),ys=W(0).setGroup(X).onRenderUpdate(i=>i.time),ql=W(0).setGroup(X).onRenderUpdate(i=>i.deltaTime),bg=W(0,"uint").setGroup(X).onRenderUpdate(i=>i.frameId),Sg=(i=1)=>(console.warn('TSL: timerLocal() is deprecated. Use "time" instead.'),ys.mul(i)),Ag=(i=1)=>(console.warn('TSL: timerGlobal() is deprecated. Use "time" instead.'),ys.mul(i)),Vg=(i=1)=>(console.warn('TSL: timerDelta() is deprecated. Use "deltaTime" instead.'),ql.mul(i)),zg=(i=ys)=>i.add(.75).mul(Math.PI*2).sin().mul(.5).add(.5),Cg=(i=ys)=>i.fract().round(),Rg=(i=ys)=>i.add(.5).fract().mul(2).sub(1).abs(),Eg=(i=ys)=>i.fract(),Fg=w(([i,t,e=z(.5)])=>Pl(i.sub(e),t).add(e)),Ig=w(([i,t,e=z(.5)])=>{const s=i.sub(e),n=s.dot(s),o=n.mul(n).mul(t);return i.add(s.mul(o))}),Og=w(({position:i=null,horizontal:t=!0,vertical:e=!1})=>{let s;i!==null?(s=Se.toVar(),s[3][0]=i.x,s[3][1]=i.y,s[3][2]=i.z):s=Se;const n=ee.mul(s);return mn(t)&&(n[0][0]=Se[0].length(),n[0][1]=0,n[0][2]=0),mn(e)&&(n[1][0]=0,n[1][1]=Se[1].length(),n[1][2]=0),n[2][0]=0,n[2][1]=0,n[2][2]=1,bn.mul(n).mul(ct)}),Lg=w(([i=null])=>{const t=bi();return bi(bo(i)).sub(t).lessThan(0).select(Qe,i)});class Bg extends L{static get type(){return"SpriteSheetUVNode"}constructor(t,e=rt(),s=g(0)){super("vec2"),this.countNode=t,this.uvNode=e,this.frameNode=s}setup(){const{frameNode:t,uvNode:e,countNode:s}=this,{width:n,height:r}=s,o=t.mod(n.mul(r)).floor(),a=o.mod(n),c=r.sub(o.add(1).div(n).ceil()),h=s.reciprocal(),l=z(a,c);return e.add(l).mul(h)}}const Pg=_(Bg);class Dg extends L{static get type(){return"TriplanarTexturesNode"}constructor(t,e=null,s=null,n=g(1),r=ct,o=Pt){super("vec4"),this.textureXNode=t,this.textureYNode=e,this.textureZNode=s,this.scaleNode=n,this.positionNode=r,this.normalNode=o}setup(){const{textureXNode:t,textureYNode:e,textureZNode:s,scaleNode:n,positionNode:r,normalNode:o}=this;let a=o.abs().normalize();a=a.div(a.dot(T(1)));const c=r.yz.mul(n),h=r.zx.mul(n),l=r.xy.mul(n),d=t.value,p=e!==null?e.value:d,m=s!==null?s.value:d,f=Ft(d,c).mul(a.x),x=Ft(p,h).mul(a.y),v=Ft(m,l).mul(a.z);return dt(f,x,v)}}const Gl=_(Dg),kg=(...i)=>Gl(...i),zs=new xd,ss=new S,Cs=new S,wr=new S,en=new tt,ci=new S(0,0,-1),ue=new It,sn=new S,hi=new S,nn=new It,li=new gt,Ai=new Ci,Ug=Qe.flipX();Ai.depthTexture=new Nn(1,1);let Mr=!1;class zo extends Oe{static get type(){return"ReflectorNode"}constructor(t={}){super(t.defaultTexture||Ai.texture,Ug),this._reflectorBaseNode=t.reflector||new Wg(this,t),this._depthNode=null,this.setUpdateMatrix(!1)}get reflector(){return this._reflectorBaseNode}get target(){return this._reflectorBaseNode.target}getDepthNode(){if(this._depthNode===null){if(this._reflectorBaseNode.depth!==!0)throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");this._depthNode=V(new zo({defaultTexture:Ai.depthTexture,reflector:this._reflectorBaseNode}))}return this._depthNode}setup(t){return t.object.isQuadMesh||this._reflectorBaseNode.build(t),super.setup(t)}clone(){const t=new this.constructor(this.reflectorNode);return t._reflectorBaseNode=this._reflectorBaseNode,t}}class Wg extends L{static get type(){return"ReflectorBaseNode"}constructor(t,e={}){super();const{target:s=new Jt,resolution:n=1,generateMipmaps:r=!1,bounces:o=!0,depth:a=!1}=e;this.textureNode=t,this.target=s,this.resolution=n,this.generateMipmaps=r,this.bounces=o,this.depth=a,this.updateBeforeType=o?$.RENDER:$.FRAME,this.virtualCameras=new WeakMap,this.renderTargets=new WeakMap}_updateResolution(t,e){const s=this.resolution;e.getDrawingBufferSize(li),t.setSize(Math.round(li.width*s),Math.round(li.height*s))}setup(t){return this._updateResolution(Ai,t.renderer),super.setup(t)}getVirtualCamera(t){let e=this.virtualCameras.get(t);return e===void 0&&(e=t.clone(),this.virtualCameras.set(t,e)),e}getRenderTarget(t){let e=this.renderTargets.get(t);return e===void 0&&(e=new Ci(0,0,{type:dn}),this.generateMipmaps===!0&&(e.texture.minFilter=bu,e.texture.generateMipmaps=!0),this.depth===!0&&(e.depthTexture=new Nn),this.renderTargets.set(t,e)),e}updateBefore(t){if(this.bounces===!1&&Mr)return;Mr=!0;const{scene:e,camera:s,renderer:n,material:r}=t,{target:o}=this,a=this.getVirtualCamera(s),c=this.getRenderTarget(a);if(n.getDrawingBufferSize(li),this._updateResolution(c,n),Cs.setFromMatrixPosition(o.matrixWorld),wr.setFromMatrixPosition(s.matrixWorld),en.extractRotation(o.matrixWorld),ss.set(0,0,1),ss.applyMatrix4(en),sn.subVectors(Cs,wr),sn.dot(ss)>0)return;sn.reflect(ss).negate(),sn.add(Cs),en.extractRotation(s.matrixWorld),ci.set(0,0,-1),ci.applyMatrix4(en),ci.add(wr),hi.subVectors(Cs,ci),hi.reflect(ss).negate(),hi.add(Cs),a.coordinateSystem=s.coordinateSystem,a.position.copy(sn),a.up.set(0,1,0),a.up.applyMatrix4(en),a.up.reflect(ss),a.lookAt(hi),a.near=s.near,a.far=s.far,a.updateMatrixWorld(),a.projectionMatrix.copy(s.projectionMatrix),zs.setFromNormalAndCoplanarPoint(ss,Cs),zs.applyMatrix4(a.matrixWorldInverse),ue.set(zs.normal.x,zs.normal.y,zs.normal.z,zs.constant);const h=a.projectionMatrix;nn.x=(Math.sign(ue.x)+h.elements[8])/h.elements[0],nn.y=(Math.sign(ue.y)+h.elements[9])/h.elements[5],nn.z=-1,nn.w=(1+h.elements[10])/h.elements[14],ue.multiplyScalar(1/ue.dot(nn));const l=0;h.elements[2]=ue.x,h.elements[6]=ue.y,h.elements[10]=n.coordinateSystem===ks?ue.z-l:ue.z+1-l,h.elements[14]=ue.w,this.textureNode.value=c.texture,this.depth===!0&&(this.textureNode.getDepthNode().value=c.depthTexture),r.visible=!1;const d=n.getRenderTarget(),p=n.getMRT();n.setMRT(null),n.setRenderTarget(c),n.render(e,a),n.setMRT(p),n.setRenderTarget(d),r.visible=!0,Mr=!1}}const qg=i=>V(new zo(i)),_r=new Td(-1,1,1,-1,0,1);class Gg extends Ri{constructor(t=!1){super();const e=t===!1?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new Fr([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Fr(e,2))}}const Hg=new Gg;class Hl extends pd{constructor(t=null){super(Hg,t),this.camera=_r,this.isQuadMesh=!0}renderAsync(t){return t.renderAsync(this,_r)}render(t){t.render(this,_r)}}const jg=new gt;class Xg extends Oe{static get type(){return"RTTNode"}constructor(t,e=null,s=null,n={type:dn}){const r=new Ci(e,s,n);super(r.texture,rt()),this.node=t,this.width=e,this.height=s,this.renderTarget=r,this.textureNeedsUpdate=!0,this.autoUpdate=!0,this.updateMap=new WeakMap,this._rttNode=null,this._quadMesh=new Hl(new gn),this.updateBeforeType=$.RENDER}get autoSize(){return this.width===null}setup(t){return this._rttNode=this.node.context(t.getSharedContext()),this._quadMesh.material.name="RTT",this._quadMesh.material.needsUpdate=!0,super.setup(t)}setSize(t,e){this.width=t,this.height=e;const s=t*this.pixelRatio,n=e*this.pixelRatio;this.renderTarget.setSize(s,n),this.textureNeedsUpdate=!0}setPixelRatio(t){this.pixelRatio=t,this.setSize(this.width,this.height)}updateBefore({renderer:t}){if(this.textureNeedsUpdate===!1&&this.autoUpdate===!1)return;if(this.textureNeedsUpdate=!1,this.autoSize===!0){this.pixelRatio=t.getPixelRatio();const s=t.getSize(jg);this.setSize(s.width,s.height)}this._quadMesh.material.fragmentNode=this._rttNode;const e=t.getRenderTarget();t.setRenderTarget(this.renderTarget),this._quadMesh.render(t),t.setRenderTarget(e)}clone(){const t=new Oe(this.value,this.uvNode,this.levelNode);return t.sampler=this.sampler,t.referenceNode=this,t}}const jl=(i,...t)=>V(new Xg(V(i),...t)),$g=(i,...t)=>i.isTextureNode?i:i.isPassNode?i.getTextureNode():jl(i,...t),Is=w(([i,t,e],s)=>{let n;s.renderer.coordinateSystem===ks?(i=z(i.x,i.y.oneMinus()).mul(2).sub(1),n=D(T(i,t),1)):n=D(T(i.x,i.y.oneMinus(),t).mul(2).sub(1),1);const r=D(e.mul(n));return r.xyz.div(r.w)}),Yg=w(([i,t])=>{const e=t.mul(D(i,1)),s=e.xy.div(e.w).mul(.5).add(.5).toVar();return z(s.x,s.y.oneMinus())}),Zg=w(([i,t,e])=>{const s=us(ot(t)),n=Nt(i.mul(s)).toVar(),r=ot(t,n).toVar(),o=ot(t,n.sub(Nt(2,0))).toVar(),a=ot(t,n.sub(Nt(1,0))).toVar(),c=ot(t,n.add(Nt(1,0))).toVar(),h=ot(t,n.add(Nt(2,0))).toVar(),l=ot(t,n.add(Nt(0,2))).toVar(),d=ot(t,n.add(Nt(0,1))).toVar(),p=ot(t,n.sub(Nt(0,1))).toVar(),m=ot(t,n.sub(Nt(0,2))).toVar(),f=et(H(g(2).mul(a).sub(o),r)).toVar(),x=et(H(g(2).mul(c).sub(h),r)).toVar(),v=et(H(g(2).mul(d).sub(l),r)).toVar(),A=et(H(g(2).mul(p).sub(m),r)).toVar(),F=Is(i,r,e).toVar(),O=f.lessThan(x).select(F.sub(Is(i.sub(z(g(1).div(s.x),0)),a,e)),F.negate().add(Is(i.add(z(g(1).div(s.x),0)),c,e))),E=v.lessThan(A).select(F.sub(Is(i.add(z(0,g(1).div(s.y))),d,e)),F.negate().add(Is(i.sub(z(0,g(1).div(s.y))),p,e)));return gs(Bi(O,E))});class Jg extends Qr{constructor(t,e,s=Float32Array){ArrayBuffer.isView(t)===!1&&(t=new s(t*e)),super(t,e),this.isStorageInstancedBufferAttribute=!0}}class Qg extends ze{constructor(t,e,s=Float32Array){ArrayBuffer.isView(t)===!1&&(t=new s(t*e)),super(t,e),this.isStorageBufferAttribute=!0}}class Kg extends fs{static get type(){return"StorageArrayElementNode"}constructor(t,e){super(t,e),this.isStorageArrayElementNode=!0}set storageBufferNode(t){this.node=t}get storageBufferNode(){return this.node}setup(t){return t.isAvailable("storageBuffer")===!1&&this.node.isPBO===!0&&t.setupPBO(this.node),super.setup(t)}generate(t,e){let s;const n=t.context.assign;if(t.isAvailable("storageBuffer")===!1?this.node.isPBO===!0&&n!==!0&&(this.node.value.isInstancedBufferAttribute||t.shaderStage!=="compute")?s=t.generatePBO(this):s=this.node.build(t):s=super.generate(t),n!==!0){const r=this.getNodeType(t);s=t.format(s,r,e)}return s}}const ty=_(Kg);class ey extends vo{static get type(){return"StorageBufferNode"}constructor(t,e=null,s=0){e===null&&(t.isStorageBufferAttribute||t.isStorageInstancedBufferAttribute)&&(e=Vd(t.itemSize),s=t.count),super(t,e,s),this.isStorageBufferNode=!0,this.access=pe.READ_WRITE,this.isAtomic=!1,this.isPBO=!1,this.bufferCount=s,this._attribute=null,this._varying=null,this.global=!0,t.isStorageBufferAttribute!==!0&&t.isStorageInstancedBufferAttribute!==!0&&(t.isInstancedBufferAttribute?t.isStorageInstancedBufferAttribute=!0:t.isStorageBufferAttribute=!0)}getHash(t){if(this.bufferCount===0){let e=t.globalCache.getData(this.value);return e===void 0&&(e={node:this},t.globalCache.setData(this.value,e)),e.node.uuid}return this.uuid}getInputType(){return this.value.isIndirectStorageBufferAttribute?"indirectStorageBuffer":"storageBuffer"}element(t){return ty(this,t)}setPBO(t){return this.isPBO=t,this}getPBO(){return this.isPBO}setAccess(t){return this.access=t,this}toReadOnly(){return this.setAccess(pe.READ_ONLY)}setAtomic(t){return this.isAtomic=t,this}toAtomic(){return this.setAtomic(!0)}getAttributeData(){return this._attribute===null&&(this._attribute=_n(this.value),this._varying=jt(this._attribute)),{attribute:this._attribute,varying:this._varying}}getNodeType(t){if(t.isAvailable("storageBuffer")||t.isAvailable("indirectStorageBuffer"))return super.getNodeType(t);const{attribute:e}=this.getAttributeData();return e.getNodeType(t)}generate(t){if(t.isAvailable("storageBuffer")||t.isAvailable("indirectStorageBuffer"))return super.generate(t);const{attribute:e,varying:s}=this.getAttributeData(),n=s.build(t);return t.registerTransform(n,e),n}}const Wi=(i,t,e)=>V(new ey(i,t,e)),sy=(i,t,e)=>(console.warn('THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.'),Wi(i,t,e).setPBO(!0)),ny=(i,t="float")=>{const e=Ha(t),s=new Qg(i,e);return Wi(s,t,i)},iy=(i,t="float")=>{const e=Ha(t),s=new Jg(i,e);return Wi(s,t,i)};class ry extends Dh{static get type(){return"VertexColorNode"}constructor(t=0){super(null,"vec4"),this.isVertexColorNode=!0,this.index=t}getAttributeName(){const t=this.index;return"color"+(t>0?t:"")}generate(t){const e=this.getAttributeName(t),s=t.hasGeometryAttribute(e);let n;return s===!0?n=super.generate(t):n=t.generateConst(this.nodeType,new It(1,1,1,1)),n}serialize(t){super.serialize(t),t.index=this.index}deserialize(t){super.deserialize(t),this.index=t.index}}const oy=(...i)=>V(new ry(...i));class ay extends L{static get type(){return"PointUVNode"}constructor(){super("vec2"),this.isPointUVNode=!0}generate(){return"vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )"}}const cy=C(ay),rn=new ms,br=new tt;class Bt extends L{static get type(){return"SceneNode"}constructor(t=Bt.BACKGROUND_BLURRINESS,e=null){super(),this.scope=t,this.scene=e}setup(t){const e=this.scope,s=this.scene!==null?this.scene:t.scene;let n;return e===Bt.BACKGROUND_BLURRINESS?n=lt("backgroundBlurriness","float",s):e===Bt.BACKGROUND_INTENSITY?n=lt("backgroundIntensity","float",s):e===Bt.BACKGROUND_ROTATION?n=W("mat4").label("backgroundRotation").setGroup(X).onRenderUpdate(()=>{const r=s.background;return r!==null&&r.isTexture&&r.mapping!==Yr?(rn.copy(s.backgroundRotation),rn.x*=-1,rn.y*=-1,rn.z*=-1,br.makeRotationFromEuler(rn)):br.identity(),br}):console.error("THREE.SceneNode: Unknown scope:",e),n}}Bt.BACKGROUND_BLURRINESS="backgroundBlurriness";Bt.BACKGROUND_INTENSITY="backgroundIntensity";Bt.BACKGROUND_ROTATION="backgroundRotation";const hy=C(Bt,Bt.BACKGROUND_BLURRINESS),ly=C(Bt,Bt.BACKGROUND_INTENSITY),uy=C(Bt,Bt.BACKGROUND_ROTATION);class dy extends Oe{static get type(){return"StorageTextureNode"}constructor(t,e,s=null){super(t,e),this.storeNode=s,this.isStorageTextureNode=!0,this.access=pe.WRITE_ONLY}getInputType(){return"storageTexture"}setup(t){super.setup(t);const e=t.getNodeProperties(this);e.storeNode=this.storeNode}setAccess(t){return this.access=t,this}generate(t,e){let s;return this.storeNode!==null?s=this.generateStore(t):s=super.generate(t,e),s}toReadWrite(){return this.setAccess(pe.READ_WRITE)}toReadOnly(){return this.setAccess(pe.READ_ONLY)}toWriteOnly(){return this.setAccess(pe.WRITE_ONLY)}generateStore(t){const e=t.getNodeProperties(this),{uvNode:s,storeNode:n}=e,r=super.generate(t,"property"),o=s.build(t,"uvec2"),a=n.build(t,"vec4"),c=t.generateTextureStore(t,r,o,a);t.addLineFlowCode(c,this)}}const Xl=_(dy),py=(i,t,e)=>{const s=Xl(i,t,e);return e!==null&&s.append(),s};class my extends Pi{static get type(){return"UserDataNode"}constructor(t,e,s=null){super(t,e,s),this.userData=s}updateReference(t){return this.reference=this.userData!==null?this.userData:t.object.userData,this.reference}}const fy=(i,t,e)=>V(new my(i,t,e)),ba=new WeakMap;class gy extends pt{static get type(){return"VelocityNode"}constructor(){super("vec2"),this.projectionMatrix=null,this.updateType=$.OBJECT,this.updateAfterType=$.OBJECT,this.previousModelWorldMatrix=W(new tt),this.previousProjectionMatrix=W(new tt).setGroup(X),this.previousCameraViewMatrix=W(new tt)}setProjectionMatrix(t){this.projectionMatrix=t}update({frameId:t,camera:e,object:s}){const n=Sa(s);this.previousModelWorldMatrix.value.copy(n);const r=$l(e);r.frameId!==t&&(r.frameId=t,r.previousProjectionMatrix===void 0?(r.previousProjectionMatrix=new tt,r.previousCameraViewMatrix=new tt,r.currentProjectionMatrix=new tt,r.currentCameraViewMatrix=new tt,r.previousProjectionMatrix.copy(this.projectionMatrix||e.projectionMatrix),r.previousCameraViewMatrix.copy(e.matrixWorldInverse)):(r.previousProjectionMatrix.copy(r.currentProjectionMatrix),r.previousCameraViewMatrix.copy(r.currentCameraViewMatrix)),r.currentProjectionMatrix.copy(this.projectionMatrix||e.projectionMatrix),r.currentCameraViewMatrix.copy(e.matrixWorldInverse),this.previousProjectionMatrix.value.copy(r.previousProjectionMatrix),this.previousCameraViewMatrix.value.copy(r.previousCameraViewMatrix))}updateAfter({object:t}){Sa(t).copy(t.matrixWorld)}setup(){const t=this.projectionMatrix===null?bn:W(this.projectionMatrix),e=this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix),s=t.mul(js).mul(ct),n=this.previousProjectionMatrix.mul(e).mul(Mi),r=s.xy.div(s.w),o=n.xy.div(n.w);return H(r,o)}}function $l(i){let t=ba.get(i);return t===void 0&&(t={},ba.set(i,t)),t}function Sa(i,t=0){const e=$l(i);let s=e[t];return s===void 0&&(e[t]=s=new tt),s}const yy=C(gy),Yl=w(([i,t])=>Ht(1,i.oneMinus().div(t)).oneMinus()).setLayout({name:"blendBurn",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),Zl=w(([i,t])=>Ht(i.div(t.oneMinus()),1)).setLayout({name:"blendDodge",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),Jl=w(([i,t])=>i.oneMinus().mul(t.oneMinus()).oneMinus()).setLayout({name:"blendScreen",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),Ql=w(([i,t])=>at(i.mul(2).mul(t),i.oneMinus().mul(2).mul(t.oneMinus()).oneMinus(),Li(.5,i))).setLayout({name:"blendOverlay",type:"vec3",inputs:[{name:"base",type:"vec3"},{name:"blend",type:"vec3"}]}),xy=w(([i,t])=>{const e=t.a.add(i.a.mul(t.a.oneMinus()));return D(t.rgb.mul(t.a).add(i.rgb.mul(i.a).mul(t.a.oneMinus())).div(e),e)}).setLayout({name:"blendColor",type:"vec4",inputs:[{name:"base",type:"vec4"},{name:"blend",type:"vec4"}]}),Ny=(...i)=>(console.warn('THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.'),Yl(i)),Ty=(...i)=>(console.warn('THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.'),Zl(i)),vy=(...i)=>(console.warn('THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.'),Jl(i)),wy=(...i)=>(console.warn('THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.'),Ql(i)),My=w(([i])=>qi(i.rgb)),_y=w(([i,t=g(1)])=>t.mix(qi(i.rgb),i.rgb)),by=w(([i,t=g(1)])=>{const e=dt(i.r,i.g,i.b).div(3),s=i.r.max(i.g.max(i.b)),n=s.sub(e).mul(t).mul(-3);return at(i.rgb,s,n)}),Sy=w(([i,t=g(1)])=>{const e=T(.57735,.57735,.57735),s=t.cos();return T(i.rgb.mul(s).add(e.cross(i.rgb).mul(t.sin()).add(e.mul(Je(e,i.rgb).mul(s.oneMinus())))))}),qi=(i,t=T(ht.getLuminanceCoefficients(new S)))=>Je(i,t),Ay=(i,t)=>at(T(0),i,qi(i).sub(t).max(0)),Vy=w(([i,t=T(1),e=T(0),s=T(1),n=g(1),r=T(ht.getLuminanceCoefficients(new S,Er))])=>{const o=i.rgb.dot(T(r)),a=Mt(i.rgb.mul(t).add(e),0).toVar(),c=a.pow(s).toVar();return q(a.r.greaterThan(0),()=>{a.r.assign(c.r)}),q(a.g.greaterThan(0),()=>{a.g.assign(c.g)}),q(a.b.greaterThan(0),()=>{a.b.assign(c.b)}),a.assign(o.add(a.sub(o).mul(n))),D(a.rgb,i.a)});class zy extends pt{static get type(){return"PosterizeNode"}constructor(t,e){super(),this.sourceNode=t,this.stepsNode=e}setup(){const{sourceNode:t,stepsNode:e}=this;return t.mul(e).floor().div(e)}}const Cy=_(zy),Ry=new gt;class Kl extends Oe{static get type(){return"PassTextureNode"}constructor(t,e){super(e),this.passNode=t,this.setUpdateMatrix(!1)}setup(t){return t.object.isQuadMesh&&this.passNode.build(t),super.setup(t)}clone(){return new this.constructor(this.passNode,this.value)}}class Aa extends Kl{static get type(){return"PassMultipleTextureNode"}constructor(t,e,s=!1){super(t,null),this.textureName=e,this.previousTexture=s}updateTexture(){this.value=this.previousTexture?this.passNode.getPreviousTexture(this.textureName):this.passNode.getTexture(this.textureName)}setup(t){return this.updateTexture(),super.setup(t)}clone(){return new this.constructor(this.passNode,this.textureName,this.previousTexture)}}class xe extends pt{static get type(){return"PassNode"}constructor(t,e,s,n={}){super("vec4"),this.scope=t,this.scene=e,this.camera=s,this.options=n,this._pixelRatio=1,this._width=1,this._height=1;const r=new Nn;r.isRenderTargetTexture=!0,r.name="depth";const o=new Ci(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:dn,...n});o.texture.name="output",o.depthTexture=r,this.renderTarget=o,this.updateBeforeType=$.FRAME,this._textures={output:o.texture,depth:r},this._textureNodes={},this._linearDepthNodes={},this._viewZNodes={},this._previousTextures={},this._previousTextureNodes={},this._cameraNear=W(0),this._cameraFar=W(0),this._mrt=null,this.isPassNode=!0}setMRT(t){return this._mrt=t,this}getMRT(){return this._mrt}isGlobal(){return!0}getTexture(t){let e=this._textures[t];return e===void 0&&(e=this.renderTarget.texture.clone(),e.isRenderTargetTexture=!0,e.name=t,this._textures[t]=e,this.renderTarget.textures.push(e)),e}getPreviousTexture(t){let e=this._previousTextures[t];return e===void 0&&(e=this.getTexture(t).clone(),e.isRenderTargetTexture=!0,this._previousTextures[t]=e),e}toggleTexture(t){const e=this._previousTextures[t];if(e!==void 0){const s=this._textures[t],n=this.renderTarget.textures.indexOf(s);this.renderTarget.textures[n]=e,this._textures[t]=e,this._previousTextures[t]=s,this._textureNodes[t].updateTexture(),this._previousTextureNodes[t].updateTexture()}}getTextureNode(t="output"){let e=this._textureNodes[t];return e===void 0&&(e=V(new Aa(this,t)),e.updateTexture(),this._textureNodes[t]=e),e}getPreviousTextureNode(t="output"){let e=this._previousTextureNodes[t];return e===void 0&&(this._textureNodes[t]===void 0&&this.getTextureNode(t),e=V(new Aa(this,t,!0)),e.updateTexture(),this._previousTextureNodes[t]=e),e}getViewZNode(t="depth"){let e=this._viewZNodes[t];if(e===void 0){const s=this._cameraNear,n=this._cameraFar;this._viewZNodes[t]=e=So(this.getTextureNode(t),s,n)}return e}getLinearDepthNode(t="depth"){let e=this._linearDepthNodes[t];if(e===void 0){const s=this._cameraNear,n=this._cameraFar,r=this.getViewZNode(t);this._linearDepthNodes[t]=e=Ps(r,s,n)}return e}setup({renderer:t}){return this.renderTarget.samples=this.options.samples===void 0?t.samples:this.options.samples,t.backend.isWebGLBackend===!0&&(this.renderTarget.samples=0),this.renderTarget.depthTexture.isMultisampleRenderTargetTexture=this.renderTarget.samples>1,this.scope===xe.COLOR?this.getTextureNode():this.getLinearDepthNode()}updateBefore(t){const{renderer:e}=t,{scene:s,camera:n}=this;this._pixelRatio=e.getPixelRatio();const r=e.getSize(Ry);this.setSize(r.width,r.height);const o=e.getRenderTarget(),a=e.getMRT();this._cameraNear.value=n.near,this._cameraFar.value=n.far;for(const c in this._previousTextures)this.toggleTexture(c);e.setRenderTarget(this.renderTarget),e.setMRT(this._mrt),e.render(s,n),e.setRenderTarget(o),e.setMRT(a)}setSize(t,e){this._width=t,this._height=e;const s=this._width*this._pixelRatio,n=this._height*this._pixelRatio;this.renderTarget.setSize(s,n)}setPixelRatio(t){this._pixelRatio=t,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}xe.COLOR="color";xe.DEPTH="depth";const Ey=(i,t,e)=>V(new xe(xe.COLOR,i,t,e)),Fy=(i,t)=>V(new Kl(i,t)),Iy=(i,t)=>V(new xe(xe.DEPTH,i,t));class Oy extends xe{static get type(){return"ToonOutlinePassNode"}constructor(t,e,s,n,r){super(xe.COLOR,t,e),this.colorNode=s,this.thicknessNode=n,this.alphaNode=r,this._materialCache=new WeakMap}updateBefore(t){const{renderer:e}=t,s=e.getRenderObjectFunction();e.setRenderObjectFunction((n,r,o,a,c,h,l,d)=>{if((c.isMeshToonMaterial||c.isMeshToonNodeMaterial)&&c.wireframe===!1){const p=this._getOutlineMaterial(c);e.renderObject(n,r,o,a,p,h,l,d)}e.renderObject(n,r,o,a,c,h,l,d)}),super.updateBefore(t),e.setRenderObjectFunction(s)}_createMaterial(){const t=new gn;t.isMeshToonOutlineMaterial=!0,t.name="Toon_Outline",t.side=$r;const e=Pt.negate(),s=bn.mul(js),n=g(1),r=s.mul(D(ct,1)),o=s.mul(D(ct.add(e),1)),a=gs(r.sub(o));return t.vertexNode=r.add(a.mul(this.thicknessNode).mul(r.w).mul(n)),t.colorNode=D(this.colorNode,this.alphaNode),t}_getOutlineMaterial(t){let e=this._materialCache.get(t);return e===void 0&&(e=this._createMaterial(),this._materialCache.set(t,e)),e}}const Ly=(i,t,e=new Ye(0,0,0),s=.003,n=1)=>V(new Oy(i,t,V(e),V(s),V(n))),By=w(([i,t])=>i.mul(t).clamp()).setLayout({name:"linearToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),Py=w(([i,t])=>(i=i.mul(t),i.div(i.add(1)).clamp())).setLayout({name:"reinhardToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),Dy=w(([i,t])=>{i=i.mul(t),i=i.sub(.004).max(0);const e=i.mul(i.mul(6.2).add(.5)),s=i.mul(i.mul(6.2).add(1.7)).add(.06);return e.div(s).pow(2.2)}).setLayout({name:"cineonToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),ky=w(([i])=>{const t=i.mul(i.add(.0245786)).sub(90537e-9),e=i.mul(i.add(.432951).mul(.983729)).add(.238081);return t.div(e)}),Uy=w(([i,t])=>{const e=Kt(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),s=Kt(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return i=i.mul(t).div(.6),i=e.mul(i),i=ky(i),i=s.mul(i),i.clamp()}).setLayout({name:"acesFilmicToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),Wy=Kt(T(1.6605,-.1246,-.0182),T(-.5876,1.1329,-.1006),T(-.0728,-.0083,1.1187)),qy=Kt(T(.6274,.0691,.0164),T(.3293,.9195,.088),T(.0433,.0113,.8956)),Gy=w(([i])=>{const t=T(i).toVar(),e=T(t.mul(t)).toVar(),s=T(e.mul(e)).toVar();return g(15.5).mul(s.mul(e)).sub(k(40.14,s.mul(t))).add(k(31.96,s).sub(k(6.868,e.mul(t))).add(k(.4298,e).add(k(.1191,t).sub(.00232))))}),Hy=w(([i,t])=>{const e=T(i).toVar(),s=Kt(T(.856627153315983,.137318972929847,.11189821299995),T(.0951212405381588,.761241990602591,.0767994186031903),T(.0482516061458583,.101439036467562,.811302368396859)),n=Kt(T(1.1271005818144368,-.1413297634984383,-.14132976349843826),T(-.11060664309660323,1.157823702216272,-.11060664309660294),T(-.016493938717834573,-.016493938717834257,1.2519364065950405)),r=g(-12.47393),o=g(4.026069);return e.mulAssign(t),e.assign(qy.mul(e)),e.assign(s.mul(e)),e.assign(Mt(e,1e-10)),e.assign(Ce(e)),e.assign(e.sub(r).div(o.sub(r))),e.assign(Fe(e,0,1)),e.assign(Gy(e)),e.assign(n.mul(e)),e.assign(he(Mt(T(0),e),T(2.2))),e.assign(Wy.mul(e)),e.assign(Fe(e,0,1)),e}).setLayout({name:"agxToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),jy=w(([i,t])=>{const e=g(.76),s=g(.15);i=i.mul(t);const n=Ht(i.r,Ht(i.g,i.b)),r=Ot(n.lessThan(.08),n.sub(k(6.25,n.mul(n))),.04);i.subAssign(r);const o=Mt(i.r,Mt(i.g,i.b));q(o.lessThan(e),()=>i);const a=H(1,e),c=H(1,a.mul(a).div(o.add(a.sub(e))));i.mulAssign(c.div(o));const h=H(1,Ee(1,s.mul(o.sub(c)).add(1)));return at(i,T(c),h)}).setLayout({name:"neutralToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]});class xt extends L{static get type(){return"CodeNode"}constructor(t="",e=[],s=""){super("code"),this.isCodeNode=!0,this.code=t,this.language=s,this.includes=e}isGlobal(){return!0}setIncludes(t){return this.includes=t,this}getIncludes(){return this.includes}generate(t){const e=this.getIncludes(t);for(const n of e)n.build(t);const s=t.getCodeFromNode(this,this.getNodeType(t));return s.code=this.code,s.code}serialize(t){super.serialize(t),t.code=this.code,t.language=this.language}deserialize(t){super.deserialize(t),this.code=t.code,this.language=t.language}}const Gi=_(xt),Xy=(i,t)=>Gi(i,t,"js"),$y=(i,t)=>Gi(i,t,"wgsl"),Yy=(i,t)=>Gi(i,t,"glsl");class Zy extends xt{static get type(){return"FunctionNode"}constructor(t="",e=[],s=""){super(t,e,s)}getNodeType(t){return this.getNodeFunction(t).type}getInputs(t){return this.getNodeFunction(t).inputs}getNodeFunction(t){const e=t.getDataFromNode(this);let s=e.nodeFunction;return s===void 0&&(s=t.parser.parseFunction(this.code),e.nodeFunction=s),s}generate(t,e){super.generate(t);const s=this.getNodeFunction(t),n=s.name,r=s.type,o=t.getCodeFromNode(this,r);n!==""&&(o.name=n);const a=t.getPropertyName(o),c=this.getNodeFunction(t).getCode(a);return o.code=c+`
`,e==="property"?a:t.format(`${a}()`,r,e)}}const tu=(i,t=[],e="")=>{for(let r=0;r<t.length;r++){const o=t[r];typeof o=="function"&&(t[r]=o.functionNode)}const s=V(new Zy(i,t,e)),n=(...r)=>s.call(...r);return n.functionNode=s,n},Jy=(i,t)=>tu(i,t,"glsl"),Qy=(i,t)=>tu(i,t,"wgsl");class Ky extends L{static get type(){return"ScriptableValueNode"}constructor(t=null){super(),this._value=t,this._cache=null,this.inputType=null,this.outpuType=null,this.events=new ps,this.isScriptableValueNode=!0}get isScriptableOutputNode(){return this.outputType!==null}set value(t){this._value!==t&&(this._cache&&this.inputType==="URL"&&this.value.value instanceof ArrayBuffer&&(URL.revokeObjectURL(this._cache),this._cache=null),this._value=t,this.events.dispatchEvent({type:"change"}),this.refresh())}get value(){return this._value}refresh(){this.events.dispatchEvent({type:"refresh"})}getValue(){const t=this.value;if(t&&this._cache===null&&this.inputType==="URL"&&t.value instanceof ArrayBuffer)this._cache=URL.createObjectURL(new Blob([t.value]));else if(t&&t.value!==null&&t.value!==void 0&&((this.inputType==="URL"||this.inputType==="String")&&typeof t.value=="string"||this.inputType==="Number"&&typeof t.value=="number"||this.inputType==="Vector2"&&t.value.isVector2||this.inputType==="Vector3"&&t.value.isVector3||this.inputType==="Vector4"&&t.value.isVector4||this.inputType==="Color"&&t.value.isColor||this.inputType==="Matrix3"&&t.value.isMatrix3||this.inputType==="Matrix4"&&t.value.isMatrix4))return t.value;return this._cache||t}getNodeType(t){return this.value&&this.value.isNode?this.value.getNodeType(t):"float"}setup(){return this.value&&this.value.isNode?this.value:g()}serialize(t){super.serialize(t),this.value!==null?this.inputType==="ArrayBuffer"?t.value=Xa(this.value):t.value=this.value?this.value.toJSON(t.meta).uuid:null:t.value=null,t.inputType=this.inputType,t.outputType=this.outputType}deserialize(t){super.deserialize(t);let e=null;t.value!==null&&(t.inputType==="ArrayBuffer"?e=$a(t.value):t.inputType==="Texture"?e=t.meta.textures[t.value]:e=t.meta.nodes[t.value]||null),this.value=e,this.inputType=t.inputType,this.outputType=t.outputType}}const mi=_(Ky);class eu extends Map{get(t,e=null,...s){if(this.has(t))return super.get(t);if(e!==null){const n=e(...s);return this.set(t,n),n}}}class tx{constructor(t){this.scriptableNode=t}get parameters(){return this.scriptableNode.parameters}get layout(){return this.scriptableNode.getLayout()}getInputLayout(t){return this.scriptableNode.getInputLayout(t)}get(t){const e=this.parameters[t];return e?e.getValue():null}}const fi=new eu;class ex extends L{static get type(){return"ScriptableNode"}constructor(t=null,e={}){super(),this.codeNode=t,this.parameters=e,this._local=new eu,this._output=mi(),this._outputs={},this._source=this.source,this._method=null,this._object=null,this._value=null,this._needsOutputUpdate=!0,this.onRefresh=this.onRefresh.bind(this),this.isScriptableNode=!0}get source(){return this.codeNode?this.codeNode.code:""}setLocal(t,e){return this._local.set(t,e)}getLocal(t){return this._local.get(t)}onRefresh(){this._refresh()}getInputLayout(t){for(const e of this.getLayout())if(e.inputType&&(e.id===t||e.name===t))return e}getOutputLayout(t){for(const e of this.getLayout())if(e.outputType&&(e.id===t||e.name===t))return e}setOutput(t,e){const s=this._outputs;return s[t]===void 0?s[t]=mi(e):s[t].value=e,this}getOutput(t){return this._outputs[t]}getParameter(t){return this.parameters[t]}setParameter(t,e){const s=this.parameters;return e&&e.isScriptableNode?(this.deleteParameter(t),s[t]=e,s[t].getDefaultOutput().events.addEventListener("refresh",this.onRefresh)):e&&e.isScriptableValueNode?(this.deleteParameter(t),s[t]=e,s[t].events.addEventListener("refresh",this.onRefresh)):s[t]===void 0?(s[t]=mi(e),s[t].events.addEventListener("refresh",this.onRefresh)):s[t].value=e,this}getValue(){return this.getDefaultOutput().getValue()}deleteParameter(t){let e=this.parameters[t];return e&&(e.isScriptableNode&&(e=e.getDefaultOutput()),e.events.removeEventListener("refresh",this.onRefresh)),this}clearParameters(){for(const t of Object.keys(this.parameters))this.deleteParameter(t);return this.needsUpdate=!0,this}call(t,...e){const n=this.getObject()[t];if(typeof n=="function")return n(...e)}async callAsync(t,...e){const n=this.getObject()[t];if(typeof n=="function")return n.constructor.name==="AsyncFunction"?await n(...e):n(...e)}getNodeType(t){return this.getDefaultOutputNode().getNodeType(t)}refresh(t=null){t!==null?this.getOutput(t).refresh():this._refresh()}getObject(){if(this.needsUpdate&&this.dispose(),this._object!==null)return this._object;const t=()=>this.refresh(),e=(h,l)=>this.setOutput(h,l),s=new tx(this),n=fi.get("THREE"),r=fi.get("TSL"),o=this.getMethod(this.codeNode),a=[s,this._local,fi,t,e,n,r];this._object=o(...a);const c=this._object.layout;if(c&&(c.cache===!1&&this._local.clear(),this._output.outputType=c.outputType||null,Array.isArray(c.elements)))for(const h of c.elements){const l=h.id||h.name;h.inputType&&(this.getParameter(l)===void 0&&this.setParameter(l,null),this.getParameter(l).inputType=h.inputType),h.outputType&&(this.getOutput(l)===void 0&&this.setOutput(l,null),this.getOutput(l).outputType=h.outputType)}return this._object}deserialize(t){super.deserialize(t);for(const e in this.parameters){let s=this.parameters[e];s.isScriptableNode&&(s=s.getDefaultOutput()),s.events.addEventListener("refresh",this.onRefresh)}}getLayout(){return this.getObject().layout}getDefaultOutputNode(){const t=this.getDefaultOutput().value;return t&&t.isNode?t:g()}getDefaultOutput(){return this._exec()._output}getMethod(){if(this.needsUpdate&&this.dispose(),this._method!==null)return this._method;const t=["parameters","local","global","refresh","setOutput","THREE","TSL"],s=["layout","init","main","dispose"].join(", "),n="var "+s+`; var output = {};
`,r=`
return { ...output, `+s+" };",o=n+this.codeNode.code+r;return this._method=new Function(...t,o),this._method}dispose(){this._method!==null&&(this._object&&typeof this._object.dispose=="function"&&this._object.dispose(),this._method=null,this._object=null,this._source=null,this._value=null,this._needsOutputUpdate=!0,this._output.value=null,this._outputs={})}setup(){return this.getDefaultOutputNode()}getCacheKey(t){const e=[_d(this.source),this.getDefaultOutputNode().getCacheKey(t)];for(const s in this.parameters)e.push(this.parameters[s].getCacheKey(t));return bd(e)}set needsUpdate(t){t===!0&&this.dispose()}get needsUpdate(){return this.source!==this._source}_exec(){return this.codeNode===null?this:(this._needsOutputUpdate===!0&&(this._value=this.call("main"),this._needsOutputUpdate=!1),this._output.value=this._value,this)}_refresh(){this.needsUpdate=!0,this._exec(),this._output.refresh()}}const sx=_(ex);class Co extends L{static get type(){return"FogNode"}constructor(t,e){super("float"),this.isFogNode=!0,this.colorNode=t,this.factorNode=e}getViewZNode(t){let e;const s=t.context.getViewZ;return s!==void 0&&(e=s(this)),(e||wt.z).negate()}setup(){return this.factorNode}}const nx=_(Co);class ix extends Co{static get type(){return"FogRangeNode"}constructor(t,e,s){super(t),this.isFogRangeNode=!0,this.nearNode=e,this.farNode=s}setup(t){const e=this.getViewZNode(t);return qs(this.nearNode,this.farNode,e)}}const rx=_(ix);class ox extends Co{static get type(){return"FogExp2Node"}constructor(t,e){super(t),this.isFogExp2Node=!0,this.densityNode=e}setup(t){const e=this.getViewZNode(t),s=this.densityNode;return s.mul(s,e,e).negate().exp().oneMinus()}}const ax=_(ox);let ns=null,is=null;class cx extends L{static get type(){return"RangeNode"}constructor(t=g(),e=g()){super(),this.minNode=t,this.maxNode=e}getVectorLength(t){const e=t.getTypeLength($e(this.minNode.value)),s=t.getTypeLength($e(this.maxNode.value));return e>s?e:s}getNodeType(t){return t.object.count>1?t.getTypeFromLength(this.getVectorLength(t)):"float"}setup(t){const e=t.object;let s=null;if(e.count>1){const n=this.minNode.value,r=this.maxNode.value,o=t.getTypeLength($e(n)),a=t.getTypeLength($e(r));ns=ns||new It,is=is||new It,ns.setScalar(0),is.setScalar(0),o===1?ns.setScalar(n):n.isColor?ns.set(n.r,n.g,n.b):ns.set(n.x,n.y,n.z||0,n.w||0),a===1?is.setScalar(r):r.isColor?is.set(r.r,r.g,r.b):is.set(r.x,r.y,r.z||0,r.w||0);const c=4,h=c*e.count,l=new Float32Array(h);for(let p=0;p<h;p++){const m=p%c,f=ns.getComponent(m),x=is.getComponent(m);l[p]=Ba.lerp(f,x,Math.random())}const d=this.getNodeType(t);if(e.count<=4096)s=An(l,"vec4",e.count).element(Rn).convert(d);else{const p=new Qr(l,4);t.geometry.setAttribute("__range"+this.id,p),s=wi(p).convert(d)}}else s=g(0);return s}}const hx=_(cx);class lx extends L{static get type(){return"ComputeBuiltinNode"}constructor(t,e){super(e),this._builtinName=t}getHash(t){return this.getBuiltinName(t)}getNodeType(){return this.nodeType}setBuiltinName(t){return this._builtinName=t,this}getBuiltinName(){return this._builtinName}hasBuiltin(t){t.hasBuiltin(this._builtinName)}generate(t,e){const s=this.getBuiltinName(t),n=this.getNodeType(t);return t.shaderStage==="compute"?t.format(s,n,e):(console.warn(`ComputeBuiltinNode: Compute built-in value ${s} can not be accessed in the ${t.shaderStage} stage`),t.generateConst(n))}serialize(t){super.serialize(t),t.global=this.global,t._builtinName=this._builtinName}deserialize(t){super.deserialize(t),this.global=t.global,this._builtinName=t._builtinName}}const Hi=(i,t)=>V(new lx(i,t)),ux=Hi("numWorkgroups","uvec3"),dx=Hi("workgroupId","uvec3"),px=Hi("localId","uvec3"),mx=Hi("subgroupSize","uint");class fx extends L{constructor(t){super(),this.scope=t}generate(t){const{scope:e}=this,{renderer:s}=t;s.backend.isWebGLBackend===!0?t.addFlowCode(`	// ${e}Barrier 
`):t.addLineFlowCode(`${e}Barrier()`,this)}}const Ro=_(fx),gx=()=>Ro("workgroup").append(),yx=()=>Ro("storage").append(),xx=()=>Ro("texture").append();class Nx extends fs{constructor(t,e){super(t,e),this.isWorkgroupInfoElementNode=!0}generate(t,e){let s;const n=t.context.assign;if(s=super.generate(t),n!==!0){const r=this.getNodeType(t);s=t.format(s,r,e)}return s}}class Tx extends L{constructor(t,e,s=0){super(e),this.bufferType=e,this.bufferCount=s,this.isWorkgroupInfoNode=!0,this.scope=t}label(t){return this.name=t,this}getHash(){return this.uuid}setScope(t){return this.scope=t,this}getInputType(){return`${this.scope}Array`}element(t){return V(new Nx(this,t))}generate(t){return t.getScopedArray(this.name||`${this.scope}Array_${this.id}`,this.scope.toLowerCase(),this.bufferType,this.bufferCount)}}const vx=(i,t)=>V(new Tx("Workgroup",i,t));class _t extends pt{static get type(){return"AtomicFunctionNode"}constructor(t,e,s,n=null){super("uint"),this.method=t,this.pointerNode=e,this.valueNode=s,this.storeNode=n}getInputType(t){return this.pointerNode.getNodeType(t)}getNodeType(t){return this.getInputType(t)}generate(t){const e=this.method,s=this.getNodeType(t),n=this.getInputType(t),r=this.pointerNode,o=this.valueNode,a=[];a.push(`&${r.build(t,n)}`),a.push(o.build(t,n));const c=`${t.getMethod(e,s)}( ${a.join(", ")} )`;if(this.storeNode!==null){const h=this.storeNode.build(t,n);t.addLineFlowCode(`${h} = ${c}`,this)}else t.addLineFlowCode(c,this)}}_t.ATOMIC_LOAD="atomicLoad";_t.ATOMIC_STORE="atomicStore";_t.ATOMIC_ADD="atomicAdd";_t.ATOMIC_SUB="atomicSub";_t.ATOMIC_MAX="atomicMax";_t.ATOMIC_MIN="atomicMin";_t.ATOMIC_AND="atomicAnd";_t.ATOMIC_OR="atomicOr";_t.ATOMIC_XOR="atomicXor";const wx=_(_t),Pe=(i,t,e,s)=>{const n=wx(i,t,e,s);return n.append(),n},Mx=(i,t,e=null)=>Pe(_t.ATOMIC_STORE,i,t,e),_x=(i,t,e=null)=>Pe(_t.ATOMIC_ADD,i,t,e),bx=(i,t,e=null)=>Pe(_t.ATOMIC_SUB,i,t,e),Sx=(i,t,e=null)=>Pe(_t.ATOMIC_MAX,i,t,e),Ax=(i,t,e=null)=>Pe(_t.ATOMIC_MIN,i,t,e),Vx=(i,t,e=null)=>Pe(_t.ATOMIC_AND,i,t,e),zx=(i,t,e=null)=>Pe(_t.ATOMIC_OR,i,t,e),Cx=(i,t,e=null)=>Pe(_t.ATOMIC_XOR,i,t,e);let ui;function Fn(i){ui=ui||new WeakMap;let t=ui.get(i);return t===void 0&&ui.set(i,t={}),t}function Eo(i){const t=Fn(i);return t.shadowMatrix||(t.shadowMatrix=W("mat4").setGroup(X).onRenderUpdate(()=>(i.shadow.updateMatrices(i),i.shadow.matrix)))}function Rx(i){const t=Fn(i);if(t.projectionUV===void 0){const e=Eo(i).mul(ds);t.projectionUV=e.xyz.div(e.w)}return t.projectionUV}function su(i){const t=Fn(i);return t.position||(t.position=W(new S).setGroup(X).onRenderUpdate((e,s)=>s.value.setFromMatrixPosition(i.matrixWorld)))}function nu(i){const t=Fn(i);return t.targetPosition||(t.targetPosition=W(new S).setGroup(X).onRenderUpdate((e,s)=>s.value.setFromMatrixPosition(i.target.matrixWorld)))}function Ex(i){const t=Fn(i);return t.viewPosition||(t.viewPosition=W(new S).setGroup(X).onRenderUpdate(({camera:e},s)=>{s.value=s.value||new S,s.value.setFromMatrixPosition(i.matrixWorld),s.value.applyMatrix4(e.matrixWorldInverse)}))}const Fx=i=>ee.transformDirection(su(i).sub(nu(i))),Ix=i=>i.sort((t,e)=>t.id-e.id),Ox=(i,t)=>{for(const e of t)if(e.isAnalyticLightNode&&e.light.id===i)return e;return null},Sr=new WeakMap;class Lx extends L{static get type(){return"LightsNode"}constructor(){super("vec3"),this.totalDiffuseNode=T().toVar("totalDiffuse"),this.totalSpecularNode=T().toVar("totalSpecular"),this.outgoingLightNode=T().toVar("outgoingLight"),this._lights=[],this._lightNodes=null,this._lightNodesHash=null,this.global=!0}getHash(t){if(this._lightNodesHash===null){this._lightNodes===null&&this.setupLightsNode(t);const e=[];for(const s of this._lightNodes)e.push(s.getSelf().getHash());this._lightNodesHash="lights-"+e.join(",")}return this._lightNodesHash}analyze(t){const e=t.getDataFromNode(this);for(const s of e.nodes)s.build(t)}setupLightsNode(t){const e=[],s=this._lightNodes,n=Ix(this._lights),r=t.renderer.library;for(const o of n)if(o.isNode)e.push(V(o));else{let a=null;if(s!==null&&(a=Ox(o.id,s)),a===null){const c=r.getLightNodeClass(o.constructor);if(c===null){console.warn(`LightsNode.setupNodeLights: Light node not found for ${o.constructor.name}`);continue}let h=null;Sr.has(o)?h=Sr.get(o):(h=V(new c(o)),Sr.set(o,h)),e.push(h)}}this._lightNodes=e}setupLights(t,e){for(const s of e)s.build(t)}setup(t){this._lightNodes===null&&this.setupLightsNode(t);const e=t.context,s=e.lightingModel;let n=this.outgoingLightNode;if(s){const{_lightNodes:r,totalDiffuseNode:o,totalSpecularNode:a}=this;e.outgoingLight=n;const c=t.addStack(),h=t.getDataFromNode(this);h.nodes=c.nodes,s.start(e,c,t),this.setupLights(t,r),s.indirect(e,c,t);const{backdrop:l,backdropAlpha:d}=e,{directDiffuse:p,directSpecular:m,indirectDiffuse:f,indirectSpecular:x}=e.reflectedLight;let v=p.add(f);l!==null&&(d!==null?v=T(d.mix(v,l)):v=T(l),e.material.transparent=!0),o.assign(v),a.assign(m.add(x)),n.assign(o.add(a)),s.finish(e,c,t),n=n.bypass(t.removeStack())}return n}setLights(t){return this._lights=t,this._lightNodes=null,this._lightNodesHash=null,this}getLights(){return this._lights}get hasLights(){return this._lights.length>0}}const Bx=(i=[])=>V(new Lx).setLights(i),Va=new WeakMap,za=T().toVar("shadowWorldPosition"),Px=w(([i,t,e])=>{let s=ds.sub(i).length();return s=s.sub(t).div(e.sub(t)),s=s.saturate(),s}),Dx=i=>{const t=i.shadow.camera,e=lt("near","float",t).setGroup(X),s=lt("far","float",t).setGroup(X),n=Uh(i);return Px(n,e,s)},kx=i=>{let t=Va.get(i);if(t===void 0){const e=i.isPointLight?Dx(i):null;t=new gn,t.colorNode=D(0,0,0,1),t.depthNode=e,t.isShadowNodeMaterial=!0,t.blending=Tu,t.name="ShadowMaterial",Va.set(i,t)}return t},iu=w(({depthTexture:i,shadowCoord:t})=>Ft(i,t.xy).compare(t.z)),ru=w(({depthTexture:i,shadowCoord:t,shadow:e})=>{const s=(x,v)=>Ft(i,x).compare(v),n=lt("mapSize","vec2",e).setGroup(X),r=lt("radius","float",e).setGroup(X),o=z(1).div(n),a=o.x.negate().mul(r),c=o.y.negate().mul(r),h=o.x.mul(r),l=o.y.mul(r),d=a.div(2),p=c.div(2),m=h.div(2),f=l.div(2);return dt(s(t.xy.add(z(a,c)),t.z),s(t.xy.add(z(0,c)),t.z),s(t.xy.add(z(h,c)),t.z),s(t.xy.add(z(d,p)),t.z),s(t.xy.add(z(0,p)),t.z),s(t.xy.add(z(m,p)),t.z),s(t.xy.add(z(a,0)),t.z),s(t.xy.add(z(d,0)),t.z),s(t.xy,t.z),s(t.xy.add(z(m,0)),t.z),s(t.xy.add(z(h,0)),t.z),s(t.xy.add(z(d,f)),t.z),s(t.xy.add(z(0,f)),t.z),s(t.xy.add(z(m,f)),t.z),s(t.xy.add(z(a,l)),t.z),s(t.xy.add(z(0,l)),t.z),s(t.xy.add(z(h,l)),t.z)).mul(1/17)}),ou=w(({depthTexture:i,shadowCoord:t,shadow:e})=>{const s=(l,d)=>Ft(i,l).compare(d),n=lt("mapSize","vec2",e).setGroup(X),r=z(1).div(n),o=r.x,a=r.y,c=t.xy,h=Be(c.mul(n).add(.5));return c.subAssign(h.mul(r)),dt(s(c,t.z),s(c.add(z(o,0)),t.z),s(c.add(z(0,a)),t.z),s(c.add(r),t.z),at(s(c.add(z(o.negate(),0)),t.z),s(c.add(z(o.mul(2),0)),t.z),h.x),at(s(c.add(z(o.negate(),a)),t.z),s(c.add(z(o.mul(2),a)),t.z),h.x),at(s(c.add(z(0,a.negate())),t.z),s(c.add(z(0,a.mul(2))),t.z),h.y),at(s(c.add(z(o,a.negate())),t.z),s(c.add(z(o,a.mul(2))),t.z),h.y),at(at(s(c.add(z(o.negate(),a.negate())),t.z),s(c.add(z(o.mul(2),a.negate())),t.z),h.x),at(s(c.add(z(o.negate(),a.mul(2))),t.z),s(c.add(z(o.mul(2),a.mul(2))),t.z),h.x),h.y)).mul(1/9)}),au=w(({depthTexture:i,shadowCoord:t})=>{const e=g(1).toVar(),s=Ft(i).uv(t.xy).rg,n=Li(t.z,s.x);return q(n.notEqual(g(1)),()=>{const r=t.z.sub(s.x),o=Mt(0,s.y.mul(s.y));let a=o.div(o.add(r.mul(r)));a=Fe(H(a,.3).div(.95-.3)),e.assign(Fe(Mt(n,a)))}),e}),Ux=w(({samples:i,radius:t,size:e,shadowPass:s})=>{const n=g(0).toVar(),r=g(0).toVar(),o=i.lessThanEqual(g(1)).select(g(0),g(2).div(i.sub(1))),a=i.lessThanEqual(g(1)).select(g(0),g(-1));K({start:y(0),end:y(i),type:"int",condition:"<"},({i:h})=>{const l=a.add(g(h).mul(o)),d=s.uv(dt(En.xy,z(0,l).mul(t)).div(e)).x;n.addAssign(d),r.addAssign(d.mul(d))}),n.divAssign(i),r.divAssign(i);const c=Ne(r.sub(n.mul(n)));return z(n,c)}),Wx=w(({samples:i,radius:t,size:e,shadowPass:s})=>{const n=g(0).toVar(),r=g(0).toVar(),o=i.lessThanEqual(g(1)).select(g(0),g(2).div(i.sub(1))),a=i.lessThanEqual(g(1)).select(g(0),g(-1));K({start:y(0),end:y(i),type:"int",condition:"<"},({i:h})=>{const l=a.add(g(h).mul(o)),d=s.uv(dt(En.xy,z(l,0).mul(t)).div(e));n.addAssign(d.x),r.addAssign(dt(d.y.mul(d.y),d.x.mul(d.x)))}),n.divAssign(i),r.divAssign(i);const c=Ne(r.sub(n.mul(n)));return z(n,c)}),qx=[iu,ru,ou,au],di=new Hl;class Gx extends L{static get type(){return"ShadowNode"}constructor(t,e=null){super(),this.light=t,this.shadow=e||t.shadow,this.shadowMap=null,this.vsmShadowMapVertical=null,this.vsmShadowMapHorizontal=null,this.vsmMaterialVertical=null,this.vsmMaterialHorizontal=null,this.updateBeforeType=$.RENDER,this._node=null,this.isShadowNode=!0}setupShadowFilter(t,{filterFn:e,depthTexture:s,shadowCoord:n,shadow:r}){const o=n.x.greaterThanEqual(0).and(n.x.lessThanEqual(1)).and(n.y.greaterThanEqual(0)).and(n.y.lessThanEqual(1)).and(n.z.lessThanEqual(1)),a=e({depthTexture:s,shadowCoord:n,shadow:r});return o.select(a,g(1))}setupShadowCoord(t,e){const{shadow:s}=this,{renderer:n}=t,r=lt("bias","float",s).setGroup(X);let o=e,a;if(s.camera.isOrthographicCamera||n.logarithmicDepthBuffer!==!0)o=o.xyz.div(o.w),a=o.z,n.coordinateSystem===ks&&(a=a.mul(2).sub(1));else{const c=o.w;o=o.xy.div(c);const h=lt("near","float",s.camera).setGroup(X),l=lt("far","float",s.camera).setGroup(X);a=Ao(c.negate(),h,l)}return o=T(o.x,o.y.oneMinus(),a.add(r)),o}getShadowFilterFn(t){return qx[t]}setupShadow(t){const{renderer:e}=t,{light:s,shadow:n}=this,r=e.shadowMap.type,o=new Nn(n.mapSize.width,n.mapSize.height);o.compareFunction=Ru;const a=t.createRenderTarget(n.mapSize.width,n.mapSize.height);if(a.depthTexture=o,n.camera.updateProjectionMatrix(),r===Wn){o.compareFunction=null,this.vsmShadowMapVertical=t.createRenderTarget(n.mapSize.width,n.mapSize.height,{format:qo,type:dn}),this.vsmShadowMapHorizontal=t.createRenderTarget(n.mapSize.width,n.mapSize.height,{format:qo,type:dn});const A=Ft(o),F=Ft(this.vsmShadowMapVertical.texture),O=lt("blurSamples","float",n).setGroup(X),E=lt("radius","float",n).setGroup(X),B=lt("mapSize","vec2",n).setGroup(X);let P=this.vsmMaterialVertical||(this.vsmMaterialVertical=new gn);P.fragmentNode=Ux({samples:O,radius:E,size:B,shadowPass:A}).context(t.getSharedContext()),P.name="VSMVertical",P=this.vsmMaterialHorizontal||(this.vsmMaterialHorizontal=new gn),P.fragmentNode=Wx({samples:O,radius:E,size:B,shadowPass:F}).context(t.getSharedContext()),P.name="VSMHorizontal"}const c=lt("intensity","float",n).setGroup(X),h=lt("normalBias","float",n).setGroup(X),l=Eo(s).mul(za.add(Xh.mul(h))),d=this.setupShadowCoord(t,l),p=n.filterNode||this.getShadowFilterFn(e.shadowMap.type)||null;if(p===null)throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");const m=r===Wn?this.vsmShadowMapHorizontal.texture:o,f=this.setupShadowFilter(t,{filterFn:p,shadowTexture:a.texture,depthTexture:m,shadowCoord:d,shadow:n}),x=Ft(a.texture,d),v=at(1,f.rgb.mix(x,1),c.mul(x.a)).toVar();return this.shadowMap=a,this.shadow.map=a,v}setup(t){if(t.renderer.shadowMap.enabled!==!1)return w(({material:e})=>{za.assign(e.shadowPositionNode||ds);let s=this._node;return s===null&&(this._node=s=this.setupShadow(t)),t.material.shadowNode&&console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'),t.material.receivedShadowNode&&(s=t.material.receivedShadowNode(s)),s})()}renderShadow(t){const{shadow:e,shadowMap:s}=this,{renderer:n,scene:r}=t;s.setSize(e.mapSize.width,e.mapSize.height),n.render(r,e.camera)}updateShadow(t){const{shadowMap:e,light:s,shadow:n}=this,{renderer:r,scene:o,camera:a}=t,c=r.shadowMap.type,h=e.depthTexture.version;this._depthVersionCached=h;const l=o.overrideMaterial;o.overrideMaterial=kx(s),n.camera.layers.mask=a.layers.mask;const d=r.getRenderTarget(),p=r.getRenderObjectFunction(),m=r.getMRT();r.setMRT(null),r.setRenderObjectFunction((f,...x)=>{(f.castShadow===!0||f.receiveShadow&&c===Wn)&&r.renderObject(f,...x)}),r.setRenderTarget(e),this.renderShadow(t),r.setRenderObjectFunction(p),s.isPointLight!==!0&&c===Wn&&this.vsmPass(r),r.setRenderTarget(d),r.setMRT(m),o.overrideMaterial=l}vsmPass(t){const{shadow:e}=this;this.vsmShadowMapVertical.setSize(e.mapSize.width,e.mapSize.height),this.vsmShadowMapHorizontal.setSize(e.mapSize.width,e.mapSize.height),t.setRenderTarget(this.vsmShadowMapVertical),di.material=this.vsmMaterialVertical,di.render(t),t.setRenderTarget(this.vsmShadowMapHorizontal),di.material=this.vsmMaterialHorizontal,di.render(t)}dispose(){this.shadowMap.dispose(),this.shadowMap=null,this.vsmShadowMapVertical!==null&&(this.vsmShadowMapVertical.dispose(),this.vsmShadowMapVertical=null,this.vsmMaterialVertical.dispose(),this.vsmMaterialVertical=null),this.vsmShadowMapHorizontal!==null&&(this.vsmShadowMapHorizontal.dispose(),this.vsmShadowMapHorizontal=null,this.vsmMaterialHorizontal.dispose(),this.vsmMaterialHorizontal=null),this.updateBeforeType=$.NONE}updateBefore(t){const{shadow:e}=this;(e.needsUpdate||e.autoUpdate)&&(this.updateShadow(t),this.shadowMap.depthTexture.version===this._depthVersionCached&&(e.needsUpdate=!1))}}const Hx=(i,t)=>V(new Gx(i,t)),cu=w(i=>{const{lightDistance:t,cutoffDistance:e,decayExponent:s}=i,n=t.pow(s).max(.01).reciprocal();return e.greaterThan(0).select(n.mul(t.div(e).pow4().oneMinus().clamp().pow2()),n)}),jx=w(({color:i,lightViewPosition:t,cutoffDistance:e,decayExponent:s},n)=>{const r=n.context.lightingModel,o=t.sub(wt),a=o.normalize(),c=o.length(),h=cu({lightDistance:c,cutoffDistance:e,decayExponent:s}),l=i.mul(h),d=n.context.reflectedLight;r.direct({lightDirection:a,lightColor:l,reflectedLight:d},n.stack,n)}),Xx=w(([i=rt()])=>{const t=i.mul(2),e=t.x.floor(),s=t.y.floor();return e.add(s).mod(2).sign()}),un=w(([i,t,e])=>{const s=g(e).toVar(),n=g(t).toVar(),r=Re(i).toVar();return Ot(r,n,s)}).setLayout({name:"mx_select",type:"float",inputs:[{name:"b",type:"bool"},{name:"t",type:"float"},{name:"f",type:"float"}]}),Vi=w(([i,t])=>{const e=Re(t).toVar(),s=g(i).toVar();return Ot(e,s.negate(),s)}).setLayout({name:"mx_negate_if",type:"float",inputs:[{name:"val",type:"float"},{name:"b",type:"bool"}]}),ut=w(([i])=>{const t=g(i).toVar();return y(me(t))}).setLayout({name:"mx_floor",type:"int",inputs:[{name:"x",type:"float"}]}),nt=w(([i,t])=>{const e=g(i).toVar();return t.assign(ut(e)),e.sub(g(t))}),$x=w(([i,t,e,s,n,r])=>{const o=g(r).toVar(),a=g(n).toVar(),c=g(s).toVar(),h=g(e).toVar(),l=g(t).toVar(),d=g(i).toVar(),p=g(H(1,a)).toVar();return H(1,o).mul(d.mul(p).add(l.mul(a))).add(o.mul(h.mul(p).add(c.mul(a))))}).setLayout({name:"mx_bilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"}]}),Yx=w(([i,t,e,s,n,r])=>{const o=g(r).toVar(),a=g(n).toVar(),c=T(s).toVar(),h=T(e).toVar(),l=T(t).toVar(),d=T(i).toVar(),p=g(H(1,a)).toVar();return H(1,o).mul(d.mul(p).add(l.mul(a))).add(o.mul(h.mul(p).add(c.mul(a))))}).setLayout({name:"mx_bilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"}]}),hu=bt([$x,Yx]),Zx=w(([i,t,e,s,n,r,o,a,c,h,l])=>{const d=g(l).toVar(),p=g(h).toVar(),m=g(c).toVar(),f=g(a).toVar(),x=g(o).toVar(),v=g(r).toVar(),A=g(n).toVar(),F=g(s).toVar(),O=g(e).toVar(),E=g(t).toVar(),B=g(i).toVar(),P=g(H(1,m)).toVar(),I=g(H(1,p)).toVar();return g(H(1,d)).toVar().mul(I.mul(B.mul(P).add(E.mul(m))).add(p.mul(O.mul(P).add(F.mul(m))))).add(d.mul(I.mul(A.mul(P).add(v.mul(m))).add(p.mul(x.mul(P).add(f.mul(m))))))}).setLayout({name:"mx_trilerp_0",type:"float",inputs:[{name:"v0",type:"float"},{name:"v1",type:"float"},{name:"v2",type:"float"},{name:"v3",type:"float"},{name:"v4",type:"float"},{name:"v5",type:"float"},{name:"v6",type:"float"},{name:"v7",type:"float"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]}),Jx=w(([i,t,e,s,n,r,o,a,c,h,l])=>{const d=g(l).toVar(),p=g(h).toVar(),m=g(c).toVar(),f=T(a).toVar(),x=T(o).toVar(),v=T(r).toVar(),A=T(n).toVar(),F=T(s).toVar(),O=T(e).toVar(),E=T(t).toVar(),B=T(i).toVar(),P=g(H(1,m)).toVar(),I=g(H(1,p)).toVar();return g(H(1,d)).toVar().mul(I.mul(B.mul(P).add(E.mul(m))).add(p.mul(O.mul(P).add(F.mul(m))))).add(d.mul(I.mul(A.mul(P).add(v.mul(m))).add(p.mul(x.mul(P).add(f.mul(m))))))}).setLayout({name:"mx_trilerp_1",type:"vec3",inputs:[{name:"v0",type:"vec3"},{name:"v1",type:"vec3"},{name:"v2",type:"vec3"},{name:"v3",type:"vec3"},{name:"v4",type:"vec3"},{name:"v5",type:"vec3"},{name:"v6",type:"vec3"},{name:"v7",type:"vec3"},{name:"s",type:"float"},{name:"t",type:"float"},{name:"r",type:"float"}]}),lu=bt([Zx,Jx]),Qx=w(([i,t,e])=>{const s=g(e).toVar(),n=g(t).toVar(),r=R(i).toVar(),o=R(r.bitAnd(R(7))).toVar(),a=g(un(o.lessThan(R(4)),n,s)).toVar(),c=g(k(2,un(o.lessThan(R(4)),s,n))).toVar();return Vi(a,Re(o.bitAnd(R(1)))).add(Vi(c,Re(o.bitAnd(R(2)))))}).setLayout({name:"mx_gradient_float_0",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"}]}),Kx=w(([i,t,e,s])=>{const n=g(s).toVar(),r=g(e).toVar(),o=g(t).toVar(),a=R(i).toVar(),c=R(a.bitAnd(R(15))).toVar(),h=g(un(c.lessThan(R(8)),o,r)).toVar(),l=g(un(c.lessThan(R(4)),r,un(c.equal(R(12)).or(c.equal(R(14))),o,n))).toVar();return Vi(h,Re(c.bitAnd(R(1)))).add(Vi(l,Re(c.bitAnd(R(2)))))}).setLayout({name:"mx_gradient_float_1",type:"float",inputs:[{name:"hash",type:"uint"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]}),vt=bt([Qx,Kx]),t0=w(([i,t,e])=>{const s=g(e).toVar(),n=g(t).toVar(),r=Hs(i).toVar();return T(vt(r.x,n,s),vt(r.y,n,s),vt(r.z,n,s))}).setLayout({name:"mx_gradient_vec3_0",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"}]}),e0=w(([i,t,e,s])=>{const n=g(s).toVar(),r=g(e).toVar(),o=g(t).toVar(),a=Hs(i).toVar();return T(vt(a.x,o,r,n),vt(a.y,o,r,n),vt(a.z,o,r,n))}).setLayout({name:"mx_gradient_vec3_1",type:"vec3",inputs:[{name:"hash",type:"uvec3"},{name:"x",type:"float"},{name:"y",type:"float"},{name:"z",type:"float"}]}),$t=bt([t0,e0]),s0=w(([i])=>{const t=g(i).toVar();return k(.6616,t)}).setLayout({name:"mx_gradient_scale2d_0",type:"float",inputs:[{name:"v",type:"float"}]}),n0=w(([i])=>{const t=g(i).toVar();return k(.982,t)}).setLayout({name:"mx_gradient_scale3d_0",type:"float",inputs:[{name:"v",type:"float"}]}),i0=w(([i])=>{const t=T(i).toVar();return k(.6616,t)}).setLayout({name:"mx_gradient_scale2d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]}),uu=bt([s0,i0]),r0=w(([i])=>{const t=T(i).toVar();return k(.982,t)}).setLayout({name:"mx_gradient_scale3d_1",type:"vec3",inputs:[{name:"v",type:"vec3"}]}),du=bt([n0,r0]),Wt=w(([i,t])=>{const e=y(t).toVar(),s=R(i).toVar();return s.shiftLeft(e).bitOr(s.shiftRight(y(32).sub(e)))}).setLayout({name:"mx_rotl32",type:"uint",inputs:[{name:"x",type:"uint"},{name:"k",type:"int"}]}),pu=w(([i,t,e])=>{i.subAssign(e),i.bitXorAssign(Wt(e,y(4))),e.addAssign(t),t.subAssign(i),t.bitXorAssign(Wt(i,y(6))),i.addAssign(e),e.subAssign(t),e.bitXorAssign(Wt(t,y(8))),t.addAssign(i),i.subAssign(e),i.bitXorAssign(Wt(e,y(16))),e.addAssign(t),t.subAssign(i),t.bitXorAssign(Wt(i,y(19))),i.addAssign(e),e.subAssign(t),e.bitXorAssign(Wt(t,y(4))),t.addAssign(i)}),In=w(([i,t,e])=>{const s=R(e).toVar(),n=R(t).toVar(),r=R(i).toVar();return s.bitXorAssign(n),s.subAssign(Wt(n,y(14))),r.bitXorAssign(s),r.subAssign(Wt(s,y(11))),n.bitXorAssign(r),n.subAssign(Wt(r,y(25))),s.bitXorAssign(n),s.subAssign(Wt(n,y(16))),r.bitXorAssign(s),r.subAssign(Wt(s,y(4))),n.bitXorAssign(r),n.subAssign(Wt(r,y(14))),s.bitXorAssign(n),s.subAssign(Wt(n,y(24))),s}).setLayout({name:"mx_bjfinal",type:"uint",inputs:[{name:"a",type:"uint"},{name:"b",type:"uint"},{name:"c",type:"uint"}]}),Rt=w(([i])=>{const t=R(i).toVar();return g(t).div(g(R(y(4294967295))))}).setLayout({name:"mx_bits_to_01",type:"float",inputs:[{name:"bits",type:"uint"}]}),fe=w(([i])=>{const t=g(i).toVar();return t.mul(t).mul(t).mul(t.mul(t.mul(6).sub(15)).add(10))}).setLayout({name:"mx_fade",type:"float",inputs:[{name:"t",type:"float"}]}),o0=w(([i])=>{const t=y(i).toVar(),e=R(R(1)).toVar(),s=R(R(y(3735928559)).add(e.shiftLeft(R(2))).add(R(13))).toVar();return In(s.add(R(t)),s,s)}).setLayout({name:"mx_hash_int_0",type:"uint",inputs:[{name:"x",type:"int"}]}),a0=w(([i,t])=>{const e=y(t).toVar(),s=y(i).toVar(),n=R(R(2)).toVar(),r=R().toVar(),o=R().toVar(),a=R().toVar();return r.assign(o.assign(a.assign(R(y(3735928559)).add(n.shiftLeft(R(2))).add(R(13))))),r.addAssign(R(s)),o.addAssign(R(e)),In(r,o,a)}).setLayout({name:"mx_hash_int_1",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]}),c0=w(([i,t,e])=>{const s=y(e).toVar(),n=y(t).toVar(),r=y(i).toVar(),o=R(R(3)).toVar(),a=R().toVar(),c=R().toVar(),h=R().toVar();return a.assign(c.assign(h.assign(R(y(3735928559)).add(o.shiftLeft(R(2))).add(R(13))))),a.addAssign(R(r)),c.addAssign(R(n)),h.addAssign(R(s)),In(a,c,h)}).setLayout({name:"mx_hash_int_2",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]}),h0=w(([i,t,e,s])=>{const n=y(s).toVar(),r=y(e).toVar(),o=y(t).toVar(),a=y(i).toVar(),c=R(R(4)).toVar(),h=R().toVar(),l=R().toVar(),d=R().toVar();return h.assign(l.assign(d.assign(R(y(3735928559)).add(c.shiftLeft(R(2))).add(R(13))))),h.addAssign(R(a)),l.addAssign(R(o)),d.addAssign(R(r)),pu(h,l,d),h.addAssign(R(n)),In(h,l,d)}).setLayout({name:"mx_hash_int_3",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"}]}),l0=w(([i,t,e,s,n])=>{const r=y(n).toVar(),o=y(s).toVar(),a=y(e).toVar(),c=y(t).toVar(),h=y(i).toVar(),l=R(R(5)).toVar(),d=R().toVar(),p=R().toVar(),m=R().toVar();return d.assign(p.assign(m.assign(R(y(3735928559)).add(l.shiftLeft(R(2))).add(R(13))))),d.addAssign(R(h)),p.addAssign(R(c)),m.addAssign(R(a)),pu(d,p,m),d.addAssign(R(o)),p.addAssign(R(r)),In(d,p,m)}).setLayout({name:"mx_hash_int_4",type:"uint",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xx",type:"int"},{name:"yy",type:"int"}]}),J=bt([o0,a0,c0,h0,l0]),u0=w(([i,t])=>{const e=y(t).toVar(),s=y(i).toVar(),n=R(J(s,e)).toVar(),r=Hs().toVar();return r.x.assign(n.bitAnd(y(255))),r.y.assign(n.shiftRight(y(8)).bitAnd(y(255))),r.z.assign(n.shiftRight(y(16)).bitAnd(y(255))),r}).setLayout({name:"mx_hash_vec3_0",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"}]}),d0=w(([i,t,e])=>{const s=y(e).toVar(),n=y(t).toVar(),r=y(i).toVar(),o=R(J(r,n,s)).toVar(),a=Hs().toVar();return a.x.assign(o.bitAnd(y(255))),a.y.assign(o.shiftRight(y(8)).bitAnd(y(255))),a.z.assign(o.shiftRight(y(16)).bitAnd(y(255))),a}).setLayout({name:"mx_hash_vec3_1",type:"uvec3",inputs:[{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"}]}),Yt=bt([u0,d0]),p0=w(([i])=>{const t=z(i).toVar(),e=y().toVar(),s=y().toVar(),n=g(nt(t.x,e)).toVar(),r=g(nt(t.y,s)).toVar(),o=g(fe(n)).toVar(),a=g(fe(r)).toVar(),c=g(hu(vt(J(e,s),n,r),vt(J(e.add(y(1)),s),n.sub(1),r),vt(J(e,s.add(y(1))),n,r.sub(1)),vt(J(e.add(y(1)),s.add(y(1))),n.sub(1),r.sub(1)),o,a)).toVar();return uu(c)}).setLayout({name:"mx_perlin_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"}]}),m0=w(([i])=>{const t=T(i).toVar(),e=y().toVar(),s=y().toVar(),n=y().toVar(),r=g(nt(t.x,e)).toVar(),o=g(nt(t.y,s)).toVar(),a=g(nt(t.z,n)).toVar(),c=g(fe(r)).toVar(),h=g(fe(o)).toVar(),l=g(fe(a)).toVar(),d=g(lu(vt(J(e,s,n),r,o,a),vt(J(e.add(y(1)),s,n),r.sub(1),o,a),vt(J(e,s.add(y(1)),n),r,o.sub(1),a),vt(J(e.add(y(1)),s.add(y(1)),n),r.sub(1),o.sub(1),a),vt(J(e,s,n.add(y(1))),r,o,a.sub(1)),vt(J(e.add(y(1)),s,n.add(y(1))),r.sub(1),o,a.sub(1)),vt(J(e,s.add(y(1)),n.add(y(1))),r,o.sub(1),a.sub(1)),vt(J(e.add(y(1)),s.add(y(1)),n.add(y(1))),r.sub(1),o.sub(1),a.sub(1)),c,h,l)).toVar();return du(d)}).setLayout({name:"mx_perlin_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"}]}),Fo=bt([p0,m0]),f0=w(([i])=>{const t=z(i).toVar(),e=y().toVar(),s=y().toVar(),n=g(nt(t.x,e)).toVar(),r=g(nt(t.y,s)).toVar(),o=g(fe(n)).toVar(),a=g(fe(r)).toVar(),c=T(hu($t(Yt(e,s),n,r),$t(Yt(e.add(y(1)),s),n.sub(1),r),$t(Yt(e,s.add(y(1))),n,r.sub(1)),$t(Yt(e.add(y(1)),s.add(y(1))),n.sub(1),r.sub(1)),o,a)).toVar();return uu(c)}).setLayout({name:"mx_perlin_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"}]}),g0=w(([i])=>{const t=T(i).toVar(),e=y().toVar(),s=y().toVar(),n=y().toVar(),r=g(nt(t.x,e)).toVar(),o=g(nt(t.y,s)).toVar(),a=g(nt(t.z,n)).toVar(),c=g(fe(r)).toVar(),h=g(fe(o)).toVar(),l=g(fe(a)).toVar(),d=T(lu($t(Yt(e,s,n),r,o,a),$t(Yt(e.add(y(1)),s,n),r.sub(1),o,a),$t(Yt(e,s.add(y(1)),n),r,o.sub(1),a),$t(Yt(e.add(y(1)),s.add(y(1)),n),r.sub(1),o.sub(1),a),$t(Yt(e,s,n.add(y(1))),r,o,a.sub(1)),$t(Yt(e.add(y(1)),s,n.add(y(1))),r.sub(1),o,a.sub(1)),$t(Yt(e,s.add(y(1)),n.add(y(1))),r,o.sub(1),a.sub(1)),$t(Yt(e.add(y(1)),s.add(y(1)),n.add(y(1))),r.sub(1),o.sub(1),a.sub(1)),c,h,l)).toVar();return du(d)}).setLayout({name:"mx_perlin_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),Io=bt([f0,g0]),y0=w(([i])=>{const t=g(i).toVar(),e=y(ut(t)).toVar();return Rt(J(e))}).setLayout({name:"mx_cell_noise_float_0",type:"float",inputs:[{name:"p",type:"float"}]}),x0=w(([i])=>{const t=z(i).toVar(),e=y(ut(t.x)).toVar(),s=y(ut(t.y)).toVar();return Rt(J(e,s))}).setLayout({name:"mx_cell_noise_float_1",type:"float",inputs:[{name:"p",type:"vec2"}]}),N0=w(([i])=>{const t=T(i).toVar(),e=y(ut(t.x)).toVar(),s=y(ut(t.y)).toVar(),n=y(ut(t.z)).toVar();return Rt(J(e,s,n))}).setLayout({name:"mx_cell_noise_float_2",type:"float",inputs:[{name:"p",type:"vec3"}]}),T0=w(([i])=>{const t=D(i).toVar(),e=y(ut(t.x)).toVar(),s=y(ut(t.y)).toVar(),n=y(ut(t.z)).toVar(),r=y(ut(t.w)).toVar();return Rt(J(e,s,n,r))}).setLayout({name:"mx_cell_noise_float_3",type:"float",inputs:[{name:"p",type:"vec4"}]}),v0=bt([y0,x0,N0,T0]),w0=w(([i])=>{const t=g(i).toVar(),e=y(ut(t)).toVar();return T(Rt(J(e,y(0))),Rt(J(e,y(1))),Rt(J(e,y(2))))}).setLayout({name:"mx_cell_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"float"}]}),M0=w(([i])=>{const t=z(i).toVar(),e=y(ut(t.x)).toVar(),s=y(ut(t.y)).toVar();return T(Rt(J(e,s,y(0))),Rt(J(e,s,y(1))),Rt(J(e,s,y(2))))}).setLayout({name:"mx_cell_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec2"}]}),_0=w(([i])=>{const t=T(i).toVar(),e=y(ut(t.x)).toVar(),s=y(ut(t.y)).toVar(),n=y(ut(t.z)).toVar();return T(Rt(J(e,s,n,y(0))),Rt(J(e,s,n,y(1))),Rt(J(e,s,n,y(2))))}).setLayout({name:"mx_cell_noise_vec3_2",type:"vec3",inputs:[{name:"p",type:"vec3"}]}),b0=w(([i])=>{const t=D(i).toVar(),e=y(ut(t.x)).toVar(),s=y(ut(t.y)).toVar(),n=y(ut(t.z)).toVar(),r=y(ut(t.w)).toVar();return T(Rt(J(e,s,n,r,y(0))),Rt(J(e,s,n,r,y(1))),Rt(J(e,s,n,r,y(2))))}).setLayout({name:"mx_cell_noise_vec3_3",type:"vec3",inputs:[{name:"p",type:"vec4"}]}),mu=bt([w0,M0,_0,b0]),zi=w(([i,t,e,s])=>{const n=g(s).toVar(),r=g(e).toVar(),o=y(t).toVar(),a=T(i).toVar(),c=g(0).toVar(),h=g(1).toVar();return K(o,()=>{c.addAssign(h.mul(Fo(a))),h.mulAssign(n),a.mulAssign(r)}),c}).setLayout({name:"mx_fractal_noise_float",type:"float",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),fu=w(([i,t,e,s])=>{const n=g(s).toVar(),r=g(e).toVar(),o=y(t).toVar(),a=T(i).toVar(),c=T(0).toVar(),h=g(1).toVar();return K(o,()=>{c.addAssign(h.mul(Io(a))),h.mulAssign(n),a.mulAssign(r)}),c}).setLayout({name:"mx_fractal_noise_vec3",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),S0=w(([i,t,e,s])=>{const n=g(s).toVar(),r=g(e).toVar(),o=y(t).toVar(),a=T(i).toVar();return z(zi(a,o,r,n),zi(a.add(T(y(19),y(193),y(17))),o,r,n))}).setLayout({name:"mx_fractal_noise_vec2",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),A0=w(([i,t,e,s])=>{const n=g(s).toVar(),r=g(e).toVar(),o=y(t).toVar(),a=T(i).toVar(),c=T(fu(a,o,r,n)).toVar(),h=g(zi(a.add(T(y(19),y(193),y(17))),o,r,n)).toVar();return D(c,h)}).setLayout({name:"mx_fractal_noise_vec4",type:"vec4",inputs:[{name:"p",type:"vec3"},{name:"octaves",type:"int"},{name:"lacunarity",type:"float"},{name:"diminish",type:"float"}]}),V0=w(([i,t,e,s,n,r,o])=>{const a=y(o).toVar(),c=g(r).toVar(),h=y(n).toVar(),l=y(s).toVar(),d=y(e).toVar(),p=y(t).toVar(),m=z(i).toVar(),f=T(mu(z(p.add(l),d.add(h)))).toVar(),x=z(f.x,f.y).toVar();x.subAssign(.5),x.mulAssign(c),x.addAssign(.5);const v=z(z(g(p),g(d)).add(x)).toVar(),A=z(v.sub(m)).toVar();return q(a.equal(y(2)),()=>et(A.x).add(et(A.y))),q(a.equal(y(3)),()=>Mt(et(A.x),et(A.y))),Je(A,A)}).setLayout({name:"mx_worley_distance_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),z0=w(([i,t,e,s,n,r,o,a,c])=>{const h=y(c).toVar(),l=g(a).toVar(),d=y(o).toVar(),p=y(r).toVar(),m=y(n).toVar(),f=y(s).toVar(),x=y(e).toVar(),v=y(t).toVar(),A=T(i).toVar(),F=T(mu(T(v.add(m),x.add(p),f.add(d)))).toVar();F.subAssign(.5),F.mulAssign(l),F.addAssign(.5);const O=T(T(g(v),g(x),g(f)).add(F)).toVar(),E=T(O.sub(A)).toVar();return q(h.equal(y(2)),()=>et(E.x).add(et(E.y)).add(et(E.z))),q(h.equal(y(3)),()=>Mt(Mt(et(E.x),et(E.y)),et(E.z))),Je(E,E)}).setLayout({name:"mx_worley_distance_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"x",type:"int"},{name:"y",type:"int"},{name:"z",type:"int"},{name:"xoff",type:"int"},{name:"yoff",type:"int"},{name:"zoff",type:"int"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),Xs=bt([V0,z0]),C0=w(([i,t,e])=>{const s=y(e).toVar(),n=g(t).toVar(),r=z(i).toVar(),o=y().toVar(),a=y().toVar(),c=z(nt(r.x,o),nt(r.y,a)).toVar(),h=g(1e6).toVar();return K({start:-1,end:y(1),name:"x",condition:"<="},({x:l})=>{K({start:-1,end:y(1),name:"y",condition:"<="},({y:d})=>{const p=g(Xs(c,l,d,o,a,n,s)).toVar();h.assign(Ht(h,p))})}),q(s.equal(y(0)),()=>{h.assign(Ne(h))}),h}).setLayout({name:"mx_worley_noise_float_0",type:"float",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),R0=w(([i,t,e])=>{const s=y(e).toVar(),n=g(t).toVar(),r=z(i).toVar(),o=y().toVar(),a=y().toVar(),c=z(nt(r.x,o),nt(r.y,a)).toVar(),h=z(1e6,1e6).toVar();return K({start:-1,end:y(1),name:"x",condition:"<="},({x:l})=>{K({start:-1,end:y(1),name:"y",condition:"<="},({y:d})=>{const p=g(Xs(c,l,d,o,a,n,s)).toVar();q(p.lessThan(h.x),()=>{h.y.assign(h.x),h.x.assign(p)}).ElseIf(p.lessThan(h.y),()=>{h.y.assign(p)})})}),q(s.equal(y(0)),()=>{h.assign(Ne(h))}),h}).setLayout({name:"mx_worley_noise_vec2_0",type:"vec2",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),E0=w(([i,t,e])=>{const s=y(e).toVar(),n=g(t).toVar(),r=z(i).toVar(),o=y().toVar(),a=y().toVar(),c=z(nt(r.x,o),nt(r.y,a)).toVar(),h=T(1e6,1e6,1e6).toVar();return K({start:-1,end:y(1),name:"x",condition:"<="},({x:l})=>{K({start:-1,end:y(1),name:"y",condition:"<="},({y:d})=>{const p=g(Xs(c,l,d,o,a,n,s)).toVar();q(p.lessThan(h.x),()=>{h.z.assign(h.y),h.y.assign(h.x),h.x.assign(p)}).ElseIf(p.lessThan(h.y),()=>{h.z.assign(h.y),h.y.assign(p)}).ElseIf(p.lessThan(h.z),()=>{h.z.assign(p)})})}),q(s.equal(y(0)),()=>{h.assign(Ne(h))}),h}).setLayout({name:"mx_worley_noise_vec3_0",type:"vec3",inputs:[{name:"p",type:"vec2"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),F0=w(([i,t,e])=>{const s=y(e).toVar(),n=g(t).toVar(),r=T(i).toVar(),o=y().toVar(),a=y().toVar(),c=y().toVar(),h=T(nt(r.x,o),nt(r.y,a),nt(r.z,c)).toVar(),l=g(1e6).toVar();return K({start:-1,end:y(1),name:"x",condition:"<="},({x:d})=>{K({start:-1,end:y(1),name:"y",condition:"<="},({y:p})=>{K({start:-1,end:y(1),name:"z",condition:"<="},({z:m})=>{const f=g(Xs(h,d,p,m,o,a,c,n,s)).toVar();l.assign(Ht(l,f))})})}),q(s.equal(y(0)),()=>{l.assign(Ne(l))}),l}).setLayout({name:"mx_worley_noise_float_1",type:"float",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),I0=bt([C0,F0]),O0=w(([i,t,e])=>{const s=y(e).toVar(),n=g(t).toVar(),r=T(i).toVar(),o=y().toVar(),a=y().toVar(),c=y().toVar(),h=T(nt(r.x,o),nt(r.y,a),nt(r.z,c)).toVar(),l=z(1e6,1e6).toVar();return K({start:-1,end:y(1),name:"x",condition:"<="},({x:d})=>{K({start:-1,end:y(1),name:"y",condition:"<="},({y:p})=>{K({start:-1,end:y(1),name:"z",condition:"<="},({z:m})=>{const f=g(Xs(h,d,p,m,o,a,c,n,s)).toVar();q(f.lessThan(l.x),()=>{l.y.assign(l.x),l.x.assign(f)}).ElseIf(f.lessThan(l.y),()=>{l.y.assign(f)})})})}),q(s.equal(y(0)),()=>{l.assign(Ne(l))}),l}).setLayout({name:"mx_worley_noise_vec2_1",type:"vec2",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),L0=bt([R0,O0]),B0=w(([i,t,e])=>{const s=y(e).toVar(),n=g(t).toVar(),r=T(i).toVar(),o=y().toVar(),a=y().toVar(),c=y().toVar(),h=T(nt(r.x,o),nt(r.y,a),nt(r.z,c)).toVar(),l=T(1e6,1e6,1e6).toVar();return K({start:-1,end:y(1),name:"x",condition:"<="},({x:d})=>{K({start:-1,end:y(1),name:"y",condition:"<="},({y:p})=>{K({start:-1,end:y(1),name:"z",condition:"<="},({z:m})=>{const f=g(Xs(h,d,p,m,o,a,c,n,s)).toVar();q(f.lessThan(l.x),()=>{l.z.assign(l.y),l.y.assign(l.x),l.x.assign(f)}).ElseIf(f.lessThan(l.y),()=>{l.z.assign(l.y),l.y.assign(f)}).ElseIf(f.lessThan(l.z),()=>{l.z.assign(f)})})})}),q(s.equal(y(0)),()=>{l.assign(Ne(l))}),l}).setLayout({name:"mx_worley_noise_vec3_1",type:"vec3",inputs:[{name:"p",type:"vec3"},{name:"jitter",type:"float"},{name:"metric",type:"int"}]}),P0=bt([E0,B0]),D0=w(([i])=>{const t=i.y,e=i.z,s=T().toVar();return q(t.lessThan(1e-4),()=>{s.assign(T(e,e,e))}).Else(()=>{let n=i.x;n=n.sub(me(n)).mul(6).toVar();const r=y(po(n)),o=n.sub(g(r)),a=e.mul(t.oneMinus()),c=e.mul(t.mul(o).oneMinus()),h=e.mul(t.mul(o.oneMinus()).oneMinus());q(r.equal(y(0)),()=>{s.assign(T(e,h,a))}).ElseIf(r.equal(y(1)),()=>{s.assign(T(c,e,a))}).ElseIf(r.equal(y(2)),()=>{s.assign(T(a,e,h))}).ElseIf(r.equal(y(3)),()=>{s.assign(T(a,c,e))}).ElseIf(r.equal(y(4)),()=>{s.assign(T(h,a,e))}).Else(()=>{s.assign(T(e,a,c))})}),s}).setLayout({name:"mx_hsvtorgb",type:"vec3",inputs:[{name:"hsv",type:"vec3"}]}),k0=w(([i])=>{const t=T(i).toVar(),e=g(t.x).toVar(),s=g(t.y).toVar(),n=g(t.z).toVar(),r=g(Ht(e,Ht(s,n))).toVar(),o=g(Mt(e,Mt(s,n))).toVar(),a=g(o.sub(r)).toVar(),c=g().toVar(),h=g().toVar(),l=g().toVar();return l.assign(o),q(o.greaterThan(0),()=>{h.assign(a.div(o))}).Else(()=>{h.assign(0)}),q(h.lessThanEqual(0),()=>{c.assign(0)}).Else(()=>{q(e.greaterThanEqual(o),()=>{c.assign(s.sub(n).div(a))}).ElseIf(s.greaterThanEqual(o),()=>{c.assign(dt(2,n.sub(e).div(a)))}).Else(()=>{c.assign(dt(4,e.sub(s).div(a)))}),c.mulAssign(1/6),q(c.lessThan(0),()=>{c.addAssign(1)})}),T(c,h,l)}).setLayout({name:"mx_rgbtohsv",type:"vec3",inputs:[{name:"c",type:"vec3"}]}),U0=w(([i])=>{const t=T(i).toVar(),e=no(oo(t,T(.04045))).toVar(),s=T(t.div(12.92)).toVar(),n=T(he(Mt(t.add(T(.055)),T(0)).div(1.055),T(2.4))).toVar();return at(s,n,e)}).setLayout({name:"mx_srgb_texture_to_lin_rec709",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),gu=(i,t)=>{i=g(i),t=g(t);const e=z(t.dFdx(),t.dFdy()).length().mul(.7071067811865476);return qs(i.sub(e),i.add(e),t)},yu=(i,t,e,s)=>at(i,t,e[s].clamp()),W0=(i,t,e=rt())=>yu(i,t,e,"x"),q0=(i,t,e=rt())=>yu(i,t,e,"y"),xu=(i,t,e,s,n)=>at(i,t,gu(e,s[n])),G0=(i,t,e,s=rt())=>xu(i,t,e,s,"x"),H0=(i,t,e,s=rt())=>xu(i,t,e,s,"y"),j0=(i=1,t=0,e=rt())=>e.mul(i).add(t),X0=(i,t=1)=>(i=g(i),i.abs().pow(t).mul(i.sign())),$0=(i,t=1,e=.5)=>g(i).sub(e).mul(t).add(e),Y0=(i=rt(),t=1,e=0)=>Fo(i.convert("vec2|vec3")).mul(t).add(e),Z0=(i=rt(),t=1,e=0)=>Io(i.convert("vec2|vec3")).mul(t).add(e),J0=(i=rt(),t=1,e=0)=>(i=i.convert("vec2|vec3"),D(Io(i),Fo(i.add(z(19,73)))).mul(t).add(e)),Q0=(i=rt(),t=1)=>I0(i.convert("vec2|vec3"),t,y(1)),K0=(i=rt(),t=1)=>L0(i.convert("vec2|vec3"),t,y(1)),tN=(i=rt(),t=1)=>P0(i.convert("vec2|vec3"),t,y(1)),eN=(i=rt())=>v0(i.convert("vec2|vec3")),sN=(i=rt(),t=3,e=2,s=.5,n=1)=>zi(i,y(t),e,s).mul(n),nN=(i=rt(),t=3,e=2,s=.5,n=1)=>S0(i,y(t),e,s).mul(n),iN=(i=rt(),t=3,e=2,s=.5,n=1)=>fu(i,y(t),e,s).mul(n),rN=(i=rt(),t=3,e=2,s=.5,n=1)=>A0(i,y(t),e,s).mul(n),oN=w(([i,t,e])=>{const s=gs(i).toVar("nDir"),n=H(g(.5).mul(t.sub(e)),ds).div(s).toVar("rbmax"),r=H(g(-.5).mul(t.sub(e)),ds).div(s).toVar("rbmin"),o=T().toVar("rbminmax");o.x=s.x.greaterThan(g(0)).select(n.x,r.x),o.y=s.y.greaterThan(g(0)).select(n.y,r.y),o.z=s.z.greaterThan(g(0)).select(n.z,r.z);const a=Ht(Ht(o.x,o.y),o.z).toVar("correction");return ds.add(s.mul(a)).toVar("boxIntersection").sub(e)}),aN=w(([i,t])=>{const e=i.x,s=i.y,n=i.z;let r=t.element(0).mul(.886227);return r=r.add(t.element(1).mul(2*.511664).mul(s)),r=r.add(t.element(2).mul(2*.511664).mul(n)),r=r.add(t.element(3).mul(2*.511664).mul(e)),r=r.add(t.element(4).mul(2*.429043).mul(e).mul(s)),r=r.add(t.element(5).mul(2*.429043).mul(s).mul(n)),r=r.add(t.element(6).mul(n.mul(n).mul(.743125).sub(.247708))),r=r.add(t.element(7).mul(2*.429043).mul(e).mul(n)),r=r.add(t.element(8).mul(.429043).mul(k(e,e).sub(k(s,s)))),r});var u=Object.freeze({__proto__:null,BRDF_GGX:qf,BRDF_Lambert:Pf,BasicShadowFilter:iu,Break:wl,Continue:cf,DFGApprox:Gf,D_GGX:Fl,Discard:Bh,EPSILON:Pc,F_Schlick:Cl,Fn:w,INFINITY:Tp,If:q,Loop:K,NodeAccess:pe,NodeShaderStage:Ir,NodeType:zd,NodeUpdateType:$,PCFShadowFilter:ru,PCFSoftShadowFilter:ou,PI:Ti,PI2:vp,Return:Lp,Schlick_to_F0:Hf,ScriptableNodeResources:fi,ShaderNode:ln,TBNViewMatrix:Mo,VSMShadowFilter:au,V_GGX_SmithCorrelated:El,abs:et,acesFilmicToneMapping:Uy,acos:Xc,add:dt,addMethodChaining:b,addNodeElement:Pp,agxToneMapping:Hy,all:ao,alphaT:Dr,and:Ac,anisotropy:xc,anisotropyB:Bs,anisotropyT:pi,any:Dc,append:sc,arrayBuffer:Zd,asin:jc,assign:Tc,atan:$c,atan2:eh,atomicAdd:_x,atomicAnd:Vx,atomicFunc:Pe,atomicMax:Sx,atomicMin:Ax,atomicOr:zx,atomicStore:Mx,atomicSub:bx,atomicXor:Cx,attenuationColor:gp,attenuationDistance:fp,attribute:Ie,attributeArray:ny,backgroundBlurriness:hy,backgroundIntensity:ly,backgroundRotation:uy,batch:Nl,billboarding:Og,bitAnd:Rc,bitNot:Ec,bitOr:Fc,bitXor:Ic,bitangentGeometry:um,bitangentLocal:dm,bitangentView:nl,bitangentWorld:pm,bitcast:wp,blendBurn:Yl,blendColor:xy,blendDodge:Zl,blendOverlay:Ql,blendScreen:Jl,blur:Qf,bool:Re,buffer:An,bufferAttribute:_n,bumpMap:ol,burn:Ny,bvec2:rc,bvec3:no,bvec4:hc,bypass:Fh,cache:Eh,call:vc,cameraFar:Xe,cameraNear:je,cameraNormalMatrix:Gp,cameraPosition:Hp,cameraProjectionMatrix:bn,cameraProjectionMatrixInverse:Wp,cameraViewMatrix:ee,cameraWorldMatrix:qp,cbrt:hh,cdl:Vy,ceil:Oi,checker:Xx,cineonToneMapping:Dy,clamp:Fe,clearcoat:tp,clearcoatRoughness:ep,code:Gi,color:nc,colorSpaceToWorking:yo,colorToDirection:Of,compute:Rh,cond:yh,context:fo,convert:uc,convertColorSpace:Sp,convertToTexture:$g,cos:be,cross:Bi,cubeTexture:tl,dFdx:lo,dFdy:uo,dashSize:hp,defaultBuildStages:Cd,defaultShaderStages:Ya,defined:mn,degrees:Wc,deltaTime:ql,densityFog:ax,depth:Vo,depthPass:Iy,difference:ih,diffuseColor:re,directPointLight:jx,directionToColor:If,dispersion:yp,distance:nh,div:Ee,dodge:Ty,dot:Je,drawIndex:gl,dynamicBufferAttribute:Ch,element:lc,emissive:Pr,equal:wc,equals:kc,equirectUV:Bf,exp:qc,exp2:Ws,expression:Ze,faceDirection:Sn,faceForward:ph,float:g,floor:me,fog:nx,fract:Be,frameGroup:Qd,frameId:bg,frontFacing:Gh,fwidth:Kc,gain:Ng,gapSize:lp,getConstNodeType:tc,getCurrentStack:ec,getDirection:Ll,getDistanceAttenuation:cu,getGeometryRoughness:Rl,getNormalFromDepth:Zg,getParallaxCorrectNormal:oN,getRoughness:Df,getScreenPosition:Yg,getShIrradianceAt:aN,getTextureIndex:kl,getViewPosition:Is,glsl:Yy,glslFn:Jy,grayscale:My,greaterThan:oo,greaterThanEqual:Sc,hash:xg,highPrecisionModelNormalViewMatrix:sm,highPrecisionModelViewMatrix:em,hue:Sy,instance:sf,instanceIndex:Rn,instancedArray:iy,instancedBufferAttribute:wi,instancedDynamicBufferAttribute:kr,instancedMesh:xl,int:y,inverseSqrt:Gc,invocationLocalIndex:ef,invocationSubgroupIndex:tf,ior:dp,iridescence:yc,iridescenceIOR:ip,iridescenceThickness:rp,ivec2:Nt,ivec3:oc,ivec4:ac,js:Xy,label:Nh,length:vi,lengthSq:lh,lessThan:_c,lessThanEqual:bc,lightPosition:su,lightProjectionUV:Rx,lightShadowMatrix:Eo,lightTargetDirection:Fx,lightTargetPosition:nu,lightViewPosition:Ex,lightingContext:bl,lights:Bx,linearDepth:bi,linearToneMapping:By,localId:px,log:co,log2:Ce,logarithmicDepthToViewZ:Mf,loop:hf,luminance:qi,mat2:Ii,mat3:Kt,mat4:ls,matcapUV:og,materialAOMap:pl,materialAlphaTest:al,materialAnisotropy:Lm,materialAnisotropyVector:Fs,materialAttenuationColor:Gm,materialAttenuationDistance:qm,materialClearcoat:Cm,materialClearcoatNormal:Em,materialClearcoatRoughness:Rm,materialColor:cl,materialDispersion:Jm,materialEmissive:hl,materialIOR:Wm,materialIridescence:Bm,materialIridescenceIOR:Pm,materialIridescenceThickness:Dm,materialLightMap:dl,materialLineDashOffset:Ym,materialLineDashSize:jm,materialLineGapSize:Xm,materialLineScale:Hm,materialLineWidth:$m,materialMetalness:zm,materialNormal:ul,materialOpacity:ll,materialPointWidth:Zm,materialReference:as,materialReflectivity:Am,materialRefractionRatio:Yh,materialRotation:Fm,materialRoughness:Vm,materialSheen:Im,materialSheenRoughness:Om,materialShininess:wm,materialSpecular:Mm,materialSpecularColor:bm,materialSpecularIntensity:_m,materialSpecularStrength:Sm,materialThickness:Um,materialTransmission:km,max:Mt,maxMipLevel:kh,metalness:Kd,min:Ht,mix:at,mixElement:fh,mod:mo,modInt:ro,modelDirection:Zp,modelNormalMatrix:Wh,modelPosition:Jp,modelScale:Qp,modelViewMatrix:js,modelViewPosition:Kp,modelViewProjection:ml,modelWorldMatrix:Se,modelWorldMatrixInverse:tm,morphReference:Ml,mrt:Ul,mul:k,mx_aastep:gu,mx_cell_noise_float:eN,mx_contrast:$0,mx_fractal_noise_float:sN,mx_fractal_noise_vec2:nN,mx_fractal_noise_vec3:iN,mx_fractal_noise_vec4:rN,mx_hsvtorgb:D0,mx_noise_float:Y0,mx_noise_vec3:Z0,mx_noise_vec4:J0,mx_ramplr:W0,mx_ramptb:q0,mx_rgbtohsv:k0,mx_safepower:X0,mx_splitlr:G0,mx_splittb:H0,mx_srgb_texture_to_lin_rec709:U0,mx_transform_uv:j0,mx_worley_noise_float:Q0,mx_worley_noise_vec2:K0,mx_worley_noise_vec3:tN,negate:Yc,neutralToneMapping:jy,nodeArray:hs,nodeImmutable:C,nodeObject:V,nodeObjects:Tn,nodeProxy:_,normalFlat:Hh,normalGeometry:No,normalLocal:Pt,normalMap:Wr,normalView:ye,normalWorld:jh,normalize:gs,not:zc,notEqual:Mc,numWorkgroups:ux,objectDirection:jp,objectGroup:mc,objectPosition:Uh,objectScale:$p,objectViewPosition:Yp,objectWorldMatrix:Xp,oneMinus:Zc,or:Vc,orthographicDepthToViewZ:wf,oscSawtooth:Eg,oscSine:zg,oscSquare:Cg,oscTriangle:Rg,output:Nc,outputStruct:gg,overlay:wy,overloadingFn:bt,parabola:Xr,parallaxDirection:rl,parallaxUV:fm,parameter:dg,pass:Ey,passTexture:Fy,pcurve:Tg,perspectiveDepthToViewZ:So,pmremTexture:ig,pointUV:cy,pointWidth:up,positionGeometry:xo,positionLocal:ct,positionPrevious:Mi,positionView:wt,positionViewDirection:Gt,positionWorld:ds,positionWorldDirection:qh,posterize:Cy,pow:he,pow2:rh,pow3:oh,pow4:ah,property:fc,radians:Uc,rand:mh,range:hx,rangeFog:rx,reciprocal:Qc,reference:lt,referenceBuffer:Ur,reflect:sh,reflectVector:Qh,reflectView:Zh,reflector:qg,refract:dh,refractVector:Kh,refractView:Jh,reinhardToneMapping:Py,remainder:Bc,remap:Oh,remapClamp:Lh,renderGroup:X,renderOutput:Ph,rendererReference:Ah,rotate:Pl,rotateUV:Fg,roughness:gc,round:Jc,rtt:jl,sRGBTransferEOTF:wh,sRGBTransferOETF:Mh,sampler:Up,saturate:uh,saturation:_y,screen:vy,screenCoordinate:En,screenSize:_i,screenUV:Qe,scriptable:sx,scriptableValue:mi,select:Ot,setCurrentStack:Br,shaderStages:Rd,shadow:Hx,sharedUniformGroup:io,sheen:sp,sheenRoughness:np,shiftLeft:Oc,shiftRight:Lc,shininess:cp,sign:ho,sin:qt,sinc:vg,skinning:of,skinningReference:vl,smoothstep:qs,smoothstepElement:gh,specularColor:op,specularF90:ap,spherizeUV:Ig,split:Jd,spritesheetUV:Pg,sqrt:Ne,stack:mg,step:Li,storage:Wi,storageBarrier:yx,storageObject:sy,storageTexture:Xl,string:Yd,sub:H,subgroupIndex:Km,subgroupSize:mx,tan:Hc,tangentGeometry:Di,tangentLocal:Vn,tangentView:zn,tangentWorld:sl,temp:vh,texture:Ft,texture3D:lg,textureBarrier:xx,textureBicubic:jf,textureCubeUV:Bl,textureLoad:ot,textureSize:us,textureStore:py,thickness:mp,threshold:Ay,time:ys,timerDelta:Vg,timerGlobal:Ag,timerLocal:Sg,toOutputColorSpace:_h,toWorkingColorSpace:bh,toneMapping:Vh,toneMappingExposure:zh,toonOutlinePass:Ly,transformDirection:ch,transformNormal:$h,transformNormalToView:To,transformedBentNormalView:gm,transformedBitangentView:il,transformedBitangentWorld:mm,transformedClearcoatNormalView:im,transformedNormalView:Le,transformedNormalWorld:Xh,transformedTangentView:wo,transformedTangentWorld:lm,transmission:pp,transpose:th,tri:de,tri3:Wl,triNoise3D:wg,triplanarTexture:kg,triplanarTextures:Gl,trunc:po,tslFn:$d,uint:R,uniform:W,uniformArray:os,uniformGroup:pc,uniforms:am,userData:fy,uv:rt,uvec2:ic,uvec3:Hs,uvec4:cc,varying:jt,varyingProperty:fn,vec2:z,vec3:T,vec4:D,vectorComponents:Gs,velocity:yy,vertexColor:oy,vertexIndex:fl,vibrance:by,viewZToLogarithmicDepth:Ao,viewZToOrthographicDepth:Ps,viewZToPerspectiveDepth:Vl,viewport:_o,viewportBottomLeft:xf,viewportCoordinate:Al,viewportDepthTexture:bo,viewportLinearDepth:_f,viewportMipTexture:Tf,viewportResolution:gf,viewportSafeUV:Lg,viewportSharedTexture:Ff,viewportSize:Sl,viewportTexture:Nf,viewportTopLeft:yf,viewportUV:ff,wgsl:$y,wgslFn:Qy,workgroupArray:vx,workgroupBarrier:gx,workgroupId:dx,workingToColorSpace:Sh,xor:Cc});const Ar=Ll(rt(),Ie("faceIndex")).normalize();T(Ar.x,Ar.y.negate(),Ar.z);const Rs=typeof self<"u"?self.GPUShaderStage:{VERTEX:1,FRAGMENT:2,COMPUTE:4};pe.READ_ONLY+"",pe.WRITE_ONLY+"",pe.READ_WRITE+"";Rs&&Rs.VERTEX,Rs&&Rs.FRAGMENT,Rs&&Rs.COMPUTE;const rs={tsl_xor:new xt("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),mod_float:new xt("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),mod_vec2:new xt("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),mod_vec3:new xt("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),mod_vec4:new xt("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),equals_bool:new xt("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),equals_bvec2:new xt("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),equals_bvec3:new xt("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),equals_bvec4:new xt("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),repeatWrapping_float:new xt("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),mirrorWrapping_float:new xt("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),clampWrapping_float:new xt("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),biquadraticTexture:new xt(`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`)};typeof navigator<"u"&&/Windows/g.test(navigator.userAgent)&&(rs.pow_float=new xt("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"),rs.pow_vec2=new xt("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }",[rs.pow_float]),rs.pow_vec3=new xt("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }",[rs.pow_float]),rs.pow_vec4=new xt("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }",[rs.pow_float]));/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */u.BRDF_GGX;u.BRDF_Lambert;u.BasicShadowFilter;u.Break;u.Continue;u.DFGApprox;u.D_GGX;u.Discard;u.EPSILON;u.F_Schlick;u.Fn;u.INFINITY;u.If;u.Loop;u.NodeShaderStage;u.NodeType;u.NodeUpdateType;u.NodeAccess;u.PCFShadowFilter;u.PCFSoftShadowFilter;u.PI;u.PI2;u.Return;u.Schlick_to_F0;u.ScriptableNodeResources;u.ShaderNode;u.TBNViewMatrix;u.VSMShadowFilter;u.V_GGX_SmithCorrelated;u.abs;u.acesFilmicToneMapping;u.acos;u.add;u.addMethodChaining;u.addNodeElement;u.agxToneMapping;u.all;u.alphaT;u.and;u.anisotropy;u.anisotropyB;u.anisotropyT;u.any;u.append;u.arrayBuffer;u.asin;u.assign;u.atan;u.atan2;u.atomicAdd;u.atomicAnd;u.atomicFunc;u.atomicMax;u.atomicMin;u.atomicOr;u.atomicStore;u.atomicSub;u.atomicXor;u.attenuationColor;u.attenuationDistance;u.attribute;u.attributeArray;u.backgroundBlurriness;u.backgroundIntensity;u.backgroundRotation;u.batch;u.billboarding;u.bitAnd;u.bitNot;u.bitOr;u.bitXor;u.bitangentGeometry;u.bitangentLocal;u.bitangentView;u.bitangentWorld;u.bitcast;u.blendBurn;u.blendColor;u.blendDodge;u.blendOverlay;u.blendScreen;u.blur;u.bool;u.buffer;u.bufferAttribute;u.bumpMap;u.burn;u.bvec2;u.bvec3;u.bvec4;u.bypass;u.cache;u.call;u.cameraFar;u.cameraNear;u.cameraNormalMatrix;u.cameraPosition;u.cameraProjectionMatrix;u.cameraProjectionMatrixInverse;u.cameraViewMatrix;u.cameraWorldMatrix;u.cbrt;u.cdl;u.ceil;u.checker;u.cineonToneMapping;u.clamp;u.clearcoat;u.clearcoatRoughness;u.code;const Oo=u.color;u.colorSpaceToWorking;u.colorToDirection;u.compute;u.cond;u.context;u.convert;u.convertColorSpace;u.convertToTexture;u.cos;u.cross;u.cubeTexture;u.dFdx;u.dFdy;u.dashSize;u.defaultBuildStages;u.defaultShaderStages;u.defined;u.degrees;u.deltaTime;u.densityFog;u.depth;u.depthPass;u.difference;u.diffuseColor;u.directPointLight;u.directionToColor;u.dispersion;u.distance;u.div;u.dodge;u.dot;u.drawIndex;u.dynamicBufferAttribute;u.element;u.emissive;u.equal;u.equals;u.equirectUV;u.exp;u.exp2;u.expression;u.faceDirection;u.faceForward;u.float;u.floor;u.fog;u.fract;u.frameGroup;u.frameId;u.frontFacing;u.fwidth;u.gain;u.gapSize;u.getConstNodeType;u.getCurrentStack;u.getDirection;u.getDistanceAttenuation;u.getGeometryRoughness;u.getNormalFromDepth;u.getParallaxCorrectNormal;u.getRoughness;u.getScreenPosition;u.getShIrradianceAt;u.getTextureIndex;u.getViewPosition;u.glsl;u.glslFn;u.grayscale;u.greaterThan;u.greaterThanEqual;u.hash;u.highPrecisionModelNormalViewMatrix;u.highPrecisionModelViewMatrix;u.hue;u.instance;u.instanceIndex;u.instancedArray;u.instancedBufferAttribute;u.instancedDynamicBufferAttribute;u.instancedMesh;u.int;u.inverseSqrt;u.invocationLocalIndex;u.invocationSubgroupIndex;u.ior;u.iridescence;u.iridescenceIOR;u.iridescenceThickness;u.ivec2;u.ivec3;u.ivec4;u.js;u.label;u.length;u.lengthSq;u.lessThan;u.lessThanEqual;u.lightPosition;u.lightTargetDirection;u.lightTargetPosition;u.lightViewPosition;u.lightingContext;u.lights;u.linearDepth;u.linearToneMapping;u.localId;u.log;u.log2;u.logarithmicDepthToViewZ;u.loop;u.luminance;u.mat2;u.mat3;u.mat4;u.matcapUV;u.materialAOMap;u.materialAlphaTest;u.materialAnisotropy;u.materialAnisotropyVector;u.materialAttenuationColor;u.materialAttenuationDistance;u.materialClearcoat;u.materialClearcoatNormal;u.materialClearcoatRoughness;u.materialColor;u.materialDispersion;u.materialEmissive;u.materialIOR;u.materialIridescence;u.materialIridescenceIOR;u.materialIridescenceThickness;u.materialLightMap;u.materialLineDashOffset;u.materialLineDashSize;u.materialLineGapSize;u.materialLineScale;u.materialLineWidth;u.materialMetalness;u.materialNormal;u.materialOpacity;u.materialPointWidth;u.materialReference;u.materialReflectivity;u.materialRefractionRatio;u.materialRotation;u.materialRoughness;u.materialSheen;u.materialSheenRoughness;u.materialShininess;u.materialSpecular;u.materialSpecularColor;u.materialSpecularIntensity;u.materialSpecularStrength;u.materialThickness;u.materialTransmission;u.max;u.maxMipLevel;u.metalness;u.min;u.mix;u.mixElement;u.mod;u.modInt;u.modelDirection;u.modelNormalMatrix;u.modelPosition;u.modelScale;u.modelViewMatrix;u.modelViewPosition;u.modelViewProjection;u.modelWorldMatrix;u.modelWorldMatrixInverse;u.morphReference;u.mrt;u.mul;u.mx_aastep;u.mx_cell_noise_float;u.mx_contrast;u.mx_fractal_noise_float;u.mx_fractal_noise_vec2;u.mx_fractal_noise_vec3;u.mx_fractal_noise_vec4;u.mx_hsvtorgb;u.mx_noise_float;u.mx_noise_vec3;u.mx_noise_vec4;u.mx_ramplr;u.mx_ramptb;u.mx_rgbtohsv;u.mx_safepower;u.mx_splitlr;u.mx_splittb;u.mx_srgb_texture_to_lin_rec709;u.mx_transform_uv;u.mx_worley_noise_float;u.mx_worley_noise_vec2;u.mx_worley_noise_vec3;u.negate;u.neutralToneMapping;u.nodeArray;u.nodeImmutable;u.nodeObject;u.nodeObjects;u.nodeProxy;u.normalFlat;u.normalGeometry;u.normalLocal;u.normalMap;u.normalView;u.normalWorld;u.normalize;u.not;u.notEqual;u.numWorkgroups;u.objectDirection;u.objectGroup;u.objectPosition;u.objectScale;u.objectViewPosition;u.objectWorldMatrix;u.oneMinus;u.or;u.orthographicDepthToViewZ;u.oscSawtooth;u.oscSine;u.oscSquare;u.oscTriangle;u.output;u.outputStruct;u.overlay;u.overloadingFn;u.parabola;u.parallaxDirection;u.parallaxUV;u.parameter;u.pass;u.passTexture;u.pcurve;u.perspectiveDepthToViewZ;u.pmremTexture;u.pointUV;u.pointWidth;u.positionGeometry;u.positionLocal;u.positionPrevious;u.positionView;u.positionViewDirection;u.positionWorld;u.positionWorldDirection;u.posterize;u.pow;u.pow2;u.pow3;u.pow4;u.property;u.radians;u.rand;u.range;u.rangeFog;u.reciprocal;u.reference;u.referenceBuffer;u.reflect;u.reflectVector;u.reflectView;u.reflector;u.refract;u.refractVector;u.refractView;u.reinhardToneMapping;u.remainder;u.remap;u.remapClamp;u.renderGroup;u.renderOutput;u.rendererReference;u.rotate;u.rotateUV;u.roughness;u.round;u.rtt;u.sRGBTransferEOTF;u.sRGBTransferOETF;u.sampler;u.saturate;u.saturation;u.screen;u.screenCoordinate;u.screenSize;u.screenUV;u.scriptable;u.scriptableValue;u.select;u.setCurrentStack;u.shaderStages;u.shadow;u.sharedUniformGroup;u.sheen;u.sheenRoughness;u.shiftLeft;u.shiftRight;u.shininess;u.sign;u.sin;u.sinc;u.skinning;u.skinningReference;u.smoothstep;u.smoothstepElement;u.specularColor;u.specularF90;u.spherizeUV;u.split;u.spritesheetUV;u.sqrt;u.stack;u.step;u.storage;u.storageBarrier;u.storageObject;u.storageTexture;u.string;u.sub;u.subgroupIndex;u.subgroupSize;u.tan;u.tangentGeometry;u.tangentLocal;u.tangentView;u.tangentWorld;u.temp;u.texture;u.texture3D;u.textureBarrier;u.textureBicubic;u.textureCubeUV;u.textureLoad;u.textureSize;u.textureStore;u.thickness;u.threshold;u.time;u.timerDelta;u.timerGlobal;u.timerLocal;u.toOutputColorSpace;u.toWorkingColorSpace;u.toneMapping;u.toneMappingExposure;u.toonOutlinePass;u.transformDirection;u.transformNormal;u.transformNormalToView;u.transformedBentNormalView;u.transformedBitangentView;u.transformedBitangentWorld;u.transformedClearcoatNormalView;u.transformedNormalView;u.transformedNormalWorld;u.transformedTangentView;u.transformedTangentWorld;u.transmission;u.transpose;u.tri;u.tri3;u.triNoise3D;u.triplanarTexture;u.triplanarTextures;u.trunc;u.tslFn;u.uint;const ji=u.uniform;u.uniformArray;u.uniformGroup;u.uniforms;u.userData;u.uv;u.uvec2;u.uvec3;u.uvec4;u.varying;u.varyingProperty;u.vec2;u.vec3;u.vec4;u.vectorComponents;u.velocity;u.vertexColor;u.vertexIndex;u.vibrance;u.viewZToLogarithmicDepth;u.viewZToOrthographicDepth;u.viewZToPerspectiveDepth;u.viewport;u.viewportBottomLeft;u.viewportCoordinate;u.viewportDepthTexture;u.viewportLinearDepth;u.viewportMipTexture;u.viewportResolution;u.viewportSafeUV;u.viewportSharedTexture;u.viewportSize;u.viewportTexture;u.viewportTopLeft;u.viewportUV;u.wgsl;u.wgslFn;u.workgroupArray;u.workgroupBarrier;u.workgroupId;u.workingToColorSpace;u.xor;function Es(i){return new Nd({color:i,metalness:0,roughness:.8,flatShading:!1})}Es(8190976),Es(2263842),Es(16775885),Es(16738740),Es(12211667),Es(8900346),new Ua({color:16777215,transparent:!0,opacity:0,side:Nu,blending:vu,depthWrite:!1});new Jt;ji(Oo(8900331));ji(Oo(16758465));ji(0);ji(Oo(16777215));
