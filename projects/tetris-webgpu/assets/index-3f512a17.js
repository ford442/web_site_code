(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function n(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=n(i);fetch(i.href,r)}})();class D{constructor(){this.reset()}get level(){return Math.floor(this.lines*.1)}createPiece(){const n="IJLOSTZ"[Math.floor(Math.random()*7)],s={blocks:[],x:0,y:0};switch(n){case"I":s.blocks=[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]];break;case"J":s.blocks=[[2,2,2],[0,0,2],[0,0,0]];break;case"L":s.blocks=[[3,0,0],[3,0,0],[3,3,0]];break;case"O":s.blocks=[[0,0,0,0],[0,4,4,0],[0,4,4,0],[0,0,0,0]];break;case"S":s.blocks=[[0,5,5],[5,5,0],[0,0,0]];break;case"T":s.blocks=[[6,6,6],[0,6,0],[0,0,0]];break;case"Z":s.blocks=[[7,7,0],[0,7,7],[0,0,0]];break;default:throw new Error("Что то пошло не так!")}return s.x=4,s.y=-2,s}getState(){const e=[[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0]];for(let n=0;n<this.playfield.length;n++){const s=this.playfield[n];for(let i=0;i<s.length;i++){const r=s[i];e[n][i]=r;const{y:a,x:o,blocks:f}=this.activPiece;for(let h=0;h<f.length;h++)for(let l=0;l<f[h].length;l++)f[h][l]&&a+h>=0&&(e[a+h][o+l]=f[h][l])}}return{score:this.score,level:this.level,lines:this.lines,nextPiece:this.nextPiece,isGameOwer:this.gameower,playfield:e}}reset(){this.score=0,this.lines=0,this.gameower=!1,this.playfield=[[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0]],this.activPiece=this.createPiece(),this.nextPiece=this.createPiece()}movePieceLeft(){this.activPiece.x-=1,this.hasCollision()&&(this.activPiece.x+=1)}movePieceRight(){this.activPiece.x+=1,this.hasCollision()&&(this.activPiece.x-=1)}movePieceDown(){if(this.activPiece.y+=1,this.hasCollision()){this.activPiece.y-=1,this.lockPiece();const e=this.clearLine();e&&this.updateScore(e),this.updatePieces()}}rotatePiece(e=!0){const n=this.activPiece.blocks,s=n.length,i=[];for(let r=0;r<s;r++)i[r]=new Array(s).fill(0);if(e)for(let r=0;r<s;r++)for(let a=0;a<s;a++)i[a][r]=n[s-1-r][a];else for(let r=0;r<s;r++)for(let a=0;a<s;a++)i[a][r]=n[r][s-1-a];this.activPiece.blocks=i,this.hasCollision()&&(this.activPiece.blocks=n)}hasCollision(){const e=this.playfield,{y:n,x:s,blocks:i}=this.activPiece;for(let r=0;r<i.length;r++)for(let a=0;a<i[r].length;a++)if(i[r][a]!==0&&n+r>=0&&(e[n+r]===void 0||e[n+r][s+a]===void 0||e[n+r][s+a]>=1))return!0;return!1}lockPiece(){const{y:e,x:n,blocks:s}=this.activPiece;for(let i=0;i<s.length;i++)for(let r=0;r<s[i].length;r++)e<0?this.gameower=!0:s[i][r]&&(this.playfield[e+i][n+r]=s[i][r])}updatePieces(){this.activPiece=this.nextPiece,this.nextPiece=this.createPiece()}clearLine(){let e=[],n=this.playfield;for(let s=n.length-1;s>=0;s--){const i=n[s];let r=!0;for(let a=0;a<i.length;a++)i[a]==0&&(r=!1);r&&(e.unshift(s),console.log(e))}for(let s=0;s<e.length;s++){const i=e[s];this.playfield.splice(i,1);const r=new Array(10);r.fill(0),this.playfield.unshift(r),this.lines+=1}return e.length}updateScore(e){this.score+=e*e*10,console.log("score = "+this.score)}}var L=1e-6,C=typeof Float32Array<"u"?Float32Array:Array;function A(){var t=new C(16);return C!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0),t[0]=1,t[5]=1,t[10]=1,t[15]=1,t}function R(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function _(t,e){if(t===e){var n=e[1],s=e[2],i=e[3],r=e[6],a=e[7],o=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=n,t[6]=e[9],t[7]=e[13],t[8]=s,t[9]=r,t[11]=e[14],t[12]=i,t[13]=a,t[14]=o}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}function k(t,e){var n=e[0],s=e[1],i=e[2],r=e[3],a=e[4],o=e[5],f=e[6],h=e[7],l=e[8],d=e[9],p=e[10],c=e[11],P=e[12],y=e[13],b=e[14],w=e[15],M=n*o-s*a,v=n*f-i*a,u=n*h-r*a,m=s*f-i*o,g=s*h-r*o,U=i*h-r*f,B=l*y-d*P,G=l*b-p*P,I=l*w-c*P,T=d*b-p*y,E=d*w-c*y,O=p*w-c*b,x=M*O-v*E+u*T+m*I-g*G+U*B;return x?(x=1/x,t[0]=(o*O-f*E+h*T)*x,t[1]=(i*E-s*O-r*T)*x,t[2]=(y*U-b*g+w*m)*x,t[3]=(p*g-d*U-c*m)*x,t[4]=(f*I-a*O-h*G)*x,t[5]=(n*O-i*I+r*G)*x,t[6]=(b*u-P*U-w*v)*x,t[7]=(l*U-p*u+c*v)*x,t[8]=(a*E-o*I+h*B)*x,t[9]=(s*I-n*E-r*B)*x,t[10]=(P*g-y*u+w*M)*x,t[11]=(d*u-l*g-c*M)*x,t[12]=(o*G-a*T-f*B)*x,t[13]=(n*T-s*G+i*B)*x,t[14]=(y*v-P*m-b*M)*x,t[15]=(l*m-d*v+p*M)*x,t):null}function X(t,e,n){var s=e[0],i=e[1],r=e[2],a=e[3],o=e[4],f=e[5],h=e[6],l=e[7],d=e[8],p=e[9],c=e[10],P=e[11],y=e[12],b=e[13],w=e[14],M=e[15],v=n[0],u=n[1],m=n[2],g=n[3];return t[0]=v*s+u*o+m*d+g*y,t[1]=v*i+u*f+m*p+g*b,t[2]=v*r+u*h+m*c+g*w,t[3]=v*a+u*l+m*P+g*M,v=n[4],u=n[5],m=n[6],g=n[7],t[4]=v*s+u*o+m*d+g*y,t[5]=v*i+u*f+m*p+g*b,t[6]=v*r+u*h+m*c+g*w,t[7]=v*a+u*l+m*P+g*M,v=n[8],u=n[9],m=n[10],g=n[11],t[8]=v*s+u*o+m*d+g*y,t[9]=v*i+u*f+m*p+g*b,t[10]=v*r+u*h+m*c+g*w,t[11]=v*a+u*l+m*P+g*M,v=n[12],u=n[13],m=n[14],g=n[15],t[12]=v*s+u*o+m*d+g*y,t[13]=v*i+u*f+m*p+g*b,t[14]=v*r+u*h+m*c+g*w,t[15]=v*a+u*l+m*P+g*M,t}function N(t,e,n){var s=n[0],i=n[1],r=n[2],a,o,f,h,l,d,p,c,P,y,b,w;return e===t?(t[12]=e[0]*s+e[4]*i+e[8]*r+e[12],t[13]=e[1]*s+e[5]*i+e[9]*r+e[13],t[14]=e[2]*s+e[6]*i+e[10]*r+e[14],t[15]=e[3]*s+e[7]*i+e[11]*r+e[15]):(a=e[0],o=e[1],f=e[2],h=e[3],l=e[4],d=e[5],p=e[6],c=e[7],P=e[8],y=e[9],b=e[10],w=e[11],t[0]=a,t[1]=o,t[2]=f,t[3]=h,t[4]=l,t[5]=d,t[6]=p,t[7]=c,t[8]=P,t[9]=y,t[10]=b,t[11]=w,t[12]=a*s+l*i+P*r+e[12],t[13]=o*s+d*i+y*r+e[13],t[14]=f*s+p*i+b*r+e[14],t[15]=h*s+c*i+w*r+e[15]),t}function q(t,e,n,s,i){var r=1/Math.tan(e/2);if(t[0]=r/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=r,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,i!=null&&i!==1/0){var a=1/(s-i);t[10]=(i+s)*a,t[14]=2*i*s*a}else t[10]=-1,t[14]=-2*s;return t}var V=q;function F(t,e,n,s){var i,r,a,o,f,h,l,d,p,c,P=e[0],y=e[1],b=e[2],w=s[0],M=s[1],v=s[2],u=n[0],m=n[1],g=n[2];return Math.abs(P-u)<L&&Math.abs(y-m)<L&&Math.abs(b-g)<L?R(t):(l=P-u,d=y-m,p=b-g,c=1/Math.sqrt(l*l+d*d+p*p),l*=c,d*=c,p*=c,i=M*p-v*d,r=v*l-w*p,a=w*d-M*l,c=Math.sqrt(i*i+r*r+a*a),c?(c=1/c,i*=c,r*=c,a*=c):(i=0,r=0,a=0),o=d*a-p*r,f=p*i-l*a,h=l*r-d*i,c=Math.sqrt(o*o+f*f+h*h),c?(c=1/c,o*=c,f*=c,h*=c):(o=0,f=0,h=0),t[0]=i,t[1]=o,t[2]=l,t[3]=0,t[4]=r,t[5]=f,t[6]=d,t[7]=0,t[8]=a,t[9]=h,t[10]=p,t[11]=0,t[12]=-(i*P+r*y+a*b),t[13]=-(o*P+f*y+h*b),t[14]=-(l*P+d*y+p*b),t[15]=1,t)}const Y=()=>{const t=new Float32Array([-1,-1,1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,-1,1,-1,-1,1,-1,1,-1,-1,1]),e=new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0]);return{positions:t,normals:e}},H=()=>{let t={};t.color="(0.0, 1.0, 0.0)",t.ambientIntensity="0.2",t.diffuseIntensity="0.8",t.specularIntensity="0.4",t.shininess="150.0",t.specularColor="(1.0, 1.0, 1.0)",t.isPhong="1";const e=`
            struct Uniforms {
                viewProjectionMatrix : mat4x4<f32>,
                modelMatrix : mat4x4<f32>,
                normalMatrix : mat4x4<f32>,  
                colorVertex : vec4<f32>              
            };
            @binding(0) @group(0) var<uniform> uniforms : Uniforms;

            struct Output {
                @builtin(position) Position : vec4<f32>,
                @location(0) vPosition : vec4<f32>,
                @location(1) vNormal : vec4<f32>,
                @location(2) vColor : vec4<f32>             
              
            };
          
            @vertex
            fn main(@location(0) position: vec4<f32>, @location(1) normal: vec4<f32>) -> Output {
                var output: Output;
                let mPosition:vec4<f32> = uniforms.modelMatrix * position;
                output.vPosition = mPosition;
                output.vNormal   =  uniforms.normalMatrix*normal;
                output.Position  = uniforms.viewProjectionMatrix * mPosition;
                output.vColor   =  uniforms.colorVertex;
                return output;
            }`,n=`
            struct Uniforms {
                lightPosition : vec4<f32>,
                eyePosition : vec4<f32>,
                color : vec4<f32>
            };
            @binding(1) @group(0) var<uniform> uniforms : Uniforms;

            @fragment
            fn main(@location(0) vPosition: vec4<f32>, @location(1) vNormal: vec4<f32>,@location(2) vColor: vec4<f32>) ->  @location(0) vec4<f32> {
               
              let N:vec3<f32> = normalize(vNormal.xyz);
                let L:vec3<f32> = normalize(uniforms.lightPosition.xyz - vPosition.xyz);
                let V:vec3<f32> = normalize(uniforms.eyePosition.xyz - vPosition.xyz);
                let H:vec3<f32> = normalize(L + V);
                let diffuse:f32 = 0.8 * max(dot(N, L), 0.0);
                var specular:f32;
                var isp:i32 = ${t.isPhong};
                if(isp == 1){
                    specular = ${t.specularIntensity} * pow(max(dot(V, reflect(-L, N)),0.0), ${t.shininess});
                } else {
                    specular = ${t.specularIntensity} * pow(max(dot(N, H),0.0), ${t.shininess});
                }
                let ambient:f32 = ${t.ambientIntensity};
                let finalColor:vec3<f32> = vColor.xyz * (ambient + diffuse) + vec3<f32>${t.specularColor}*specular;
                return vec4<f32>(finalColor, 1.0);
            }`;return{vertex:e,fragment:n}},$={playfield:[[7,2,3,4,5,6,7,0,1,1],[4,5,6,0,0,0,0,0,0,1],[0,5,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,1,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,1,0,0,1,1,1,0,0],[0,1,1,1,0,0,1,0,0,0],[0,0,0,0,0,0,2,0,0,0],[0,1,0,0,7,6,0,0,0,0],[0,0,0,0,0,5,2,0,0,0],[0,0,0,0,0,4,2,0,0,0],[0,0,0,0,0,3,2,2,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,1],[1,1,0,0,0,0,0,0,1,1]]};class J{constructor(e,n,s,i,r,a){if(this.themes={pastel:{0:[.3,.3,.3],1:[.69,.92,.95],2:[.73,.87,.98],3:[1,.8,.74],4:[1,.98,.77],5:[.78,.9,.79],6:[.88,.75,.91],7:[1,.8,.82],border:[.82,.77,.91]},neon:{0:[.1,.1,.1],1:[0,1,1],2:[0,0,1],3:[1,.5,0],4:[1,1,0],5:[0,1,0],6:[.5,0,1],7:[1,0,0],border:[1,1,1]}},this.currentTheme=this.themes.pastel,this.CreateGPUBuffer=(o,f,h=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST)=>{const l=o.createBuffer({size:f.byteLength,usage:h,mappedAtCreation:!0});return new Float32Array(l.getMappedRange()).set(f),l.unmap(),l},this.Frame=()=>{let o=this.ctxWebGPU.getCurrentTexture().createView();const f=this.device.createTexture({size:[this.canvasWebGPU.width,this.canvasWebGPU.height,1],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});this.renderPassDescription={colorAttachments:[{view:o,loadValue:{r:0,g:0,b:0,a:0},storeOp:"store",loadOp:"clear"}],depthStencilAttachment:{view:f.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},this.renderPlayfild_WebGPU(this.state);const h=this.device.createCommandEncoder(),l=h.beginRenderPass(this.renderPassDescription);l.setPipeline(this.pipeline),l.setVertexBuffer(0,this.vertexBuffer),l.setVertexBuffer(1,this.normalBuffer);let d=this.uniformBindGroup_ARRAY_border.length;for(let c=0;c<d;c++)l.setBindGroup(0,this.uniformBindGroup_ARRAY_border[c]),l.draw(this.numberOfVertices);let p=this.uniformBindGroup_ARRAY.length;for(let c=0;c<p;c++)l.setBindGroup(0,this.uniformBindGroup_ARRAY[c]),l.draw(this.numberOfVertices);l.end(),this.device.queue.submit([h.finish()]),requestAnimationFrame(this.Frame)},this.CheckWebGPU=()=>{let o="Great, your current browser supports WebGPU!",f=!0;return navigator.gpu||(o=`Your current browser does not support WebGPU! Make sure you are on a system 
                         with WebGPU enabled. Currently, SPIR-WebGPU is only supported in  
                         <a href="https://www.google.com/chrome/canary/">Chrome canary</a>
                         with the flag "enable-unsafe-webgpu" enabled. See the 
                         <a href="https://github.com/gpuweb/gpuweb/wiki/Implementation-Status"> 
                         Implementation Status</a> page for more details.                   
                        `,f=!1),{result:f,description:o}},this.element=e,this.width=n,this.heigh=s,this.nextPieceContext=a,this.canvasWebGPU=document.createElement("canvas"),this.canvasWebGPU.id="canvaswebgpu",this.canvasWebGPU.style.position="absolute",this.canvasWebGPU.style.top="0",this.canvasWebGPU.style.left="0",this.canvasWebGPU.style.pointerEvents="none",this.canvasWebGPU.width=this.width,this.canvasWebGPU.height=this.heigh,this.ctxWebGPU=this.canvasWebGPU.getContext("webgpu"),this.isWebGPU=this.CheckWebGPU(),this.playfildBorderWidth=4,this.playfildX=this.playfildBorderWidth+1,this.playfildY=this.playfildBorderWidth+1,this.playfildWidth=this.width*2/3,this.playfildHeight=this.heigh,this.playfildInnerWidth=this.playfildWidth-this.playfildBorderWidth*2,this.playfildInnerHeight=this.playfildHeight-this.playfildBorderWidth*2-2,this.blockWidth=this.playfildInnerWidth/r,this.blockHeight=this.playfildInnerHeight/i,this.panelX=this.playfildWidth+10,this.panelY=0,this.panelWidth=this.width/3,this.panelHeight=this.heigh,this.state={playfield:[[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0]]},this.blockData={},this.isWebGPU.result)this.element.appendChild(this.canvasWebGPU),this.preRender(),window.addEventListener("resize",this.resize.bind(this));else{let o=document.createElement("div");o.innerText=this.isWebGPU.description,this.element.appendChild(o)}}resize(){if(!this.device)return;this.width=window.innerWidth,this.heigh=window.innerHeight,this.canvasWebGPU.width=this.width,this.canvasWebGPU.height=this.heigh;const e=window.devicePixelRatio||1,n=[this.canvasWebGPU.width*e,this.canvasWebGPU.height*e],s=navigator.gpu.getPreferredCanvasFormat();this.ctxWebGPU.configure({device:this.device,format:s,size:n,alphaMode:"premultiplied"}),R(this.PROJMATRIX);let i=40*Math.PI/180;V(this.PROJMATRIX,i,this.canvasWebGPU.width/this.canvasWebGPU.height,1,150),this.vpMatrix=A(),R(this.vpMatrix),X(this.vpMatrix,this.PROJMATRIX,this.VIEWMATRIX)}setTheme(e){this.currentTheme=this.themes[e],this.renderPlayfild_Border_WebGPU()}renderNextPiece(e){this.nextPieceContext.clearRect(0,0,this.nextPieceContext.canvas.width,this.nextPieceContext.canvas.height);const{blocks:n}=e,s=20,i=Object.values(this.currentTheme);n.forEach((r,a)=>{r.forEach((o,f)=>{if(o>0){const h=i[o];this.nextPieceContext.fillStyle=`rgb(${h[0]*255}, ${h[1]*255}, ${h[2]*255})`,this.nextPieceContext.fillRect(f*s,a*s,s,s)}})})}renderMainScreen(e){this.clearScreen(e),this.renderPlayfild_WebGPU(e),this.renderNextPiece(e.nextPiece),document.getElementById("score").textContent=e.score,document.getElementById("lines").textContent=e.lines,document.getElementById("level").textContent=e.level}clearScreen({lines:e,score:n}){let s=document.querySelector("#info1");s.innerHTML="Line :"+e+" Score :"+n;let i=document.querySelector("#info2");i.innerHTML="-----------------------------"}renderStartScreen(){let e=document.querySelector("#info1");e.innerHTML="Press ENTER to Start";let n=document.querySelector("#info2");n.innerHTML="-----------------------------"}renderPauseScreen(){let e=document.querySelector("#info1");e.innerHTML="Press ENTER to Resume";let n=document.querySelector("#info2");n.innerHTML="-----------------------------"}renderEndScreen({score:e}){document.getElementById("game-over").style.display="block"}async preRender(){const e=await navigator.gpu.requestAdapter();this.device=await e.requestDevice();const n=window.devicePixelRatio||1,s=[this.canvasWebGPU.width*n,this.canvasWebGPU.height*n],i=navigator.gpu.getPreferredCanvasFormat();this.ctxWebGPU.configure({device:this.device,format:i,size:s,alphaMode:"premultiplied"});const r=H(),a=Y();this.numberOfVertices=a.positions.length/3,this.vertexBuffer=this.CreateGPUBuffer(this.device,a.positions),this.normalBuffer=this.CreateGPUBuffer(this.device,a.normals),this.pipeline=this.device.createRenderPipeline({label:"main pipeline",layout:"auto",vertex:{module:this.device.createShaderModule({code:r.vertex}),entryPoint:"main",buffers:[{arrayStride:12,attributes:[{shaderLocation:0,format:"float32x3",offset:0}]},{arrayStride:12,attributes:[{shaderLocation:1,format:"float32x3",offset:0}]}]},fragment:{module:this.device.createShaderModule({code:r.fragment}),entryPoint:"main",targets:[{format:i}]},primitive:{topology:"triangle-list"},depthStencil:{format:"depth24plus",depthWriteEnabled:!0,depthCompare:"less"}}),this.fragmentUniformBuffer=this.device.createBuffer({size:48,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.MODELMATRIX=A(),this.NORMALMATRIX=A(),this.VIEWMATRIX=A(),this.PROJMATRIX=A();let o=[0,-20,75],f=new Float32Array([-5,0,0]);R(this.VIEWMATRIX),F(this.VIEWMATRIX,o,[9,-20,0],[0,1,0]),R(this.PROJMATRIX);let h=40*Math.PI/180;V(this.PROJMATRIX,h,this.canvasWebGPU.width/this.canvasWebGPU.height,1,150),this.vpMatrix=A(),R(this.vpMatrix),X(this.vpMatrix,this.PROJMATRIX,this.VIEWMATRIX),this.device.queue.writeBuffer(this.fragmentUniformBuffer,0,new Float32Array(o)),this.device.queue.writeBuffer(this.fragmentUniformBuffer,16,f),this.device.queue.writeBuffer(this.fragmentUniformBuffer,32,new Float32Array(this.currentTheme[5]));let l=this.ctxWebGPU.getCurrentTexture().createView();const d=this.device.createTexture({size:[this.canvasWebGPU.width,this.canvasWebGPU.height,1],format:"depth24plus",usage:GPUTextureUsage.RENDER_ATTACHMENT});this.renderPassDescription={colorAttachments:[{view:l,loadValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:d.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store"}},this.renderPlayfild_Border_WebGPU(),this.vertexUniformBuffer=this.device.createBuffer({size:$.playfield.length*10*256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.Frame()}async renderPlayfild_WebGPU({playfield:e}){this.x+=.01;const n=e.length;this.uniformBindGroup_ARRAY=[];let s=0;for(let i=0;i<n;i++)for(let r=0;r<e[i].length;r++){if(!e[i][r])continue;let a=e[i][r],o=this.device.createBindGroup({label:"uniformBindGroup_next",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.vertexUniformBuffer,offset:s,size:208}},{binding:1,resource:{buffer:this.fragmentUniformBuffer,offset:0,size:48}}]});R(this.MODELMATRIX),R(this.NORMALMATRIX),N(this.MODELMATRIX,this.MODELMATRIX,[r*2.2,i*-2.2,0]),R(this.NORMALMATRIX),k(this.NORMALMATRIX,this.MODELMATRIX),_(this.NORMALMATRIX,this.NORMALMATRIX),this.device.queue.writeBuffer(this.vertexUniformBuffer,s+0,this.vpMatrix),this.device.queue.writeBuffer(this.vertexUniformBuffer,s+64,this.MODELMATRIX),this.device.queue.writeBuffer(this.vertexUniformBuffer,s+128,this.NORMALMATRIX),this.device.queue.writeBuffer(this.vertexUniformBuffer,s+192,new Float32Array(this.currentTheme[a])),this.uniformBindGroup_ARRAY.push(o),s+=256}}async renderPlayfild_Border_WebGPU(){const e={playfield:[[1,1,1,1,1,1,1,1,1,1,1,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1]]};this.x+=.01;const n=e.playfield.length,s=64*256;this.vertexUniformBuffer_border=this.device.createBuffer({size:s,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroup_ARRAY_border=[];let i=0;for(let r=0;r<n;r++)for(let a=0;a<e.playfield[r].length;a++){if(!e.playfield[r][a])continue;let o=this.device.createBindGroup({label:"uniformBindGroup_next 635",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.vertexUniformBuffer_border,offset:i,size:208}},{binding:1,resource:{buffer:this.fragmentUniformBuffer,offset:0,size:48}}]});R(this.MODELMATRIX),R(this.NORMALMATRIX),N(this.MODELMATRIX,this.MODELMATRIX,[a*2.2-2,r*-2.2+2,0]),R(this.NORMALMATRIX),k(this.NORMALMATRIX,this.MODELMATRIX),_(this.NORMALMATRIX,this.NORMALMATRIX),this.device.queue.writeBuffer(this.vertexUniformBuffer_border,i+0,this.vpMatrix),this.device.queue.writeBuffer(this.vertexUniformBuffer_border,i+64,this.MODELMATRIX),this.device.queue.writeBuffer(this.vertexUniformBuffer_border,i+128,this.NORMALMATRIX),this.device.queue.writeBuffer(this.vertexUniformBuffer_border,i+192,new Float32Array(this.currentTheme.border)),this.uniformBindGroup_ARRAY_border.push(o),i+=256}}}class j{constructor(e,n,s){this.game=e,this.view=n,this.viewWebGPU=s,this.isPlaying=!1,this.gameLoopID=null,this.intervalID=null,document.addEventListener("keydown",this.handleKeyDown.bind(this)),this.play()}update(){this.game.movePieceDown(),this.updateView()}play(){this.isPlaying=!0,this.startTimer(),this.updateView(),this.gameLoop(this)}pause(){this.isPlaying=!1,this.stopTimer(),this.updateView(),this.view.renderPauseScreen()}startTimer(){const e=1e3-this.game.getState().level*100;this.intervalID||(this.intervalID=setInterval(()=>{this.update()},e>0?e:100))}stopTimer(){this.intervalID&&(clearInterval(this.intervalID),this.intervalID=null)}updateView(){const e=this.game.getState();e.isGameOwer?(this.view.renderEndScreen(e),this.isPlaying=!1):this.isPlaying?this.view.renderMainScreen(e):this.view.renderPauseScreen()}reset(){this.game.reset(),this.play()}handleKeyDown(e){const n=this.game.getState();switch(e.keyCode){case 13:n.isGameOwer?this.reset():this.isPlaying?this.pause():this.play();break;case 37:this.game.movePieceLeft(),this.updateView();break;case 38:this.game.rotatePiece(),this.updateView();break;case 39:this.game.movePieceRight(),this.updateView();break;case 40:this.game.movePieceDown(),this.updateView();break}}gameLoop(e){let n=0;const s=function(i){if(n||(n=i),Math.abs(i-n)>=1e3/30){const r=e.game.getState();e.viewWebGPU.state=r,n=i}if(e.isPlaying==!1)return 0;window.requestAnimationFrame(s)};s(0)}}const K=document.getElementById("ui-container");K.innerHTML=`
  <h1>TETRIS</h1>
  <div class="theme-buttons">
    <button id="pastel-theme">Pastel</button>
    <button id="neon-theme">Neon</button>
  </div>
  <div class="info-line">
    <p>SCORE</p>
    <p id="score">0</p>
  </div>
  <div class="info-line">
    <p>LINES</p>
    <p id="lines">0</p>
  </div>
  <div class="info-line">
    <p>LEVEL</p>
    <p id="level">0</p>
  </div>
  <div id="next-piece-container">
    <p>NEXT</p>
    <canvas id="next-piece-canvas" width="80" height="80"></canvas>
  </div>
  <div class="control-buttons">
    <button id="start-button">START</button>
    <button id="pause-button">PAUSE</button>
  </div>
  <div id="game-over">GAME OVER</div>
  <div id="info1"></div>
  <div id="info2"></div>
`;const z=new D,W=new J(document.body,window.innerWidth,window.innerHeight,20,10,document.getElementById("next-piece-canvas").getContext("2d")),S=new j(z,W,W);document.getElementById("pastel-theme").addEventListener("click",()=>{document.body.className="pastel-theme",W.setTheme("pastel")});document.getElementById("neon-theme").addEventListener("click",()=>{document.body.className="neon-theme",W.setTheme("neon")});document.getElementById("start-button").addEventListener("click",()=>{S.play()});document.getElementById("pause-button").addEventListener("click",()=>{S.pause()});window.game=z;window.view=W;window.controller=S;document.getElementById("pastel-theme").click();
